<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="努力学习">
<meta property="og:type" content="website">
<meta property="og:title" content="赖宝的宝">
<meta property="og:url" content="http://blog.webtoatl.cn/page/2/index.html">
<meta property="og:site_name" content="赖宝的宝">
<meta property="og:description" content="努力学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赖宝的宝">
<meta name="twitter:description" content="努力学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.webtoatl.cn/page/2/"/>





  <title> 赖宝的宝 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖宝的宝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端技能分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/05/D3.js学习笔记：简单条形图制作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/D3.js学习笔记：简单条形图制作/" itemprop="url">
                  D3.js学习笔记：简单条形图制作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T00:00:00+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>D3简介</strong>：D3.js is a JavaScript library for manipulating documents based on data. D3 helps you bring data to life using HTML, SVG and CSS. D3’s emphasis on web standards gives you the full capabilities of modern browsers without tying yourself to a proprietary framework, combining powerful visualization components and a data-driven approach to DOM manipulation.</p>
<hr>
<h2 id="一、元素选择"><a href="#一、元素选择" class="headerlink" title="一、元素选择"></a>一、元素选择</h2><p>平常的程序如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div = document.createElement("div");</div><div class="line">div.innerHTML = "Hello, world!";</div><div class="line">document.body.appendChild(div);</div></pre></td></tr></table></figure>
<p>通过使用D3.js的selector程序如下所示（网页全代码）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://d3js.org/d3.v3.min.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line"><span class="keyword">var</span> body = d3.select(<span class="string">"body"</span>);</div><div class="line"><span class="keyword">var</span> div = body.append(<span class="string">"div"</span>);</div><div class="line">div.html(<span class="string">"Hello, world!"</span>);</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，d3.select的元素body可以替换成其他很多元素。</p>
<hr>
<h2 id="二、变换方法"><a href="#二、变换方法" class="headerlink" title="二、变换方法"></a>二、变换方法</h2><p>selection.attr返回当前的选择内容，selection.append返回一个新内容。以下为一些示例：</p>
<ul>
<li>改变body样式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> body = d3.select(<span class="string">"body"</span>);</div><div class="line">body.style(<span class="string">"color"</span>, <span class="string">"black"</span>);</div><div class="line">body.style(<span class="string">"background-color"</span>, <span class="string">"white"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>添加一个新div（section需在样式表中提前定义）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3.selectAll(<span class="string">"section"</span>)</div><div class="line">	.attr(<span class="string">"class"</span>, <span class="string">"special"</span>)</div><div class="line">  .append(<span class="string">"div"</span>)</div><div class="line">	.html(<span class="string">"Hello, world!"</span>);</div></pre></td></tr></table></figure>
<hr>
<h2 id="三、手动码表"><a href="#三、手动码表" class="headerlink" title="三、手动码表"></a>三、手动码表</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"></div><div class="line">.chart div &#123;</div><div class="line">  font: 10px sans-serif;</div><div class="line">  background-color: steelblue;</div><div class="line">  text-align: right;</div><div class="line">  padding: 3px;</div><div class="line">  margin: 1px;</div><div class="line">  color: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chart"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 40px;"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 80px;"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 150px;"</span>&gt;</span>15<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 160px;"</span>&gt;</span>16<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 230px;"</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 420px;"</span>&gt;</span>42<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="四、自动码表"><a href="#四、自动码表" class="headerlink" title="四、自动码表"></a>四、自动码表</h2><p>假设我们已经定义了chart的样式，则代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d3.select(<span class="string">".chart"</span>)</div><div class="line">  .selectAll(<span class="string">"div"</span>)</div><div class="line">	.data(data)</div><div class="line">  .enter().append(<span class="string">"div"</span>)</div><div class="line">	.style(<span class="string">"width"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d * <span class="number">10</span> + <span class="string">"px"</span>; &#125;)</div><div class="line">	.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</div></pre></td></tr></table></figure>
<p>select是选中chart块，而selectAll是选中chart中的已有和之后可能有的div块，data是用于数据绑定，enter().append()是为现在不存在的元素增加div块，style是设置显示长度，text是设置显示文字内容。</p>
<p>为了让条形图的长度适合，我们可以定下一个范围，让数据根据自身大小自行处理。x轴的长度设置如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = d3.scale.linear()</div><div class="line">	.domain([<span class="number">0</span>, d3.max(data)])</div><div class="line">	.range([<span class="number">0</span>, <span class="number">420</span>]);</div></pre></td></tr></table></figure>
<p>自动填补长度的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d3.select(<span class="string">".chart"</span>)</div><div class="line">  .selectAll(<span class="string">"div"</span>)</div><div class="line">	.data(data)</div><div class="line">  .enter().append(<span class="string">"div"</span>)</div><div class="line">	.style(<span class="string">"width"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> x(d) + <span class="string">"px"</span>; &#125;)</div><div class="line">	.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</div></pre></td></tr></table></figure>
<p>总代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"></div><div class="line">.chart div &#123;</div><div class="line">  font: 10px sans-serif;</div><div class="line">  background-color: steelblue;</div><div class="line">  text-align: right;</div><div class="line">  padding: 3px;</div><div class="line">  margin: 1px;</div><div class="line">  color: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://d3js.org/d3.v3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = d3.scale.linear()</div><div class="line">	.domain([<span class="number">0</span>, d3.max(data)])</div><div class="line">	.range([<span class="number">0</span>, <span class="number">420</span>]);</div><div class="line"></div><div class="line">d3.select(<span class="string">".chart"</span>)</div><div class="line">  .selectAll(<span class="string">"div"</span>)</div><div class="line">	.data(data)</div><div class="line">  .enter().append(<span class="string">"div"</span>)</div><div class="line">	.style(<span class="string">"width"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> x(d) + <span class="string">"px"</span>; &#125;)</div><div class="line">	.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/03/动手实现一个简单的浏览器端js模块加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/03/动手实现一个简单的浏览器端js模块加载器/" itemprop="url">
                  动手实现一个简单的浏览器端js模块加载器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T00:00:00+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在es6之前，js不像其他语言自带成熟的模块化功能，页面只能靠插入一个个script标签来引入自己的或第三方的脚本，并且容易带来命名冲突的问题。js社区做了很多努力，在当时的运行环境中，实现”模块”的效果。<br>通用的js模块化标准有CommonJS与AMD，前者运用于node环境，后者在浏览器环境中由Require.js等实现。此外还有国内的开源项目Sea.js，遵循CMD规范。（目前随着es6的普及已经停止维护，不论是AMD还是CMD，都将是一段历史了）</p>
<h3 id="浏览器端js加载器"><a href="#浏览器端js加载器" class="headerlink" title="浏览器端js加载器"></a>浏览器端js加载器</h3><p>实现一个简单的js加载器并不复杂，主要可以分为 <strong>解析路径、下载模块、解析模块依赖、解析模块</strong> 四个步骤。<br>首先定义一下模块。在各种规范中，通常一个js文件即表示一个模块。那么，我们可以在模块文件中，构造一个闭包，并传出一个对象，作为模块的导出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(factory() &#123;</div><div class="line">    <span class="keyword">var</span> x = &#123;</div><div class="line">        <span class="attr">a</span>: <span class="number">1</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>define函数接收一个工厂函数参数，浏览器执行该脚本时，define函数执行factory，并把它的return值存储在加载器的模块对象modules里。<br>如何 <strong>标识</strong> 一个模块呢？可以用文件的 <strong>uri</strong>，它是唯一标识，是天然的id。<br>文件路径path有几种形式：</p>
<p>绝对路径：<a href="http://xxx" target="_blank" rel="external">http://xxx</a>, file://xxx</p>
<p>相对路径：./xxx ， ../xxx ， xxx(相对当前页面的文件路径)</p>
<p>虚拟绝对路径：/xxx /表示网站根目录<br>因此，需要一个resolvePath函数来将不同形式的path解析成uri，参照当前页面的文件路径来解析。</p>
<p>接着，假设我们需要引用a.js与b.js两个模块，并设置了需要a与b才能执行的回调函数f。我们希望加载器去拉取a与b，当a与b都加载完成后，从modules里取出a与b作为参数传给f，执行下一步操作。这里可以用观察者模式（即订阅/发布模式）实现，创建一个eventProxy，订阅加载a与加载b事件；define函数执行到最后，已经把导出挂载modules里之后，emit一个本模块加载完成的事件，eventProxy收到后检查a与b是否都加载完成，如果完成，就传参给f执行回调。</p>
<p>同理，eventProxy也可以实现模块依赖加载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define([ <span class="string">'c.js'</span>, <span class="string">'d.js'</span> ], factory (c, d) &#123;</div><div class="line">    <span class="keyword">var</span> x = c + d;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>define函数的第一个参数可以传入一个依赖数组，表示a模块依赖c与d。define执行时，告诉eventProxy订阅c与d加载事件，加载好了就执行回调函数f存储a的导出，并emit事件a已加载。</p>
<p>浏览器端加载脚本的原始方法是插入一个 <strong>script</strong> 标签，指定src之后，浏览器开始下载该脚本。<br>那么加载器中的模块加载可以用dom操作实现，插入一个script标签并指定src，此时该模块为下载中状态。<br>PS：浏览器中，动态插入script标签与初次加载页面dom时的script加载方式不同：</p>
<p>初次加载页面，浏览器会从上到下顺序解析dom，碰到script标签时，下载脚本并阻塞dom解析，等到该脚本下载、执行完毕后再继续解析之后的dom（现代浏览器做了preload优化，会预先下载好多个脚本，但执行顺序与它们在dom中顺序一致，执行时阻塞其他dom解析）</p>
<p>动态插入script，<strong>var a = document.createElement(‘script’); a.src=’xxx’; document.body.appendChild(a)</strong>;浏览器会在该脚本下载完成后执行，过程是异步的。</p>
<p>下载完成后执行上述的操作，解析依赖-&gt;加载依赖-&gt;解析本模块-&gt;加载完成-&gt;执行回调。</p>
<p>模块下载完成后，如何在解析它时知道它的uri呢？有两种发发，一种是用 <strong>srcipt.onload</strong> 获取 <strong>this</strong> 对象的src属性；一种是在define函数中采用 <strong>document.currentScript.src</strong>。</p>
<p>实现基本的功能比较简单，代码不到200行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zmm = &#123;</div><div class="line">    <span class="attr">_modules</span>: &#123;&#125;,</div><div class="line">    <span class="attr">_configs</span>: &#123;</div><div class="line">        <span class="comment">// 用于拼接相对路径</span></div><div class="line">        basePath: (<span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (path.charAt(path.length - <span class="number">1</span>) === <span class="string">'/'</span>) &#123;</div><div class="line">                path = path.substr(<span class="number">0</span>, path.length - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> path.substr(path.indexOf(location.host) + location.host.length + <span class="number">1</span>);</div><div class="line">        &#125;)(location.href),</div><div class="line">        <span class="comment">// 用于拼接相对根路径</span></div><div class="line">        host: location.protocol + <span class="string">'//'</span> + location.host + <span class="string">'/'</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.hasModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断是否已有该模块，不论加载中或已加载好</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._modules.hasOwnProperty(_uri);</div><div class="line">&#125;;</div><div class="line">zmm.isModuleLoaded = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断该模块是否已加载好</span></div><div class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>._modules[_uri];</div><div class="line">&#125;;</div><div class="line">zmm.pushModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 新模块占坑，但此时还未加载完成，表示加载中；防止重复加载</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._modules.hasOwnProperty(_uri)) &#123;</div><div class="line">        <span class="keyword">this</span>._modules[_uri] = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">zmm.installModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri, mod</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._modules[_uri] = mod;</div><div class="line">&#125;;</div><div class="line">zmm.load = <span class="function"><span class="keyword">function</span> (<span class="params">uris</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i, nsc;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; uris.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.hasModule(uris[i])) &#123;</div><div class="line">            <span class="keyword">this</span>.pushModule(uris[i]);</div><div class="line">            <span class="comment">// 开始加载</span></div><div class="line">            <span class="keyword">var</span> nsc = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">                nsc.src = uri;</div><div class="line">            <span class="built_in">document</span>.body.appendChild(nsc);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.resolvePath = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="comment">// 返回绝对路径</span></div><div class="line">    <span class="keyword">var</span> res = <span class="string">''</span>, paths = [], resPaths;</div><div class="line">    <span class="keyword">if</span> (path.match(<span class="regexp">/.*:\/\/.*/</span>)) &#123;</div><div class="line">        <span class="comment">// 绝对路径</span></div><div class="line">        res = path.match(<span class="regexp">/.*:\/\/.*?\//</span>)[<span class="number">0</span>]; <span class="comment">// 协议+域名</span></div><div class="line">        path = path.substr(res.length);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.charAt(<span class="number">0</span>) === <span class="string">'/'</span>) &#123;</div><div class="line">        <span class="comment">// 相对根路径 /开头</span></div><div class="line">        res = <span class="keyword">this</span>._configs.host;</div><div class="line">        path = path.substr(<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 相对路径 ./或../开头或直接文件名</span></div><div class="line">        res = <span class="keyword">this</span>._configs.host;</div><div class="line">        resPaths = <span class="keyword">this</span>._configs.basePath.split(<span class="string">'/'</span>);</div><div class="line">    &#125;</div><div class="line">    resPaths = resPaths || [];</div><div class="line">    paths = path.split(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (paths[i] === <span class="string">'..'</span>) &#123;</div><div class="line">            resPaths.pop();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paths[i] === <span class="string">'.'</span>) &#123;</div><div class="line">            <span class="comment">// do nothing</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            resPaths.push(paths[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    res += resPaths.join(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> define = zmm.define = <span class="function"><span class="keyword">function</span> (<span class="params">dependPaths, fac</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _uri = <span class="built_in">document</span>.currentScript.src;</div><div class="line">    <span class="keyword">if</span> (zmm.isModuleLoaded(_uri)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> factory, depPaths, uris = [];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">        factory = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 挂载到模块组中</span></div><div class="line">        zmm.installModule(_uri, factory());</div><div class="line">        <span class="comment">// 告诉proxy该模块已装载好</span></div><div class="line">        zmm.proxy.emit(_uri);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 有依赖的情况</span></div><div class="line">        factory = <span class="built_in">arguments</span>[<span class="number">1</span>];</div><div class="line">        <span class="comment">// 装载完成的回调函数</span></div><div class="line">        zmm.use(<span class="built_in">arguments</span>[<span class="number">0</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            zmm.installModule(_uri, factory.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</div><div class="line">            zmm.proxy.emit(_uri);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.use = <span class="function"><span class="keyword">function</span> (<span class="params">paths, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(paths)) &#123;</div><div class="line">        paths = [paths];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> uris = [], i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</div><div class="line">        uris.push(<span class="keyword">this</span>.resolvePath(paths[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 先注册事件，再加载</span></div><div class="line">    <span class="keyword">this</span>.proxy.watch(uris, callback);</div><div class="line">    <span class="keyword">this</span>.load(uris);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.proxy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> proxy = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> taskId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> taskList = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> execute = <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> uris = task.uris,</div><div class="line">            callback = task.callback;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arr = []; i &lt; uris.length; i++) &#123;</div><div class="line">            arr.push(zmm._modules[uris[i]]);</div><div class="line">        &#125;</div><div class="line">        callback.apply(<span class="literal">null</span>, arr);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> deal_loaded = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> i, k, task, sum;</div><div class="line">        <span class="comment">// 当一个模块加载完成时，遍历当前任务栈</span></div><div class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> taskList) &#123;</div><div class="line">            <span class="keyword">if</span> (!taskList.hasOwnProperty(k)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            task = taskList[k];</div><div class="line">            <span class="keyword">if</span> (task.uris.indexOf(_uri) &gt; <span class="number">-1</span>) &#123;</div><div class="line">                <span class="comment">// 查看这个任务中的模块是否都已加载好</span></div><div class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; task.uris.length; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (zmm.isModuleLoaded(task.uris[i])) &#123;</div><div class="line">                        sum ++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (sum === task.uris.length) &#123;</div><div class="line">                    <span class="comment">// 都加载完成 删除任务</span></div><div class="line">                    <span class="keyword">delete</span>(taskList[k]);</div><div class="line">                    execute(task);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    proxy.watch = <span class="function"><span class="keyword">function</span> (<span class="params">uris, callback</span>) </span>&#123;</div><div class="line">        <span class="comment">// 先检查一遍是否都加载好了</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; uris.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (zmm.isModuleLoaded(uris[i])) &#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sum === uris.length) &#123;</div><div class="line">            execute(&#123;</div><div class="line">                <span class="attr">uris</span>: uris,</div><div class="line">                <span class="attr">callback</span>: callback</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 订阅新加载任务</span></div><div class="line">            <span class="keyword">var</span> task = &#123;</div><div class="line">                <span class="attr">uris</span>: uris,</div><div class="line">                <span class="attr">callback</span>: callback</div><div class="line">            &#125;;</div><div class="line">            taskList[<span class="string">''</span> + taskId] = task;</div><div class="line">            taskId ++;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    proxy.emit = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(_uri + <span class="string">' is loaded!'</span>);</div><div class="line">        deal_loaded(_uri);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h2 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h2><p>“循环加载”指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。这是一种应该尽量避免的设计。</p>
<h3 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h3><p>用上面的zmm工具加载模块a:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.html</span></div><div class="line">zmm.use(<span class="string">'/a.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</div><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="string">'/b.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  a = b + <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="string">'/a.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> b;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>就会陷入a等待b加载完成、b等待a加载完成的死锁状态。sea.js碰到这种情况也是死锁，也许是默认这种行为不应该出现。<br>seajs里可以通过require.async来缓解循环依赖的问题，但必须改写a.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="string">'./js/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  <span class="built_in">require</span>.async(<span class="string">'./b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</div><div class="line">      a = b + <span class="number">1</span>;</div><div class="line">      <span class="built_in">module</span>.exports = a; <span class="comment">//a= 3</span></div><div class="line">  &#125;);</div><div class="line">  <span class="built_in">module</span>.exports = a; <span class="comment">// a= 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="string">'./js/b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line">  <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">  <span class="built_in">module</span>.exports = b;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// main.html</span></div><div class="line">seajs.use(<span class="string">'./js/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但这么做a就必须先知道b会依赖自己，且use中输出的是b还没加载时a的值，use并不知道a的值之后还会改变。<br>在浏览器端，似乎没有很好的解决方案。node模块加载碰到的循环依赖问题则小得多。</p>
<h3 id="node-CommonJS"><a href="#node-CommonJS" class="headerlink" title="node/CommonJS"></a>node/CommonJS</h3><p>CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。CommonJS的做法是，一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = a;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</div><div class="line">a = b + <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = a;</div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line"><span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = b;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>上面main.js的代码中，先加载模块a，执行require函数，此时内存中已经挂了一个模块a，它的exports为一个空对象a.exports={}；接着执行a.js中的代码；执行var b = require(‘./b’);之前，a.exports=1，接着执行require(b)；b.js被执行时，拿到的是a.exports=1，b加载完成后，执行权回到a.js；最后a模块的输出为3。</p>
<p>CommonJS与浏览器端的加载器有着实现上的差异。node加载的模块都是在本地，执行的是同步的加载过程，即按依赖关系依次加载，执行到加载语句就去加载另一个模块，加载完了再回到函数调用点继续执行；浏览器端加载scripts由于天生限制，只能采取异步加载，执行回调来实现。</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。因此，ES6模块是动态引用，不存在缓存值的问题，而且模块里面的变量，绑定其所在的模块。</p>
<p>这导致ES6处理”循环加载”与CommonJS有本质的不同。ES6根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">'./odd'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123; counter++; <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);&#125;</div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">'./even'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123; <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);&#125;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./even.js'</span>;</div><div class="line">m.even(<span class="number">10</span>); <span class="comment">// true; m.counter = 6</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，even.js里面的函数even有一个参数n，只要不等于0，就会减去1，传入加载的odd()。odd.js也会做类似作。</p>
<p>上面代码中，参数n从10变为0的过程中，foo()一共会执行6次，所以变量counter等于6。第二次调用even（）时，参数n从20变为0，foo()一共会执行11次，加上前面的6次，所以变量counter等于17。</p>
<p>而这个例子要是改写成CommonJS，就根本无法执行，会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">exports.counter = counter;</div><div class="line">exports.even = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">counter++;</div><div class="line"><span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./even'</span>);</div><div class="line">m.even(<span class="number">10</span>); <span class="comment">// TypeError: even is not a function</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成”循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/02/知识点整理 - Redux 介绍与基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/知识点整理 - Redux 介绍与基础/" itemprop="url">
                  知识点整理 - Redux 介绍与基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T00:00:00+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着 JavaScript 单页应用开发日趋复杂，越来越多的 state （状态）需要在前端进行管理。</p>
<blockquote>
<p> 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p>
</blockquote>
<p>为了高效的管理 state 而不是简单的在全局上新建变量，开发者需要捋清 model/view 之间的关系，以降低前端开发的复杂性。此处以 Redux 为例，总结如何利用其设计思想以及实践经验，来使得应用的 state 管理变得容易。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Redux 的核心概念第一点则是 <strong>state</strong> 的表示，你可以用一个对象来表示应用的 state (可以看成 model) 但不能直接修改他（没有 setter）。这一步定义的内容可以看成是用于控制页面效果、动画的一些开关状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    todo: [],</div><div class="line">    name: &apos;me&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想要修改 state 中的数据只能通过发起 <strong>action</strong> 来实现（这样做的好处就是可以清晰的知道应用中到底发生了什么）， action 也是一个普通对象，用来描述将要发生什么。在 action 中我们需要存储发生事件的描述以及用于更新 state 的属性数据，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; type: &apos;ADD_TODO&apos;, text: &apos;Go to swimming pool&apos; &#125;</div></pre></td></tr></table></figure>
<p>那么如何接收 action 并更新返回新的 state 呢？用 <strong>reducer</strong> 函数。它接收 state 和 action，在内部处理后并返回新的 state。考虑到应用的复杂性，我们可以分别编写 reducer 分别独立地操作 state tree 的不同部分。</p>
<h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><ul>
<li><strong>单一数据源</strong>：整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li>
<li><strong>State 是只读的</strong>：唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li>
<li><strong>使用纯函数来执行修改</strong>：为了描述 action 如何改变 state tree ，你需要编写 reducers。</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。除了 type 字段外，对象结构完全由自己决定。但是需要注意的是应该尽量减少在 action 中传递的数据。</p>
<p>为了了解生成 action，还需要知道 action 创建函数，该函数只是简单的返回一个 action，这样做将使 action 创建函数更容易被移植和测试。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function addTodo(text) &#123;</div><div class="line">  return &#123;</div><div class="line">    type: ADD_TODO,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你把 action 创建函数结果传给 dispatch() 方法，即可发起一次 dispatch 过程，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch(addTodo(text))</div></pre></td></tr></table></figure>
<p>在使用过程中可能用到的工具包括 <code>connect()</code>， <code>bindActionCreators()</code></p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。通过 reducer，我们不仅可以修改 state 还可以借机初始化 state。</p>
<p>针对 action 的处理我们需要注意：不要修改 state，且在 default 情况下返回旧的 state。</p>
<p>在使用过程中可能用到的工具包括 <code>combineReducers()</code></p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>在知道了如何用 reducer 来根据 action 更新 state 后，需要进一步了解的就是 store —— 将它们联系到一起的对象。store 具有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <code>getState()</code> 方法获取 state；</li>
<li>提供 <code>dispatch(action)</code> 方法更新 state；</li>
<li>通过 <code>subscribe(listener)</code> 注册监听器;</li>
<li>通过 <code>subscribe(listener)</code> 返回的函数注销监听器。</li>
</ul>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>Redux 应用中的数据的生命周期遵循四个步骤：</p>
<ul>
<li>调用 <code>store.dispatch(action)</code></li>
<li>redux store 调用传入的 reducer 函数</li>
<li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树</li>
<li>Redux store 保存了根 reducer 返回的完整 state 树</li>
</ul>
<h3 id="搭配-react"><a href="#搭配-react" class="headerlink" title="搭配 react"></a>搭配 react</h3><p>结合 react 开发其中比较重要的一点在于如何设计组件层次结构。结合 react 可以知道在组件层次方面，主要需要考虑两点：展示组件和容器组件，当然不好区分的组件可以划分为其他组件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/02/JavaScript面向对象系列：六、对象模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/JavaScript面向对象系列：六、对象模式/" itemprop="url">
                  JavaScript面向对象系列：六、对象模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T00:00:00+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>js有很多创建对象的模式，完成工作的方式也不是只有一种。可以随时定义自己的类型和自己的泛用对象。可以使用继承或者混入等其他技术令对象间行为共享。也可以利用js高级技巧来组织对象结构被改变。</p>
<h2 id="私有成员和特权成员"><a href="#私有成员和特权成员" class="headerlink" title="私有成员和特权成员"></a>私有成员和特权成员</h2><p>js对象对象的所有属性都是公有的，且没有显式的方法指定某个属性不能被外界某个对象访问。然而，有时候可能不希望数据公有。</p>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>模块模式是一种拥有私有数据的单件对象的模式。基本做法就是使用立即调用函数表达式（IIFE）来返回一个对象。IIFE是一种被定义后立即调用并产生结果的函数表达式，该函数表达可以包括任意数量的本地变量，它们在函数外不可见。因为返回的对象被定义在函数内部，对象的方法可以访问这些数据。（IIFE定义的所有对象都可以访问通用的本地变量）以这种方式访问私有数据的方法被称为特权方法。</p>
<p>基本格式如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> yourObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//私有数据</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="comment">//公有方法和属性  </span></div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>IIFE是js中一种很流行的模式，部分原因就是模块模式中的应用。</p>
<p>模块模式允许使用普通变量作为非公有对象属性。通过创建必报函数作为对象方法来操作它们。闭包函数就是一个可以访问其作用域外部数据的普通函数。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">getAge</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">growOlder</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            age++;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<p>模块模式还有一个变种叫暴露模块模式，它将所有的变量和方法都组织在IIFE的顶部，然后将它们设置到需要被返回的对象上。可以使用暴露模块模式改写上面的例子。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">growOlder</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">getAge</span>:getAge,</div><div class="line">        <span class="attr">growOlder</span>:growOlder</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数中的私有成员"><a href="#构造函数中的私有成员" class="headerlink" title="构造函数中的私有成员"></a>构造函数中的私有成员</h2><p>模块模式在定义单个对象的私有属性上十分有效，但是对于那些同样需要私有属性的自定义类型，也可以在构造函数中使用类型的模式来创建每个实例的私有数据。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.growOlder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<p>如果需要所有实例可以共享的私有数据，可以结合模块模式和构造函数。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">InnerPerson</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InnerPerson.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InnerPerson.prototype.growOlder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> InnerPerson;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person1.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">//"xiaowang"</span></div><div class="line"><span class="built_in">console</span>.log(person2.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person1.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person1.getAge()); <span class="comment">//26</span></div><div class="line"><span class="built_in">console</span>.log(person2.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>js中大量使用了伪类继承和原型对象继承，还有另一种伪继承的手段叫混入。一个对象在不改变原型对象链的情况下得到了另一个对象的属性被称为混入。第一个对象（接收者）通过直接复制第二个对象（提供者）的属性从而接收了这些属性。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">receiver,supplier</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> supplier)&#123;</div><div class="line">        <span class="keyword">if</span>(supplier.hasOwnProperty(property))&#123;</div><div class="line">            receiver[property] = supplier[property];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> receiver;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过混入而不是继承给一个对象添加事件支持<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">EventTarget.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:EventTarget,</div><div class="line">    <span class="attr">addListener</span>:<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>) </span>&#123;</div><div class="line">        <span class="comment">//不存在数组就创建一个数组</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(<span class="string">"_listeners"</span>)) &#123;</div><div class="line">            <span class="keyword">this</span>._listeners = [];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._listeners[type] == <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._listeners[type] = [];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>._listeners[type].push(listener);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">fire</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!event.target) &#123;</div><div class="line">            event.target = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!event.type)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Event object missing 'type' propertype."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._listeners &amp;&amp; <span class="keyword">this</span>._listener[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[event.type];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = listeners.length; i &lt; len; i++)&#123;</div><div class="line">                listeners[i].call(<span class="keyword">this</span>,event);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">removeListener</span>:<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._listener &amp;&amp; <span class="keyword">this</span>._listener[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[type];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = listeners.length; i &lt; len; i++)&#123;</div><div class="line">                <span class="keyword">if</span>(listeners[i] === listener)&#123;</div><div class="line">                    listener.split(i,<span class="number">1</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>js对象中支持事件十分有用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> EventTarget();</div><div class="line">person.name = <span class="string">"laowang"</span>;</div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="keyword">this</span>.fire(&#123;<span class="attr">type</span>:<span class="string">"namsaid"</span>,<span class="attr">name</span>:name&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中，person作为EventTarget的实例被创建出来，然后添加各种跟person相关的属性。可惜的是这意味着person实际上是一个EventTarget而不是一个Object或者其他自定义类型。另外，你还需要承受手工添加一批新属性的开销。解决这个问题的方法是使用伪类继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = <span class="built_in">Object</span>.create(EventTarget.prototype);</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="keyword">this</span>.fire(&#123;</div><div class="line">        <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">        <span class="attr">name</span>:name</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> EventTarget); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>这个例子中，一个新的Person类型继承自EventTarget。随后可以在Person的原型对象上添加你需要的方法。然而不够简洁。</p>
<p>更简洁的例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">minix(Person.prototype,<span class="keyword">new</span> EventTarget());</div><div class="line">minix(Person.prototype,&#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> EventTarget); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>有时候可能需要一个对象的属性，但是不想用伪类继承的构造函数。可以使用混入来创建自己的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = mixin(<span class="keyword">new</span> EventTarget(),&#123;</div><div class="line">    get name()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"laowang"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"xiaowang"</span></div></pre></td></tr></table></figure></p>
<p>这段代码定义了仅有getter的访问器属性name。这意味着对该属性赋值应该不起作用。但是，由于在person对象里面该访问器属性变成了数据属性，你就有可能改写name的值。在调用minix()时，提供者name属性的值被读取后赋值给接受者name属性。在这个过程中没有机会定义一个新的访问器属性，从而使接收者的name属性成为了一个数据属性。</p>
<p>如果想要访问器属性被复制成访问器属性，需要一个不同的minix()函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span> (<span class="params">receiver,supplier</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">property</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(supplier,property);</div><div class="line">        <span class="built_in">Object</span>.defineProperty(receiver,property,descriptor);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> receiver;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = mixin(<span class="keyword">new</span> EventTarget(),&#123;</div><div class="line">    get name()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"laowang"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laoawng"</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div></pre></td></tr></table></figure></p>
<h2 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h2><p>构造函数也是函数，所以可以不用 new 操作符直接调用它们来改变this的值。在非严格模式下，this被强制指向全局对象，这个做法会导致无法预知的结果。在严格模式下，构造函数会抛出错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">//"undefined"</span></div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">//"laowang"</span></div></pre></td></tr></table></figure></p>
<p>很多內建构造函数，例如 <strong><em>Array</em></strong> 和 <strong><em>RegExp</em></strong> 不需要new也可以工作，这是因为他们被设计成为作用域安全的构造函数。一个作用域安全的构造函数有没有new都可以工作，并返回同样的对象。</p>
<p>一个作用域安全的构造函数如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js有很多不同的方式创建和组装对象。虽然js没有一个正式的私有属性的概念，但是可以创建仅在对象内可以访问的数据或者函数。对于单件对象，你可以使用模块模式对外界隐藏数据。可以使用立即调用表达式定义仅可被创建的对象访问的本地变量和函数。特权方法是可以访问对象私有数据的方法。你还可以创建具有私有属性的构造函数，一种方法是在构造函数定义变量，另一种方法是使用IIFE来创建所有实例共享的私有数据。</p>
<p>混入是一种给对象添加功能，同时便面继承的强有力方式。混入将一个属性从一个对象复制到另一个，从而使得接收者在不需要继承提供者的情况下获得其功能。和继承不同，混入令你在创建对象后无法检查属性来源。因此，混入最适合被用于数据属性或者小函数。如果需要更强大的功能且知道该功能来自哪里，继承仍然是我们推荐的做法。</p>
<p>作用域安全的构造函数是可以不用new都可以被调用来生成新的对象实例的构造函数。这种模式之所以能工作，是因为this在构造函数一开始执行时就已经指向自定义类型的实例，可以根据new的使用与否来决定构造函数的行为。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/20/JavaScript面向对象系列：五、继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/JavaScript面向对象系列：五、继承/" itemprop="url">
                  JavaScript面向对象系列：五、继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T00:00:00+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原型对象链和-Object-prototype"><a href="#原型对象链和-Object-prototype" class="headerlink" title="原型对象链和 Object.prototype"></a>原型对象链和 <strong><em>Object.prototype</em></strong></h2><p> js內建的继承方法被称为原型对象链，又可以称为原型对象继承。原型对象的属性可以经由对象实例访问，这就是继承的一种形式。对象实例继承了原型对象的属性。因为原型对象也是一个对象，他也有自己的原型对象并继承其属性。这就是原型对象链，而原型对象继承它的原型对象，以此类推。</p>
<p> 所有对象，包括哪些你自己定义的对象都自动继承自 <strong><em>Object</em></strong>，除非另有指定。更确切的说，所有对象都继承自 <strong><em>Object.prototype</em></strong>。任何以队形字面量形式定义的对象，其 <strong><em>[[Prototype]]</em></strong> 的值都被设为 <strong><em>Object.prototype</em></strong>,这意味着它继承 <strong><em>Object.prototype</em></strong> 的属性。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(book);</div><div class="line"><span class="built_in">console</span>.log(prototype === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="继承自-Object-peototype-的方法"><a href="#继承自-Object-peototype-的方法" class="headerlink" title="继承自 Object.peototype 的方法"></a>继承自 <strong><em>Object.peototype</em></strong> 的方法</h2><p>前面说到的很多方法其实都是定义在 <strong><em>Object.prototype</em></strong> 上面的。因此可以被其他对象继承。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>hasOwnProperty()</td>
<td>检查是否存在一个给定名字的自有属性</td>
</tr>
<tr>
<td>propertyIsEnumerable()</td>
<td>检查一个自有属性是否可枚举</td>
</tr>
<tr>
<td>isPrototypeof()</td>
<td>检查一个对象是否是另一个对象的原型对象</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回一个对象的值表达</td>
</tr>
<tr>
<td>toString()</td>
<td>返回一个对象的字符串表达</td>
</tr>
</tbody>
</table>
<p><strong><em>valueOf</em></strong>,每当一个操作符被用于一个对象时就会调用 <strong><em>valueOf()</em></strong> 方法。 <strong><em>valueOf()</em></strong> 默认返回对象实例本身。原始封装类型重写了 <strong><em>valueOf()</em></strong> 以使得它对 <strong><em>String</em></strong> 返回一个字符串，对 <strong><em>Boolean</em></strong> 返回一个布尔值，对 <strong><em>Number</em></strong> 返回一个数字。类似的，<strong><em>Date</em></strong> 对象返回一个 <strong><em>epoch</em></strong> 时间。如果你的对象也要这样使用操作符，也可以自定义 <strong><em>valueOf()</em></strong> 方法.定义的时候并没有改变操作符的行为，仅仅定了操作符默认行为所使用的值。</p>
<p><strong><em>toString()</em></strong>,一旦 <strong><em>valueOf()</em></strong> 方法返回的是一个引用而不是原始值的时候，就会回退调用 <strong><em>toString()</em></strong> 方法。另外，当js期望一个字符串时，也会对原始值隐式调用 <strong><em>toString()</em></strong> .例如，当加号操作符的一边是一个字符串时，另一边会被自动转换成字符串。如果另一边是一个原始值，会自动被转换成一个字符串表达（例如，<strong><em>true</em></strong> 转换成 <strong><em>“true”</em></strong>）。如果另一边是一个引用值，则会调用 <strong><em>valueOf()</em></strong>。如果 <strong><em>valueOf()</em></strong> 返回一个引用值，则调用 <strong><em>toString()</em></strong>。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> message = <span class="string">"Book = "</span> + book;</div><div class="line"><span class="built_in">console</span>.log(message); <span class="comment">//"Book = [object Object]"</span></div></pre></td></tr></table></figure>
<p>这段以 “Book =” 和book来构造字符串。因为book是一个对象，此时调用它的 <strong><em>toString()</em></strong> 方法。该方法继承自 <strong><em>Object.prototype</em></strong>,大部分js引擎返回默认值 “[object Object]”。如果对这个值满意，就不需要改变对象的 <strong><em>toString()</em></strong> 方法。定义自己的 <strong><em>toString()</em></strong> 方法有时候可以为此类字符串转换提供更过信息的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span>,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Book "</span> + <span class="keyword">this</span>.title + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> message = <span class="string">"Book = "</span> + book;</div><div class="line"><span class="built_in">console</span>.log(message); <span class="comment">//"Book = [Book javascript]"</span></div></pre></td></tr></table></figure></p>
<h2 id="修改-Object-pototype"><a href="#修改-Object-pototype" class="headerlink" title="修改 Object.pototype"></a>修改 <strong><em>Object.pototype</em></strong></h2><p>所有的对象都默认继承自 <strong><em>Object.prototype</em></strong>，所以改变 <strong><em>Object.prototype</em></strong> 会影响所有的对象，是非常危险的。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(book.add(<span class="number">5</span>)); <span class="comment">//"[object Object]5";</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"title"</span>.add(<span class="string">"end"</span>)); <span class="comment">//"titleend"</span></div><div class="line"></div><div class="line"><span class="comment">//在浏览器中</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.add(<span class="literal">true</span>)); <span class="comment">//"[object HTMLDocument]true"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.add(<span class="number">5</span>)); <span class="comment">//"[object Window]6"</span></div></pre></td></tr></table></figure></p>
<p>上面给 <strong><em>Object.prototype</em></strong> 添加方法可能会带来不可预知的结果</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prpperty <span class="keyword">in</span> empty)&#123;</div><div class="line">    <span class="built_in">console</span>.log(property);</div><div class="line">&#125;</div><div class="line"><span class="comment">// add</span></div></pre></td></tr></table></figure></p>
<p>空对象依然会输出一个”add”属性。考虑到js中 <strong><em>for-in</em></strong> 使用频繁，为 <strong><em>Object.prototype</em></strong> 添加可枚举属性会影响大量代码。所以可以在 <strong><em>for-in</em></strong> 中使用 <strong><em>hasOwnProperty()</em></strong>.</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prpperty <span class="keyword">in</span> empty)&#123;</div><div class="line">    <span class="keyword">if</span>(empty.hasOwnProperty(property))&#123;</div><div class="line">        <span class="built_in">console</span>.log(property);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure></p>
<p>这样循环只会输出对象自有属性，不会输出原型属性。</p>
<h2 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h2><p>对象继承是最简单的继承类型。唯一需要做的就是制定那个对象是新对象的 <strong><em>[[Prototype]]</em></strong> 。对象字面量形式会隐式指定 <strong><em>Object.prototype</em></strong> 为其 <strong><em>[[Prototype]]</em></strong>,也可以使用 <strong><em>Object.create()</em></strong> 方法显式指定。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//和下面是一样的</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> book = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</div><div class="line">    <span class="attr">title</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:<span class="string">"javascript"</span>,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>继承其他对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1,&#123;</div><div class="line">    <span class="attr">name</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:<span class="string">"xiaowang"</span>,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">person1.sayName(); <span class="comment">//"laowang"</span></div><div class="line">person2.sayName(); <span class="comment">//"xiaowang"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"sayName"</span>)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.isPrototypeOf(person2)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"sayName"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>另外，也可以通过 <strong><em>Object.create()</em></strong> 创建 <strong><em>[[Prototype]]</em></strong> 为null的对象，这样的对象是没有原型对象链的对象。意味着 <strong><em>toString()</em></strong> 和 <strong><em>valueOf()</em></strong> 等內建方法都不存在该对象上面。实际上，这种对象完全就是一个没有任何预定义属性的白板，也是一个完美的哈希容器，因为不会有自由属性和原型属性的冲突。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nakedObject = object.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> nakedObject); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"valueOf"</span> <span class="keyword">in</span> nakedObject); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>js中的对象继承也是构造函数继承的基础。几乎所有的函数都有 <strong><em>prototype</em></strong> 属性，它可以被修改或者换。该 <strong><em>prototype</em></strong> 属性被自动设置为一个新的继承自 <strong><em>Object.prototype</em></strong> 的泛用对象，该对象有一个自有属性 <strong><em>constructor</em></strong> ,实际上js引擎自动做了下面的事情</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">YourConstructor</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//js引擎自动为你做了下面的事情</span></div><div class="line">YourConstructor.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:YourConstructor,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>创建出来的对象都继承自 <strong><em>Object.prototype</em></strong>。YourConstructor 是Object的子类，Object是YourConstructor 的父类。</p>
<p>由于 <strong><em>prototype</em></strong> 属性可写，可以通过改写它来改变原型对象链。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = size;</div><div class="line">    <span class="keyword">this</span>.width = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="keyword">new</span> Rectangle();</div><div class="line">Square.prototype.constuctor = Square;</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">//50</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.toString()); <span class="comment">//"[Rectangle 5X10 ]"</span></div><div class="line"><span class="built_in">console</span>.log(square.toString()); <span class="comment">//"[Square 6X6 ]"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>此时不需要给Rectangle的调用提供参数，因为他们不需要被使用，而且如果提供了，那所有Square的对象实例都会共享同样的维度。用这种方式改变原型对象链时，需要确保构造函数不会再参数缺失时抛出错误（很多构造函数包含的初始化逻辑会需要参数）且构造函数不会改变任何全局状态，比如追踪有多少实例被创建等。</p>
<p>rect作为Rectangle的实例被创建，而square则是作为Square的实例被创建。两个对象都有getArea方法，那是因为继承自Reatangle.prototype。instanceof操作符认为变量square同时是Square、Rectangle、Object的实例，因为instanceof是使用原型对象链检查对象类型。</p>
<p>使用 <strong><em>Object.create()</em></strong> 方法可以简化并且不会导致参数缺失而报错。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = size;</div><div class="line">    <span class="keyword">this</span>.width = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">//50</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.toString()); <span class="comment">//"[Rectangle 5X10 ]"</span></div><div class="line"><span class="built_in">console</span>.log(square.toString()); <span class="comment">//"[Square 6X6 ]"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数窃取"><a href="#构造函数窃取" class="headerlink" title="构造函数窃取"></a>构造函数窃取</h2><p>由于js中的继承是通过原型对象链来实现的，因此不需要调用对象的父类构造函数。如果需要在子类构造函数中调用父类构造函数，就需要用 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong>。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    Retangle.call(<span class="keyword">this</span>,size,size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square.length); <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(square.width); <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div></pre></td></tr></table></figure></p>
<p>由于这种做法模仿了那些基于类语言的类继承，通常被称为伪类继承。</p>
<h2 id="访问父类方法"><a href="#访问父类方法" class="headerlink" title="访问父类方法"></a>访问父类方法</h2><p>子类提供的新功能覆盖父类方法很常见，但是如果还想访问父类方法，只能通过 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 来访问了，而且这是唯一方法。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    Retangle.call(<span class="keyword">this</span>,size,size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> text = Rectangle.prototype.toString().call(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> text.replace(<span class="string">"Rectangle"</span>,<span class="string">"Square"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js通过原型对象链支持继承。当将一个对象的 <strong><em>[[Prototype]]</em></strong> 设置为另一个对象时，就在这两个对象之间创建了一条原型对象链。所有的泛用对象都自动继承自 <strong><em>Object.prototype</em></strong> 。如果你想创建一个继承自其它对象的对象，你可以用 <strong><em>Object.create()</em></strong> 指定 <strong><em>[[Prototype]]</em></strong> 为一个新对象。</p>
<p>可以在构造函数中创建原型对象链来完成自定义类型之间的继承。通过将构造函数的 <strong><em>prototype</em></strong> 属性设置为某一个对象那个，就建立了自定义类型对象和该对象的继承关系。构造函数的所有对象、实例共享同一个原型对象，所以他们都继承自该对象。这个技术在继承其他对象的方式时工作得很好。但是不能用原型继承自有属性。</p>
<p>为了正确继承自有属性，可以使用构造函数窃取。只需要以 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 调用父类的构造函数，就可以在子类里面完成各种初始化。结合构造函数窃取和原型对象链是js中最常见的继承手段。由于和基于类的继承相似，这个组合经常被称为伪类继承。</p>
<p>可以通过直接访问父类原型对象的方式访问父类方法。必须以 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 执行父类方法并传入一个子类的对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/12/JavaScript面向对象系列：四、构造函数和原型对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/12/JavaScript面向对象系列：四、构造函数和原型对象/" itemprop="url">
                  JavaScript面向对象系列：四、构造函数和原型对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T00:00:00+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Prototype-属性"><a href="#Prototype-属性" class="headerlink" title="[[Prototype]] 属性"></a><strong><em>[[Prototype]]</em></strong> 属性</h2><p>一个对象实例通过内部属性 <strong><em>[[Prototype]]</em></strong> 跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针，当你new创建一个新的对象时，构造函数的原型对象会被赋值给该对象的  <strong><em>[[Prototype]]</em></strong> 属性。</p>
<p>可以调用对象的 <strong><em>Object.getPrototypeOf()</em></strong> 方法读取<strong><em>[[Prototype]]</em></strong> 属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(obj);</div><div class="line"><span class="built_in">console</span>.log(prototype === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="大部分js引擎都会提供一个-proto-属性。该属性使你可以直接读写-Prototype-属性。"><a href="#大部分js引擎都会提供一个-proto-属性。该属性使你可以直接读写-Prototype-属性。" class="headerlink" title="大部分js引擎都会提供一个  proto 属性。该属性使你可以直接读写 [[Prototype]] 属性。"></a>大部分js引擎都会提供一个 <strong> </strong>proto<strong> </strong>属性。该属性使你可以直接读写 <strong><em>[[Prototype]]</em></strong> 属性。</h2><h2 id="可以使用-isPrototypeOf-方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有"><a href="#可以使用-isPrototypeOf-方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有" class="headerlink" title="可以使用 isPrototypeOf() 方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有."></a>可以使用 <strong><em>isPrototypeOf()</em></strong> 方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(obj)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>因为obj是一个泛用对象，原型是Object.prototype</p>
<h2 id="当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索-Prototype-中的对象，如果找到则返回。如果找不到，则返回undefined。"><a href="#当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索-Prototype-中的对象，如果找到则返回。如果找不到，则返回undefined。" class="headerlink" title="当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索[[Prototype]] 中的对象，如果找到则返回。如果找不到，则返回undefined。"></a>当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索<strong><em>[[Prototype]]</em></strong> 中的对象，如果找到则返回。如果找不到，则返回undefined。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line">obj.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[object Custom]"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Custom]"</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> obj.toString;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> obj.toString;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div></pre></td></tr></table></figure>
<p>上述例子也说明了，仅当自有属性被删除时，原型属性才会再一次被使用。delete操作符仅对自有属性起作用，无法删除原型对象的属性。</p>
<h2 id="在构造函数中使用原型对象"><a href="#在构造函数中使用原型对象" class="headerlink" title="在构造函数中使用原型对象"></a>在构造函数中使用原型对象</h2><p>使用对象字面量形式改写原型对象时要注意 <strong><em>constructor</em></strong> 属性</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === Person); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>使用这种方式创建原型对象，<strong><em>constructor</em></strong> 属性会有误差。每一个原型对象都有一个 <strong><em>constructor</em></strong> 属性，这是其他对象实例没有的。</p>
<p>当一个函数被创建时，它的 <strong><em>prototype</em></strong> 属性也被创建，且该原型对象的 <strong><em>constructor</em></strong> 属性指向该函数。当使用对象字面量形式改写原型对象的时候，<strong><em>constructor</em></strong> 被置为泛对象Object。得手动修正。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === <span class="built_in">Object</span>); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.constructor === Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.constructor === <span class="built_in">Object</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>构造函数、原型对象和对象实例之间的关系最有趣的一个方面也许就是对象实例和构造函数之间没有直接联系。不过对象实例和原型对象以及原型对象和构造函数之间都有直接联系。</p>
<h2 id="改变原型对象"><a href="#改变原型对象" class="headerlink" title="改变原型对象"></a>改变原型对象</h2><p>给定类型的所有对象实例功效一个原型对象，所以可以一次性扩充所有对象实例。<strong>_[[Prototype]]</strong> 属性只是包含了一个指向原型对象的指针。任何对原型对象的改变都立即反映到所有引用它的对象实例上。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person1); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person2); <span class="comment">//false</span></div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person1.sayHi(); <span class="comment">//"Hi"</span></div><div class="line">person2.sayHi(); <span class="comment">//"Hi"</span></div></pre></td></tr></table></figure></p>
<p>对象封印和对象冻结只能操作对象的自有属性。封印或者冻结之后，无法添加自有属性或者改变冻结对象的自有属性。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(person1);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person1); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person2); <span class="comment">//false</span></div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person1.sayHi(); <span class="comment">//"Hi"</span></div><div class="line">person2.sayHi(); <span class="comment">//"Hi"</span></div></pre></td></tr></table></figure></p>
<p>其实，<strong><em>[[Prototype]]</em></strong> 属性是对象实例的自有属性，属性本身被冻结，但是其指向的值（原型对象）并没有被冻结。</p>
<p>实际开发中，可能不会频繁的使用原型对象，但是理解对象实例及其原型对象之间的关系是非常重要的。</p>
<h2 id="改变内建原型对象"><a href="#改变内建原型对象" class="headerlink" title="改变内建原型对象"></a>改变内建原型对象</h2><p>所有的內建对象都有构造函数，因此也都有原型对象可以改变。</p>
<p>例如，简单修改Array的原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> pre + cur;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = numbers.sum();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//15</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构造函数就是用 <strong><em>new</em></strong> 操作符调用的普通函数。可以随时定义自己的构造函数来创建多个具有同样属性的对象。可以用 <strong><em>instanceof</em></strong> 操作符或直接访问 <strong><em>constructor</em></strong> 属性来鉴别对象是被哪个构造函数创建的。</p>
<p>每一个函数都有都具有 <strong><em>prototype</em></strong> 属性，它定义了该构造函数创建的所有对象共享的属性。通常，共享的方法和原始值属性被定义在原型对象里，而其他属性都定义在构造函数里。 <strong><em>constructor</em></strong> 属性实际上被定义在原型对象里供所有对象实例共享。</p>
<p>原型对象被保存在对象实例内部的 <strong><em>[[Prototype]]</em></strong> 属性中。这个属性时一个引用而不是副本。由于js查找属性的机制，对原型对象的修改都立刻出现在所有对象实例中。当试图访问一个对象的某个属性时，js首先在自有属性里查找该名字，如果自有属性中没有找到则在原型属性中查找。这样的机制意味着原型对象可以随时改变而引用它的对象实例则立即反映出这些改变。</p>
<p>內建对象也有可以被修改的原型对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/07/JavaScript 中至关重要的 Apply, Call 和 Bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/07/JavaScript 中至关重要的 Apply, Call 和 Bind/" itemprop="url">
                  JavaScript 中至关重要的 Apply, Call 和 Bind
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-07T00:00:00+08:00">
                2017-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文基于 <a href="http://javascriptissexy.com/javascript-apply-call-and-bind-methods-are-essential-for-javascript-professionals/#" target="_blank" rel="external">JavaScript’s Apply, Call, and Bind Methods are Essential for JavaScript Professionals</a> 阅读整理而来, 其中对于原文中的内容进行了部分翻译与增删, 例如 ES6 中开发的注意事项以及三者之间的区别等等, 望周知. 阅读本文内容的先备知识包括:</p>
<ul>
<li>理解 JavaScript 中的 this 关键字</li>
<li>JavaScript 对象概念</li>
<li>JavaScript 闭包概念</li>
</ul>
<p>如果你对前面提到的先备知识有所了解, 你应该知道 JavaScript 中的函数其实是一种对象. 而作为对象, 函数是可以有方法的, 包括非常强大的 <code>Apply</code>, <code>Call</code> 以及 <code>Bind</code> 方法. 一方面, Apply 方法和 Call 方法的用途几乎相同, 在 JavaScript 中被频繁使用于方法借用和明确 this 关键字指向等场景. 我们也将 Apply 用于参数可变的函数; 在后文中你将会对此有更多的了解. 另一方面, 我们会使用 Bind 来给方法指定 this 指向值或者函数柯里化 (currying functions).</p>
<p>我们会讨论在 JavaScript 中使用这三种方法的每一个场景. Apply 和 Call 方法是在 ECMAScript 3 标准中出现的(可以在IE 6, 7, 8 以及现代浏览器中使用), ECAMScript 5 标准添加了 Bind 这个方法. 由于三种方法都非常强大, 开发时你一定会用到其中一个. 让我们先从 Bind 方法说起.</p>
<h2 id="Bind-方法"><a href="#Bind-方法" class="headerlink" title="Bind 方法"></a>Bind 方法</h2><p>我们用 Bind() 来实现在指明函数内部 this 指向的情况下去调用该函数, 换句话说, bind() 允许我们非常简单的在函数或者方法被调用时绑定 this 到指定对象上.</p>
<p>当我们在一个方法中用到了 this, 而这个方法调用于一个接收器对象, 我们会需要使用到 bind() 方法; 在这种情况下, 由于 this 不一定完全如我们所期待的绑定在目标对象上, 程序有时便会出错;</p>
<h2 id="Bind-允许我们明确指定方法中的-this-指向"><a href="#Bind-允许我们明确指定方法中的-this-指向" class="headerlink" title="Bind 允许我们明确指定方法中的 this 指向"></a>Bind 允许我们明确指定方法中的 this 指向</h2><p>当以下按钮被点击的时候, 文本输入框会被随机填入一个名字.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;button&gt;Get Random Person&lt;/button&gt;​</span></div><div class="line"><span class="comment">// &lt;input type="text"&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="attr">data</span>        :[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"T. Woods"</span>, <span class="attr">age</span>:<span class="number">37</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"P. Mickelson"</span>, <span class="attr">age</span>:<span class="number">43</span>&#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">clickHandler</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> randomNum = ((<span class="built_in">Math</span>.random () * <span class="number">2</span> | <span class="number">0</span>) + <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// random number between 0 and 1​</span></div><div class="line">​</div><div class="line">        <span class="comment">// 从 data 数组中随机选取一个名字填入 input 框内</span></div><div class="line">        $(<span class="string">"input"</span>).val(<span class="keyword">this</span>.data[randomNum].name + <span class="string">" "</span> + <span class="keyword">this</span>.data[randomNum].age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 给点击事件添加一个事件处理器</span></div><div class="line">$(<span class="string">"button"</span>).click(user.clickHandler);</div></pre></td></tr></table></figure>
<p>当你点击按钮时, 会发现一个报错信息: 因为 clickHandler() 方法中的 this 绑定的是按钮 HTML 内容的上下文, 因为这才是 clickHandler 方法的执行时的调用对象.</p>
<p>在 JavaScript 中这种问题比较常见, JavaScript 框架中例如 Backbone.js, jQuery 都自动为我们做好了绑定的工作, 所以在使用时 this 总是可以绑定到我们所期望的那个对象上.</p>
<p>为了解决之前例子中存在的问题, 我们利用 bind() 方法将 <code>$(&quot;button&quot;).click(user.clickHandler);</code> 换成以下形式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"button"</span>).click(user.clickHandler.bind(user));</div></pre></td></tr></table></figure>
<p>再考虑另一个方法来修复 this 的值: 你可以给 click() 方法传递一个匿名回调函数, jQuery 会将匿名函数的 this 绑定到按钮对象上.</p>
<blockquote>
<p>bind() 函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。 - MDN</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</div><div class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></div><div class="line">      <span class="comment">// internal IsCallable function</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </div><div class="line">        fToBind = <span class="keyword">this</span>, <span class="comment">// 此处的 this 指向目标函数</span></div><div class="line">        fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</div><div class="line">            ? <span class="keyword">this</span> <span class="comment">// 此处 this 为 调用 new obj() 时所生成的 obj 本身</span></div><div class="line">            : oThis || <span class="keyword">this</span>, <span class="comment">// 若 oThis 无效则将 fBound 绑定到 this</span></div><div class="line">            <span class="comment">// 将通过 bind 传递的参数和调用时传递的参数进行合并, 并作为最终的参数传递</span></div><div class="line">            aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用</span></div><div class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</div><div class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fBound;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续之前的例子, 如果我们将包含 this 的方法赋值给一个变量, 那么 this 的指向也会绑定到另一个对象上, 如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量 data</span></div><div class="line"><span class="keyword">var</span> data = [</div><div class="line">    &#123;<span class="attr">name</span>:<span class="string">"Samantha"</span>, <span class="attr">age</span>:<span class="number">12</span>&#125;,</div><div class="line">    &#123;<span class="attr">name</span>:<span class="string">"Alexis"</span>, <span class="attr">age</span>:<span class="number">14</span>&#125;</div><div class="line">]</div><div class="line">​</div><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="comment">// 局部变量 data</span></div><div class="line">    data    :[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"T. Woods"</span>, <span class="attr">age</span>:<span class="number">37</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"P. Mickelson"</span>, <span class="attr">age</span>:<span class="number">43</span>&#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">showData</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> randomNum = ((<span class="built_in">Math</span>.random () * <span class="number">2</span> | <span class="number">0</span>) + <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// random number between 0 and 1​</span></div><div class="line">​</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data[randomNum].name + <span class="string">" "</span> + <span class="keyword">this</span>.data[randomNum].age);</div><div class="line">    &#125;</div><div class="line">​</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 将 user 对象的 showData 方法赋值给一个变量</span></div><div class="line"><span class="keyword">var</span> showDataVar = user.showData;</div><div class="line">​</div><div class="line">showDataVar(); <span class="comment">// Samantha 12 (来自全局变量数组而非局部变量数组)​</span></div></pre></td></tr></table></figure>
<p>当我们执行 showDataVar() 函数时, 输出到 console 的数值来自全局 data 数组, 而不是 user 对象. 这是因为 showDataVar() 函数是被当做一个全局函数执行的, 所以在函数内部 this 被绑定位全局对象, 即浏览器中的 window 对象.</p>
<p>来, 我们用 bind 方法来修复这个 bug.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bind the showData method to the user object</span></div><div class="line"><span class="keyword">var</span> showDataVar = user.showData.bind(user);</div></pre></td></tr></table></figure>
<h2 id="Bind-方法允许我们实现函数借用"><a href="#Bind-方法允许我们实现函数借用" class="headerlink" title="Bind 方法允许我们实现函数借用"></a>Bind 方法允许我们实现函数借用</h2><p>在 JavaScript 中, 我们可以传递函数, 返回函数, 借用他们等等, 而 bind() 方法使函数借用变得极其简单. 以下为一个函数借用的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// cars 对象</span></div><div class="line"><span class="keyword">var</span> cars = &#123;</div><div class="line">    <span class="attr">data</span>:[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Honda Accord"</span>, <span class="attr">age</span>:<span class="number">14</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Tesla Model S"</span>, <span class="attr">age</span>:<span class="number">2</span>&#125;</div><div class="line">    ]</div><div class="line">​</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 我们从之前定义的 user 对象借用 showData 方法</span></div><div class="line"><span class="comment">// 这里我们将 user.showData 方法绑定到刚刚新建的 cars 对象上​</span></div><div class="line">cars.showData = user.showData.bind(cars);</div><div class="line">cars.showData(); <span class="comment">// Honda Accord 14​</span></div></pre></td></tr></table></figure>
<p>这里存在一个问题, 当我们在 cars 对象上添加一个新方法(showData)时我们可能不想只是简单的借用一个函数那样, 因为 cars 本身可能已经有一个方法或者属性叫做 showData 了, 我们不想意外的将这个方法覆盖了. 正如在之后的 <em>Apply 和 Call 方法</em> 章节我们会介绍, 借用函数的最佳实践应该是使用 Apply 或者 Call 方法.</p>
<h2 id="Bind-方法允许我们柯里化一个函数"><a href="#Bind-方法允许我们柯里化一个函数" class="headerlink" title="Bind 方法允许我们柯里化一个函数"></a>Bind 方法允许我们柯里化一个函数</h2><blockquote>
<p>柯里化的概念很简单, 只传递给函数一部分参数来调用它, 让它返回一个函数去处理剩下的参数. 你可以一次性地调用 curry 函数, 也可以每次只传一个参数分多次调用, 以下为一个简单的示例. - <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html" target="_blank" rel="external">JS 函数是编程指南 第 4 章: 柯里化（curry）</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</div><div class="line"></div><div class="line">increment(<span class="number">2</span>);</div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">addTen(<span class="number">2</span>);</div><div class="line"><span class="comment">// 12</span></div></pre></td></tr></table></figure>
<p>现在, 我们使用 bind() 方法来实现函数的柯里化. 我们首先定义一个接收三个参数的 greet() 函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">gender, age, name</span>) </span>&#123;</div><div class="line">    <span class="comment">// if a male, use Mr., else use Ms.​</span></div><div class="line">    <span class="keyword">var</span> salutation = gender === <span class="string">"male"</span> ? <span class="string">"Mr. "</span> : <span class="string">"Ms. "</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (age &gt; <span class="number">25</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + salutation + name + <span class="string">"."</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hey, "</span> + name + <span class="string">"."</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们使用 bind() 方法柯里化 greet() 方法. bind() 接收的第一个参数指定了 this 的值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 在 greet 函数中我们可以传递 null, 因为函数中并未使用到 this 关键字</span></div><div class="line"><span class="keyword">var</span> greetAnAdultMale = greet.bind (<span class="literal">null</span>, <span class="string">"male"</span>, <span class="number">45</span>);</div><div class="line">​</div><div class="line">greetAnAdultMale(<span class="string">"John Hartlove"</span>); <span class="comment">// "Hello, Mr. John Hartlove."​</span></div><div class="line">​</div><div class="line"><span class="keyword">var</span> greetAYoungster = greet.bind(<span class="literal">null</span>, <span class="string">""</span>, <span class="number">16</span>);</div><div class="line">greetAYoungster(<span class="string">"Alex"</span>); <span class="comment">// "Hey, Alex."​</span></div><div class="line">greetAYoungster(<span class="string">"Emma Waterloo"</span>); <span class="comment">// "Hey, Emma Waterloo."​</span></div></pre></td></tr></table></figure>
<p>当我们用 bind() 实现柯里化时, greet() 函数参数中除了最后一个参数都被预定义好了, 所以当我们调用柯里化后的新函数时只需要指定最后一位参数.</p>
<p>所以小结一下, bind() 方法允许我们明确指定对象方法中的 this 指向, 我们可以借用, 复制一个方法或者将方法赋值为一个可作为函数执行的变量. 我们以可以借用 bind 实现函数柯里化.</p>
<h2 id="JavaScript-中的-Apply-和-Call-方法"><a href="#JavaScript-中的-Apply-和-Call-方法" class="headerlink" title="JavaScript 中的 Apply 和 Call 方法"></a>JavaScript 中的 Apply 和 Call 方法</h2><p>作为 JavaScript 中最常用的两个函数方法, apply 和 call 允许我们借用函数以及在函数调用中指定 this 指向. 除此外, apply 函数允许我们在执行函数时传入一个参数数组, 以此使函数在执行可变参数的函数时可以将每个参数单独的传入函数并得到处理.</p>
<h2 id="使用-apply-或者-call-设置-this"><a href="#使用-apply-或者-call-设置-this" class="headerlink" title="使用 apply 或者 call 设置 this"></a>使用 apply 或者 call 设置 this</h2><p>当我们使用 apply 或者 call 时, 传入的第一个参数为目标函数中 this 指向的对象, 以下为一个简单的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量​</span></div><div class="line"><span class="keyword">var</span> avgScore = <span class="string">"global avgScore"</span>;</div><div class="line">​</div><div class="line"><span class="comment">// 全局函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">avg</span>(<span class="params">arrayOfScores</span>) </span>&#123;</div><div class="line">    <span class="comment">// 分数相加并返回结果</span></div><div class="line">    <span class="keyword">var</span> sumOfScores = arrayOfScores.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> prev + cur;</div><div class="line">    &#125;);</div><div class="line">​</div><div class="line">    <span class="comment">// 这里的 "this" 会被绑定到全局对象上, 除非使用 Call 或者 Apply 明确指定 this 的指向</span></div><div class="line">    <span class="keyword">this</span>.avgScore = sumOfScores / arrayOfScores.length;</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="keyword">var</span> gameController = &#123;</div><div class="line">    <span class="attr">scores</span>  :[<span class="number">20</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">77</span>],</div><div class="line">    <span class="attr">avgScore</span>:<span class="literal">null</span>​</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 调用 avg 函数, this 指向 window 对象​</span></div><div class="line">avg(gameController.scores);</div><div class="line"><span class="comment">// 证明 avgScore 已经被设置为 window 对象的属性​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.avgScore); <span class="comment">// 46.4​</span></div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// null​</span></div><div class="line">​</div><div class="line"><span class="comment">// 重置全局变量</span></div><div class="line">avgScore = <span class="string">"global avgScore"</span>;</div><div class="line">​</div><div class="line"><span class="comment">// 使用 call() 方法明确将 "this" 绑定到 gameController 对象​</span></div><div class="line">avg.call(gameController, gameController.scores);</div><div class="line">​</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.avgScore); <span class="comment">// 全局变量 avgScore 的值​</span></div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// 46.4</span></div></pre></td></tr></table></figure>
<p>以上例子中 call() 中的第一个参数明确了 this 的指向, 第二参数被传递给了 avg() 函数.</p>
<p>apply 和 call 的用法几乎相同, 唯一的差别在于当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量.</p>
<h3 id="在灰调函数中用-call-或者-apply-设置-this"><a href="#在灰调函数中用-call-或者-apply-设置-this" class="headerlink" title="在灰调函数中用 call 或者 apply 设置 this"></a>在灰调函数中用 call 或者 apply 设置 this</h3><p>以下为一个例子, 这种做法允许我们在执行 callback 函数时能够明确 其内部的 this 指向</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个方法</span></div><div class="line"><span class="keyword">var</span> clientData = &#123;</div><div class="line">    <span class="attr">id</span>: <span class="number">094545</span>,</div><div class="line">    <span class="attr">fullName</span>: <span class="string">"Not Set"</span>,</div><div class="line">    <span class="comment">// clientData 对象中的一个方法</span></div><div class="line">    setUserName: <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>)  </span>&#123;</div><div class="line">        <span class="keyword">this</span>.fullName = firstName + <span class="string">" "</span> + lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInput</span>(<span class="params">firstName, lastName, callback, callbackObj</span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用 apply 方法将 "this" 绑定到 callbackObj 对象</span></div><div class="line">    callback.apply(callbackObj, [firstName, lastName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下样例中传递给 callback 函数<br>中的参数将会在 clientData 对象中被设置/更新.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getUserInput(<span class="string">"Barack"</span>, <span class="string">"Obama"</span>, clientData.setUserName, clientData);</div><div class="line"><span class="built_in">console</span>.log(clientData.fullName); <span class="comment">// Barack Obama​</span></div></pre></td></tr></table></figure>
<h2 id="使用-Apply-或者-Call-借用函数-必备知识"><a href="#使用-Apply-或者-Call-借用函数-必备知识" class="headerlink" title="使用 Apply 或者 Call 借用函数(必备知识)"></a>使用 Apply 或者 Call 借用函数(必备知识)</h2><p>相比 bind 方法, 我们使用 apply 或者 call 方法实现函数借用能够有很大的施展空间. 接下来我们考虑从 Array 中借用方法的问题, 让我们定义一个<strong>类数组对象(array-like object)</strong>然后从数组中借用方法来处理我们定义的这个对象, 不过在这之前请记住我们要操作的是一个对象, 而不是数组;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// An array-like object: note the non-negative integers used as keys​</span></div><div class="line"><span class="keyword">var</span> anArrayLikeObj = &#123;<span class="number">0</span>:<span class="string">"Martin"</span>, <span class="number">1</span>:<span class="number">78</span>, <span class="number">2</span>:<span class="number">67</span>, <span class="number">3</span>:[<span class="string">"Letta"</span>, <span class="string">"Marieta"</span>, <span class="string">"Pauline"</span>], <span class="attr">length</span>:<span class="number">4</span> &#125;;</div></pre></td></tr></table></figure>
<p>接下来我们可以这样使用数组的原生方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Make a quick copy and save the results in a real array:​</span></div><div class="line"><span class="comment">// First parameter sets the "this" value​</span></div><div class="line"><span class="keyword">var</span> newArray = <span class="built_in">Array</span>.prototype.slice.call(anArrayLikeObj, <span class="number">0</span>);</div><div class="line">​</div><div class="line"><span class="built_in">console</span>.log(newArray); <span class="comment">// ["Martin", 78, 67, Array[3]]​</span></div><div class="line">​</div><div class="line"><span class="comment">// Search for "Martin" in the array-like object​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.indexOf.call(anArrayLikeObj, <span class="string">"Martin"</span>) === <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>); <span class="comment">// true​</span></div><div class="line">​</div><div class="line"><span class="comment">// Try using an Array method without the call () or apply ()​</span></div><div class="line"><span class="built_in">console</span>.log(anArrayLikeObj.indexOf(<span class="string">"Martin"</span>) === <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>); <span class="comment">// Error: Object has no method 'indexOf'​</span></div><div class="line">​</div><div class="line"><span class="comment">// Reverse the object:​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.reverse.call(anArrayLikeObj));</div><div class="line"><span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, 3: "Martin", length: 4&#125;​</span></div><div class="line">​</div><div class="line"><span class="comment">// Sweet. We can pop too:​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.pop.call(anArrayLikeObj));</div><div class="line"><span class="built_in">console</span>.log(anArrayLikeObj); <span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, length: 3&#125;​</span></div><div class="line">​</div><div class="line"><span class="comment">// What about push?​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.push.call(anArrayLikeObj, <span class="string">"Jackie"</span>));</div><div class="line"><span class="built_in">console</span>.log(anArrayLikeObj); <span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, 3: "Jackie", length: 4&#125;​</span></div></pre></td></tr></table></figure>
<p>这样的操作使得我们定义的对象既保留有所有对象的属性, 同时也能够在对象上使用数组方法.</p>
<p><strong>arguments</strong> 对象是所有 JavaScript 函数中的一个类数组对象, 因此 call() 和 apply() 的一个最常用的用法是从 arguments 中提取参数并将其传递给一个函数.</p>
<p>以下为 Ember.js 源码中的一部分, 加上了我的一些注释:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">transitionTo</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">// 因为 arguments 是一个类数组对象, 所以我们可以使用 slice()来处理它</span></div><div class="line">    <span class="comment">// 参数 "1" 表示我们返回一个从下标为1到结尾元素的数组</span></div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">​</div><div class="line">    <span class="comment">// 添加该行代码用于查看 args 的值</span></div><div class="line">    <span class="built_in">console</span>.log(args);</div><div class="line">​</div><div class="line">    <span class="comment">// 注释本例不需要使用到的代码</span></div><div class="line">    <span class="comment">//doTransition(this, name, this.updateURL, args);​</span></div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 使用案例</span></div><div class="line">transitionTo(<span class="string">"contact"</span>, <span class="string">"Today"</span>, <span class="string">"20"</span>); <span class="comment">// ["Today", "20"]​</span></div></pre></td></tr></table></figure>
<p>以上例子中, args 变量是一个真正的数组. 从以上案例中我们可以写一个得到快速得到传递给函数的所有参数(以数组形式)的函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="built_in">console</span>.log(args);</div><div class="line">&#125;</div><div class="line">​</div><div class="line">doSomething(<span class="string">"Water"</span>, <span class="string">"Salt"</span>, <span class="string">"Glue"</span>); <span class="comment">// ["Water", "Salt", "Glue"]​</span></div></pre></td></tr></table></figure>
<p>考虑到字符串是不可变的, 如果使用 apply 或者 call 方法借用字符串的方法, 不可变的数组操作对他们来说才是有效的, 所以你不能使用类似 reverse 或者 pop 等等这类的方法. 除此外, 我们也可以用他们借用我们自定义的方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gameController = &#123;</div><div class="line">    <span class="attr">scores</span>  :[<span class="number">20</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">77</span>],</div><div class="line">    <span class="attr">avgScore</span>:<span class="literal">null</span>,</div><div class="line">    <span class="attr">players</span> :[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Tommy"</span>, <span class="attr">playerID</span>:<span class="number">987</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Pau"</span>, <span class="attr">playerID</span>:<span class="number">87</span>, <span class="attr">age</span>:<span class="number">33</span>&#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="keyword">var</span> appController = &#123;</div><div class="line">    <span class="attr">scores</span>  :[<span class="number">900</span>, <span class="number">845</span>, <span class="number">809</span>, <span class="number">950</span>],</div><div class="line">    <span class="attr">avgScore</span>:<span class="literal">null</span>,</div><div class="line">    <span class="attr">avg</span>     :<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> sumOfScores = <span class="keyword">this</span>.scores.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> prev + cur;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">this</span>.avgScore = sumOfScores / <span class="keyword">this</span>.scores.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// Note that we are using the apply() method, so the 2nd argument has to be an array​</span></div><div class="line">appController.avg.apply(gameController);</div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// 46.4​</span></div><div class="line">​</div><div class="line"><span class="comment">// appController.avgScore is still null; it was not updated, only gameController.avgScore was updated​</span></div><div class="line"><span class="built_in">console</span>.log(appController.avgScore); <span class="comment">// null​</span></div></pre></td></tr></table></figure>
<p>这个例子非常简单, 我们定义的 gameController 对象借用了 appController 对象的 avg() 方法. 你也许会想, 如果我们借用的函数定义发生了变化, 那么我们的代码会发生什么变化. 借用(复制后)的函数也会变化么, 还是说他在完整复制后已经和原始的方法切断了联系? 让我们用下面这个小例子来说明这个问题:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">appController.maxNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.avgScore = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, <span class="keyword">this</span>.scores);</div><div class="line">&#125;</div><div class="line">​</div><div class="line">appController.maxNum.apply(gameController, gameController.scores);</div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// 77​</span></div></pre></td></tr></table></figure>
<p>正如我们所期望的那样, 如果我们修改原始的方法, 这样的变化会在借用实例的方法上体现出来. 我们总是希望如此, 因为我们从来不希望完整的复制一个方法, 我们只是想简单的借用一下.</p>
<h2 id="使用-apply-执行参数可变的函数"><a href="#使用-apply-执行参数可变的函数" class="headerlink" title="使用 apply() 执行参数可变的函数"></a>使用 apply() 执行参数可变的函数</h2><p>关于 Apply, Call 和 Bind 方法的多功能性和实用性, 我们将讨论一下Apply方法的一个很简单的功能: 使用参数数组执行函数.</p>
<p>Math.max() 方法是 JavaScript 中一个常见的参数可变函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">23</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">56</span>)); <span class="comment">// 56</span></div></pre></td></tr></table></figure>
<p>但如果我们有一个数组要传递给 Math.max(), 是不能这样做的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allNumbers = [<span class="number">23</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">56</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(allNumbers)); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<p>使用 apply 我们可以像下面这样传递数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allNumbers = [<span class="number">23</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">56</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, allNumbers)); <span class="comment">// 56</span></div></pre></td></tr></table></figure>
<p>正如之前讨论, apply() 的第一个参数用于设置 this 的指向, 但是 Math.max() 并未使用到 this, 所以我们传递 null 给他.</p>
<p>为了更进一步解释 apply() 在 参数可变函数上的能力, 我们自定义了一个参数可变函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> students = [<span class="string">"Peter Alexander"</span>, <span class="string">"Michael Woodruff"</span>, <span class="string">"Judy Archer"</span>, <span class="string">"Malcolm Khan"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 不定义参数, 因为我们可以传递任意多个参数进入该函数​</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">welcomeStudents</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">​</div><div class="line">    <span class="keyword">var</span> lastItem = args.pop();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Welcome "</span> + args.join (<span class="string">", "</span>) + <span class="string">", and "</span> + lastItem + <span class="string">"."</span>);</div><div class="line">&#125;</div><div class="line">​</div><div class="line">welcomeStudents.apply(<span class="literal">null</span>, students);</div><div class="line"><span class="comment">// Welcome Peter Alexander, Michael Woodruff, Judy Archer, and Malcolm Khan.</span></div></pre></td></tr></table></figure>
<h2 id="区别与注意事项"><a href="#区别与注意事项" class="headerlink" title="区别与注意事项"></a>区别与注意事项</h2><p>三个函数存在的区别, 用一句话来说的话就是: bind是返回对应函数, 便于稍后调用; apply, call则是立即调用. 除此外, 在 ES6 的箭头函数下, call 和 apply 的失效, 对于箭头函数来说:</p>
<ul>
<li>函数体内的 this 对象, 就是定义时所在的对象, 而不是使用时所在的对象;</li>
<li>不可以当作构造函数, 也就是说不可以使用 new 命令, 否则会抛出一个错误;</li>
<li>不可以使用 arguments 对象, 该对象在函数体内不存在. 如果要用, 可以用 Rest 参数代替;</li>
<li>不可以使用 yield 命令, 因此箭头函数不能用作 Generator 函数;</li>
</ul>
<p>更多关于箭头函数的介绍在这里就不做过多介绍了, 详情可以查看 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">Arrow functions</a>.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的叙述, Call, Apply 和 Bind 在设置 this 指向, 声称与执行参数可变函数以及函数借用方面的强大之处已经非常明显. 作为一名 JavaScript 开发者, 你一定会经常见到这种用法, 或者在开发中尝试使用他. 请确保你已经很好的了解了如上所述的概念与用法.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/06/JavaScript面向对象系列：三、理解对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/06/JavaScript面向对象系列：三、理解对象/" itemprop="url">
                  JavaScript面向对象系列：三、理解对象构造函数和原型对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-06T00:00:00+08:00">
                2017-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。"><a href="#js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。" class="headerlink" title="js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。"></a>js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。</h2><h2 id="当一个属性第一次被添加给对象时，js在对象上调用一个名为-Put-的内部方法。-Put-方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用-Put-的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。"><a href="#当一个属性第一次被添加给对象时，js在对象上调用一个名为-Put-的内部方法。-Put-方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用-Put-的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。" class="headerlink" title="当一个属性第一次被添加给对象时，js在对象上调用一个名为 [[Put]] 的内部方法。 [[Put]] 方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用 [[Put]] 的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。"></a>当一个属性第一次被添加给对象时，js在对象上调用一个名为 <strong><em>[[Put]]</em></strong> 的内部方法。 <strong><em>[[Put]]</em></strong> 方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用 <strong><em>[[Put]]</em></strong> 的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。</h2><h2 id="当一个已有的属性被赋予一个新值的时候，调用一个名为-Set-的方法。该方法将属性的当前方法替换为新值。"><a href="#当一个已有的属性被赋予一个新值的时候，调用一个名为-Set-的方法。该方法将属性的当前方法替换为新值。" class="headerlink" title="当一个已有的属性被赋予一个新值的时候，调用一个名为 [[Set]] 的方法。该方法将属性的当前方法替换为新值。"></a>当一个已有的属性被赋予一个新值的时候，调用一个名为 <strong><em>[[Set]]</em></strong> 的方法。该方法将属性的当前方法替换为新值。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span> <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">&#125;;</div><div class="line">person.age = <span class="number">25</span>; <span class="comment">//调用 [[Put]] 方法</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>; <span class="comment">//调用 [[Set]] 方法</span></div></pre></td></tr></table></figure>
<h2 id="属性探测"><a href="#属性探测" class="headerlink" title="属性探测"></a>属性探测</h2><p>不要使用一下模式探测属性是否存在<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(person.age)&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为当person.age 为一个对象、非空字符串、非零数字、true时，会判断为真。当person为 null、undefined、0、false、NaN或空字符串会判断为假。</p>
<p>更可靠的属性探测方式是使用 <strong><em>in</em></strong> 操作符。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sex"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>使用 <strong><em>in</em></strong> 操作符，在大多数情况下是属性探测的最好的办法。它还有一个额外的好处是不会评估属性的值。当此类评估会导致性能问题或者错误时，这一点很重要。</p>
<h2 id="在某些情况下，希望检查一个属性是不是自有属性。"><a href="#在某些情况下，希望检查一个属性是不是自有属性。" class="headerlink" title="在某些情况下，希望检查一个属性是不是自有属性。"></a>在某些情况下，希望检查一个属性是不是自有属性。</h2><p><strong><em>in</em></strong> 操作符会检查自有属性和原型属性，所以不能检查出正确结果。</p>
<p>另一个方法是 hasOwnProperty方法，这个方法只有在属性存在并且是自有属性时才返回true。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span> <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">"toString"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>##删除对象属性</p>
<p>使用 <strong><em>delete</em></strong> 操作符可以将属性从一个对象中删除。将对象的一个属性设置为null并不能将属性从对象中彻底删除，这种做法只会将原值替换为null。</p>
<p>使用 <strong><em>delete</em></strong> 操作符会调用对象内部名为 <strong><em>[[Delete]]</em></strong> 的内部方法。相当于从哈希表中移除了一个键值对。</p>
<h2 id="属性枚举"><a href="#属性枚举" class="headerlink" title="属性枚举"></a>属性枚举</h2><p>对象内部属性 <strong><em>[[Enumerable]]</em></strong> 设置为true，则属性可以循环遍历。可以使用 <strong><em>for-in</em></strong> 操作符来遍历一个对象。es5中新增 <strong><em>Object.keys()</em></strong> 来遍历对象的键，返回一个键组成的数组。</p>
<p>这两种操作符循环遍历有区别， <strong><em>for-in</em></strong> 操作符会遍历自有属性和原型属性，<strong><em>Object.keys()</em></strong> 只会遍历自由属性。</p>
<p>并不是所有属性都是可枚举的，实际上，对象大部分原生方法的 <strong><em>[[Enumerable]]</em></strong> 设置为false,可以使用 <strong><em>propertyIsEnumerable()</em></strong> 方法来检查一个属性是否为可枚举，每个对象都有这个方法。</p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p><strong><em>get</em></strong> 和 <strong><em>set</em></strong> 属性时访问器属性，可以定义属性被读取或者写入时候的行为。这两个属性可以只设置其中一个，如果只设置 <strong><em>get</em></strong> 这个属性变为只读，如果只设置 <strong><em>set</em></strong> 这个属性变为只写，这两种情况在严格模式下会报错.</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>, <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">    set name(value)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>);</div><div class="line">        <span class="keyword">this</span>.name = value;</div><div class="line">    &#125;,</div><div class="line">    get name()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person.name; <span class="comment">//get</span></div><div class="line">person.name = <span class="string">'xiaowang'</span>; <span class="comment">//set</span></div></pre></td></tr></table></figure>
<p>##通用特征</p>
<p>有两个属性是数据和访问器都具有的。一个是 <strong><em>[[Enumerable]]</em></strong> ，决定了你是否可以遍历该属性。另一个是<br><strong><em>[[Configurable]]</em></strong> ,决定了该属性是否可配置.可以随时删除或改变一个可配置属性。改变属性特征，可以使用 <strong><em>Object.defineProperty()</em></strong> 方法。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.propertyIsEnumerable(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> propertites = <span class="built_in">Object</span>.keys(person);</div><div class="line"><span class="built_in">console</span>.log(propertites.length); <span class="comment">//0</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></div><div class="line">&#125;);  <span class="comment">//报错</span></div></pre></td></tr></table></figure>
<p>一个属性被设置为不可配置了，就不能再修改了。<strong>无法将一个不可配置属性变成可配置属性</strong> 。删除一个不可配置属性，非严格模式下会失败，严格模式下会报错。</p>
<h2 id="数据属性特征"><a href="#数据属性特征" class="headerlink" title="数据属性特征"></a>数据属性特征</h2><p>数据属性拥有两个访问器属性不具备的特征：</p>
<p>第一个是 <strong><em>[[Value]]</em></strong> ,包含属性的值，在对象上创建属性时该特征被自动赋值。所有的属性的值都保存在 <strong><em>[[Value]]</em></strong> 中，即使值是一个函数。</p>
<p>第二个是 <strong><em>[[Writable]]</em></strong> ,该特种是一个布尔值，只是该属性是否可以写入，所有的属性默认是可写的。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">value</span>:<span class="string">"laowang"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.propertyIsEnumerable(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div></pre></td></tr></table></figure>
<p>使用 <strong><em>Object.defineProperty()</em></strong> 定义新的属性时，一定要为所有特征指定一个值，否则布尔值类型的特征会被默认设置为false。上面这个name就是不可枚举，不可配置，不可写。</p>
<h2 id="定义多重属性"><a href="#定义多重属性" class="headerlink" title="定义多重属性"></a>定义多重属性</h2><p>使用 <strong><em>Object.defineProperty()</em></strong> 可以定义一个属性的特征。使用 <strong><em>Object.defineProperties()</em></strong> 可以定义多个属性的特征。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperties(person,&#123;</div><div class="line">    <span class="attr">name</span>:&#123;</div><div class="line">        <span class="attr">value</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">age</span>:&#123;</div><div class="line">        <span class="attr">value</span>:<span class="number">25</span>,</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">false</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="获取属性特征"><a href="#获取属性特征" class="headerlink" title="获取属性特征"></a>获取属性特征</h2><p>使用 <strong><em>Object.getOwnPropertyDescriptor()</em></strong> 可以获取一个属性的所有特征</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.writable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">//laowang</span></div></pre></td></tr></table></figure>
<h2 id="对象禁止扩展"><a href="#对象禁止扩展" class="headerlink" title="对象禁止扩展"></a>对象禁止扩展</h2><p>对象也有内部特征，禁止扩展方法是 <strong><em>Object.preventExtensions()</em></strong> 。可以用 <strong><em>Object.isExtensible()</em></strong> 来检查对象的 <strong><em>[[Extensible]]</em></strong> 的值。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h2 id="对象封印"><a href="#对象封印" class="headerlink" title="对象封印"></a>对象封印</h2><p>对象封印时创建不可扩展对象的第二种方法。对象被封印后是不可扩展的并且所有属性都不可配置。不仅不能给对象添加新属性，也不能删除属性或改变其类型（从数据属性编程访问器属性或者相反）。一个对象被封印，则只能读写它的属性。</p>
<p>使用 <strong><em>Object.seal()</em></strong> 方法来封印一个对象。对象的 <strong><em>[[Extensible]]</em></strong> 被设置为false。 其余所有属性的 <strong><em>[[Configurate]]</em></strong> 特征被设置为false。可以使用 <strong><em>Object.isSealed()</em></strong>  来判断一个对象是否被封印。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.seal(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//xiaowang</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//xiaowang</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="对象冻结"><a href="#对象冻结" class="headerlink" title="对象冻结"></a>对象冻结</h2><p>创建不可扩展对象的最后一种方法是冻结对象。如果一个对象被冻结，则不能在对象上添加或者删除属性，不能改变属性类型，也不能写入任何数据属性。被冻结对象是一个数据属性都为只读的封印对象。被冻结的对象无法解冻。使用 <strong><em>Object.freeze()</em></strong> 来冻结一个对象，使用 <strong><em>Object.isFrozen()</em></strong> 来判断一个对象是否被冻结。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.writable); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>属性有两种类型：数据属性、访问器属性。数据属性可以保存值，访问器属性不保存值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/05/24/JavaScript面向对象系列：二、函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/24/JavaScript面向对象系列：二、函数/" itemprop="url">
                  JavaScript面向对象系列：二、函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T00:00:00+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为-Call-的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。"><a href="#在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为-Call-的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。" class="headerlink" title="在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 [[Call]] 的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。"></a>在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 <strong><em>[[Call]]</em></strong> 的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。</h2><h2 id="Call-属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有-Call-属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含-Call-属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof-不会再将正则表达式鉴别为函数了"><a href="#Call-属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有-Call-属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含-Call-属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof-不会再将正则表达式鉴别为函数了" class="headerlink" title="[[Call]] 属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有 [[Call]] 属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含 [[Call]] 属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof 不会再将正则表达式鉴别为函数了."></a><strong><em>[[Call]]</em></strong> 属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有 <strong><em>[[Call]]</em></strong> 属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含 <strong><em>[[Call]]</em></strong> 属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof 不会再将正则表达式鉴别为函数了.</h2><h2 id="声明还是表达式"><a href="#声明还是表达式" class="headerlink" title="声明还是表达式"></a>声明还是表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数具有两种字面形式</div></pre></td></tr></table></figure>
<p>第一种：函数声明<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种：函数表达式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两种看起来相似，实际上有一个非常重要的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数名声形式的会被提升至上下文（context）顶部，而函数表达式不会</div></pre></td></tr></table></figure></p>
<p>所以就会有下面的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种实际上是能正确运行的，这是因为函数声明被提升至上下文顶部，好像被写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>但是下面这种就会报错<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为函数表达式不会被提升，所以上面执行时找不到函数。<br>不过，只要你始终在使用函数前定义他们，你就可以随意使用者两种字面形式.</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>js的函数另一个独特之处在于你可以给函数传递任意数量的参数却不造成错误。因为函数参数实际被保存在arguments的类数组对象中。</p>
<p>函数的命名参数只不过是为了方便使用，并不是真正的限制了该函数可接受参数的个数。</p>
<p>函数的命名参数都是函数的期望参数，函数的length属性只会显示出期望参数的个数。</p>
<p>例如</p>
<p>情况一<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflect</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>)); <span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>),<span class="number">25</span>); <span class="comment">//"1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect.length); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>情况二<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflect</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>)); <span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>),<span class="number">25</span>); <span class="comment">//"1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect.length); <span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>大多数面向对象语言支持函数重载，它能让一个函数具有多个 <strong><em>函数签名（函数签名由函数的名字，参数的个数以及其类型组成）</em></strong> ,因为js可以接受任意数量的参数且没有类型限制，所以js没有函数重载。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Default message"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayMessage(<span class="string">"Hello"</span>); <span class="comment">//"Default message"</span></div></pre></td></tr></table></figure></p>
<p>这里为什么是 “Default message”,可以用对象来帮助理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sayMessage = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"message"</span>,<span class="string">"console.log(message);"</span>);</div><div class="line">sayMessage = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"message"</span>,<span class="string">"console.log(\"Default message\");"</span>);</div><div class="line">sayMessage(<span class="string">"Hello!"</span>); <span class="comment">//Default message</span></div></pre></td></tr></table></figure></p>
<p>但是js可以模仿函数重载</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</div><div class="line">        message = <span class="string">"Default message"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line">sayMessage(<span class="string">"Hello!"</span>); <span class="comment">//Hello!</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js函数的独特之处在于它们同时也是对象，也就是说它们可以被访问、复制、覆盖，就像其他对象一样。js中的函数和其他对象最大区别在于函数对象有一个特殊的内部属性 <strong><em>[[Call]]</em></strong>,包含了该函数的执行指令。typeof 操作符会在对象内部查找这个内部属性，如果找到，就返回 “function”</p>
<p>函数字面形式有两种：声明和表达式。函数声明会被提升至上下文顶部，而函数表达式不会。但是函数表达式可以用于任何可以使用值的地方，例如赋值语句、函数参数或者另一个函数的返回值。</p>
<p>函数是对象，所以存在一个构造函数 Function。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/05/20/JavaScript面向对象系列：一、类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/20/JavaScript面向对象系列：一、类型/" itemprop="url">
                  JavaScript面向对象系列：一、类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T00:00:00+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js有5中原始类型-Boolean-number-string-null-undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。"><a href="#js有5中原始类型-Boolean-number-string-null-undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。" class="headerlink" title="js有5中原始类型 Boolean number string null undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。"></a>js有5中原始类型 Boolean number string null undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。</h2><h2 id="js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝-例如"><a href="#js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝-例如" class="headerlink" title="js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝.例如"></a>js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝.例如</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color1 = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> color2 = color1;</div></pre></td></tr></table></figure>
<h2 id="每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量"><a href="#每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量" class="headerlink" title="每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量."></a>每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量.</h2><h2 id="虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）"><a href="#虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）" class="headerlink" title="虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）."></a>虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）.</h2><h2 id="尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。"><a href="#尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。" class="headerlink" title="尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。"></a>尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。</h2><h2 id="引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。"><a href="#引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。" class="headerlink" title="引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。"></a>引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。</h2><h2 id="当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。"><a href="#当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。" class="headerlink" title="当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。"></a>当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。</h2><h2 id="js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。"><a href="#js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。" class="headerlink" title="js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。"></a>js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。</h2><h2 id="js内建类型-Array-Date-Error-Function-Object-RegExp"><a href="#js内建类型-Array-Date-Error-Function-Object-RegExp" class="headerlink" title="js内建类型 Array Date Error Function Object RegExp"></a>js内建类型 Array Date Error Function Object RegExp</h2><h2 id="鉴别引用类型，对于函数，typeof-返回的是-funcion-但是其他引用类型的返回都是object-其他的引用类型可以使用instanceof来鉴别。"><a href="#鉴别引用类型，对于函数，typeof-返回的是-funcion-但是其他引用类型的返回都是object-其他的引用类型可以使用instanceof来鉴别。" class="headerlink" title="鉴别引用类型，对于函数，typeof 返回的是 funcion,但是其他引用类型的返回都是object.其他的引用类型可以使用instanceof来鉴别。"></a>鉴别引用类型，对于函数，typeof 返回的是 funcion,但是其他引用类型的返回都是object.其他的引用类型可以使用instanceof来鉴别。</h2><h2 id="es5引入Array-isArray-item-来鉴别数组"><a href="#es5引入Array-isArray-item-来鉴别数组" class="headerlink" title="es5引入Array.isArray(item)来鉴别数组"></a>es5引入Array.isArray(item)来鉴别数组</h2><h2 id="原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。"><a href="#原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。" class="headerlink" title="原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。"></a>原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。</h2><h2 id="字符串对象的存在仅用于该语句并在随后被销毁。"><a href="#字符串对象的存在仅用于该语句并在随后被销毁。" class="headerlink" title="字符串对象的存在仅用于该语句并在随后被销毁。"></a>字符串对象的存在仅用于该语句并在随后被销毁。</h2><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"aaaa"</span>;</div><div class="line">name.last = <span class="string">"bbbb"</span></div><div class="line"><span class="built_in">console</span>.log(name.last);  <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>下面是实际在js引擎中实际发生的事</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name  = <span class="string">"aaaa"</span>;</div><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(name);</div><div class="line">temp.last = <span class="string">"bbbb"</span>;</div><div class="line">temp = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(name);</div><div class="line"><span class="built_in">console</span>.log(temp);  <span class="comment">//undefined</span></div><div class="line">temp = <span class="literal">null</span></div></pre></td></tr></table></figure>
<p>实际上是在一个立刻就被销毁的临时对象上而不是字符串上添加了新的属性。之后当你试图访问该属性时，另一个不同的临时对象被创建，而新属性并不存在。虽然原始封装类型会被自动创建，在这些值上进行instanceof检查对应类型的返回值却都是false。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"aaa"</span>;</div><div class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(name <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(count <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(found <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>这是因为临时对象仅在值被读取时被创建。instanceof操作符并没有真的读取任何东西，也就是没有临时对象的创建，于是它告诉我们这些值并不属于原始封装类型。<br>你也可以手动创建原始封装类型，但是有某些副作用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"aaa"</span>);</div><div class="line"><span class="keyword">var</span> count = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> found = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">//"object"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> count); <span class="comment">//"object"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> found); <span class="comment">//"object"</span></div></pre></td></tr></table></figure>
<p>手动创建原始封装类型实际会创建出一个object，这意味着typeof无法手动鉴别出你实际保存的数据类型</p>
<h2 id="一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。"><a href="#一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。" class="headerlink" title="一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。"></a>一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found =  <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"><span class="keyword">if</span>(found)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Found"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//结果执行了，"Found"</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>javascript中虽然没有类，但是有类型。每个变量或数据都有一个对应的原始类型或者引用类型。5种原始类型（字符串、数字、布尔值、空类型、未定义）的值会被直接保存在变量对象中。除了空类型，都可以用typeof来鉴别。空类型必须直接跟null进行比较才能鉴别。

引用类型是js中最接近类的东西，而对象则是引用类型的实例。可以使用new操作符或者字面量的形式创建新对象。通常可以用点号访问属性和方法，也可以用中括号。函数在js中也是对象，可以使用typeof来鉴别他们。至于其他引用类型，你应该用instanceof和一个构造函数来鉴别。

为了让原始类型看上去更像引用类型，js提供了三种原始封装类型：String、Number、Boolean。js会在背后创建这些对象是的你能够像使用普通对象那样直接使用原始值，但是这些临时对象在使用它们的语句结束时就立刻被销毁。虽然你也可以自己创建原始封装类型的实例，但是它们太容易令人误解，所以最好别这么干。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="赖宝" />
          <p class="site-author-name" itemprop="name">赖宝</p>
           
              <p class="site-description motion-element" itemprop="description">努力学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖宝</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
