<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="努力学习">
<meta property="og:type" content="website">
<meta property="og:title" content="赖宝的宝">
<meta property="og:url" content="http://blog.webtoatl.cn/page/2/index.html">
<meta property="og:site_name" content="赖宝的宝">
<meta property="og:description" content="努力学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赖宝的宝">
<meta name="twitter:description" content="努力学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.webtoatl.cn/page/2/"/>





  <title> 赖宝的宝 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖宝的宝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端技能分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/09/知识点整理 - 前端涉及的各种像素概念以及 viewport 汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/09/知识点整理 - 前端涉及的各种像素概念以及 viewport 汇总/" itemprop="url">
                  知识点整理 - 前端涉及的各种像素概念以及 viewport 汇总
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T00:00:00+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><strong>设备像素(device pixel, dp)</strong>: 又称为物理像素。指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位 pt。pt 在 css 单位中属于真正的绝对单位，1pt = 1/72(inch), inch及英寸，而1英寸等于2.54厘米。所以设备像素的特点就是大小固定，不可变。比如 iPhone 5 的分辨率为 640 x 1136px.</li>
<li><strong>CSS像素(css pixel, px)</strong>: 又称为虚拟像素，也可以理解为直觉像素。CSS 像素是 Web 编程的概念，指的是 CSS 样式代码中使用的逻辑像素。在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是前面所说的设备像素(device pixel)。比如 iPhone 5 的 CSS 像素数为 320 x 568px.</li>
</ul>
<h2 id="关于像素的那些事"><a href="#关于像素的那些事" class="headerlink" title="关于像素的那些事"></a>关于像素的那些事</h2><p>前面说到的 px 相对单位指的是图像显示的基本单元，<strong>它既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。</strong> 刚刚提到了图像显示的基本单元，这个东西在不同设备上又是不一样的，例如显示器上的物理像素指的是显示器的点距，而打印机的物理像素则指的是打印机的墨点。</p>
<p>作为一个抽象概念，CSS 像素又具有两个方面的相对性，即：</p>
<ul>
<li>在同一个设备上，每1个 CSS 像素所代表的设备像素是可以变化的（即CSS像素的第一方面的相对性）；</li>
<li>在不同的设备之间，每1个 CSS 像素所代表的设备像素是可以变化的（即CSS像素的第二方面的相对性）；</li>
</ul>
<p>所以，<strong>CSS中的1px（CSS像素 可变）!== 设备的1px（设备像素 不可变）</strong>。</p>
<h3 id="CSS-像素的真正含义"><a href="#CSS-像素的真正含义" class="headerlink" title="CSS 像素的真正含义"></a>CSS 像素的真正含义</h3><p>按照 CSS 规范的定义，CSS 中的 px 是一个相对长度，它相对的，是 viewing device 的分辨率。这个 viewing device，通常就是电脑显示器。典型的电脑显示器的分辨率是96DPI，也就是1像素为1/96英寸（实际上，假设我们的显示器分辨率都与物理分辨率一致，而液晶点距其实是0.25mm到0.29mm之间，所以不太可能是正好1/96英寸，而只是接近）。</p>
<p>一般来说，px 就是对应设备的物理像素，然而如果输出设备的解析度与电脑显示器大不相同，输出效果就会有问题。例如打印机输出到纸张上，其解析度比电脑屏幕要高许多，如果不缩放，直接使用设备的物理像素，那电脑上的照片由 600DPI 的打印机打出来就比用显示器看小了约6倍。</p>
<p>由于不同的物理设备的物理像素的大小是不一样的，所以 CSS 认为浏览器应该对 CSS 中的像素进行调节，使得浏览器中 1个 CSS 像素的大小在不同物理设备上看上去大小总是差不多，目的是为了保证阅读体验的一致。为了达到这一点，浏览器可以直接按照设备的物理像素大小进行换算，而 CSS 规范中使用<strong>参考像素</strong>来进行换算。</p>
<p>一个参考像素即为从一臂之遥看解析度为 96DPI 的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。它并不是1/96英寸长度，而是从一臂之遥的距离处看解析度为 96DPI 的设备输出一单位（即1/96英寸）时视线与水平线的夹角。通常认为常人臂长为28英寸，所以它的视角是:<br>(1/96)in / (28in <em> 2 </em> PI / 360deg) = 0.0213度。如下图是一个示意图：</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-2.png" alt=""></p>
<p>对于人来说，眼睛看到的大小取决于可视角度。而可视角度取决于物体的实际大小以及物体与眼睛的距离。10米远处一个1米见方的东西，与1米远处的10厘米见方的东西，看上去的大小差不多是一样的，所谓一叶障目不见泰山，讲的就是这个常识。</p>
<p>左边的屏幕（可以认为是电脑屏幕）的典型视觉距离是71厘米即28英寸，其1px对应了0.28mm；而右边的屏幕（可以认为是你的42寸高清电视）的典型视觉距离是3.5米即120英寸，其1px对应1.3mm。42寸的1080p电视，分辨率是1920*1080，则其物理像素只有0.5mm左右。</p>
<p>综上，px 是一个相对单位，而且在特定设备上总是一个近似值（原则是尽量接近参考像素）。</p>
<h3 id="影响像素的那些因素"><a href="#影响像素的那些因素" class="headerlink" title="影响像素的那些因素"></a>影响像素的那些因素</h3><p>然而，如果你把绝对单位理解为对输出效果的绝对掌控，事情却大相径庭。就网页输出的最主要对象——电脑屏幕来说，px 可被视为一个基准单位——与桌面分辨率一致，如果是液晶屏，则几乎总是与液晶屏物理分辨率一致——也就是说网页设计者设定的1px，就是“最终打开这个网页的用户在显示器上看到的1个点距”！反倒是那些绝对单位，其实一点也不绝对。</p>
<p>那么 <strong>px 都会受哪些因素的影响而变化</strong>？</p>
<ul>
<li><strong>每英寸像素(pixel per inch, ppi/PPI)</strong>: 它表示的是每英寸所拥有的像素(pixel)数目，更确切的说法应该是<strong>像素密度</strong>，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。数值越高，代表显示屏能够以越高的密度显示图像。</li>
<li><strong>设备像素比(device pixel ratio, dpr/DPR)</strong>: 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。如何理解这个概念呢？通俗来说，它是指在开发中1个 CSS 像素占用多少设备像素，如 <code>dpr=2</code> 代表1个 CSS 像素用2x2个设备像素来绘制，所以，可以理解为 <strong>1px由多少个设备像素组成</strong></li>
<li><strong>DPI</strong>: 每英寸多少点。</li>
</ul>
<p>当用于描述显示器时，我们可以吧 ppi 和 dpi 认为是同一个概念。那么 ppi 和 dpr 到底是什么关系呢？ ppi 用作显示设备的工业标准，业界人士用 ppi 的值来衡量一个屏幕是否为高清屏，然后根据得到的密度分界来获得此时对应的 dpr 值，也即默认缩放比例。 dpr 和 ppi 相关，一般 dpr 为 ppi/160 的整数倍，如下所示：</p>
<table>
<thead>
<tr>
<th>项名</th>
<th>ldpi</th>
<th>mdpi</th>
<th>hdpi</th>
<th>xhdpi</th>
</tr>
</thead>
<tbody>
<tr>
<td>密度分界（密度值）</td>
<td>120</td>
<td>160</td>
<td>240</td>
<td>320</td>
</tr>
<tr>
<td>屏幕尺寸（分辨率）</td>
<td>240×320</td>
<td>320×480</td>
<td>480×800</td>
<td>640×960</td>
</tr>
<tr>
<td>默认缩放比例</td>
<td>0.75</td>
<td>1.0</td>
<td>1.5</td>
<td>2.0</td>
</tr>
</tbody>
</table>
<p>了解了这两个概念后，我们可以来说说导致 CSS 中 px 变化的因素了。</p>
<ul>
<li><strong>像素密度</strong>：从 iPhone4 开始，苹果推出了 Retina 屏，分辨率提高了一倍（640<em>960），而屏幕尺寸却没变。这时一个css像素=2个设备像素（换算公式为 `1px = (dpr)^2 </em> 1dp`, 必须让css中的1px代表更多的设备像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，否则会因太小而看不清），即 DPR=2，示意图如下：</li>
</ul>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-1.png" alt=""></p>
<ul>
<li><strong>缩放操作</strong>：缩放也会引起 css 中 px 的变化。放大页面到200%，字体大小与元素宽度的像素值不变，只是css的1px代表设备像素中的4px，宽高都是200%，DPR增加了。此时，获取 <code>screen.width</code> 值不变，而 <code>window.innerWidth/Height</code> 值（visual viewport）变成原来的一半。缩放值越大，当前 viewport 宽度会越小。</li>
</ul>
<p>如何理解上面说到的缩放呢？放大1倍，原来 1px 的东西变成 2px，但 1px 变为 2px 并不是把原来的 320px 变为 640px，而是在实际宽度不变的情况下，1px 变得跟原来的 2px 的长度（长宽）一样了（元素会占据更多的设备像素），所以放大1倍后原来需要 320px 才能填满的宽度现在只需要 160px，也即原来 320px 的面积里现在只能填入 160px 的东西了。</p>
<p>举个例子说明 CSS 像素的相对性，如下示意图：</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-3.png" alt=""></p>
<p>作为Web开发者，我们接触的更多的是用于控制元素样式的样式单位像素。这里的像素我们称之为CSS像素。假设我们用PC浏览器打开一个页面，浏览器此时的效果如左图所示，但如果我们把页面放大（通过“Ctrl键”加上“+号键”），此时块状容器则横向扩张，如右图所示（黑色为实际效果，灰色为原来效果）。吊诡的是此时我们既没有调整浏览器窗口大小，也没有改变块状元素的css宽度，但是它看上去却变大了一倍——这是因为我们把CSS像素放大为了原来的两倍。</p>
<p>也就是说默认情况下一个CSS像素应该是等于一个物理像素的宽度的，但是浏览器的放大操作让一个CSS像素等于了多个设备像素宽度。</p>
<ul>
<li><strong>设备独立像素(Device independent Pixel, DIP)</strong>: 也称为逻辑像素，简称 DIP.</li>
</ul>
<h2 id="像素换算与倍率"><a href="#像素换算与倍率" class="headerlink" title="像素换算与倍率"></a>像素换算与倍率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DPR = 设备像素 / CSS像素 = 屏幕横向设备像素 / 理想视口的宽</div><div class="line">CSS像素 = 设备独立像素 = 逻辑像素</div></pre></td></tr></table></figure>
<p>有关倍率，我们用 iPhone 3gs 和 4s 来举例。假设有个邮件列表界面，我们不妨按照PC端网页设计的思维来想象。3gs上大概只能显示4-5行，4s就能显示9-10行，而且每行会变得特别宽。但两款手机其实是一样大的。如果照这种方式显示，3gs上刚刚好的效果，在4s上就会小到根本看不清字。</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-4.png" alt=""></p>
<p>在现实中，这两者效果却是一样的。这是因为Retina屏幕把2x2个像素当1个像素使用。比如原本44像素高的顶部导航栏，在Retina屏上用了88个像素的高度来显示。导致界面元素都变成2倍大小，反而和3gs效果一样了。画质却更清晰。</p>
<p>在以前，iOS应用的资源图片中，同一张图通常有两个尺寸。你会看到文件名有的带@2x字样，有的不带。其中不带@2x的用在普通屏上，带@2x的用在Retina屏上。只要图片准备好，iOS会自己判断用哪张，Android道理也一样。</p>
<p>由此可以看出，苹果以普通屏为基准，给Retina屏定义了一个2倍的倍率（iPhone 6plus除外，它达到了3倍）。实际像素除以倍率，就得到逻辑像素尺寸。只要两个屏幕逻辑像素相同，它们的显示效果就是相同的。</p>
<h2 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h2><h3 id="都有哪些-viewport"><a href="#都有哪些-viewport" class="headerlink" title="都有哪些 viewport?"></a>都有哪些 viewport?</h3><p><strong>什么是 viewport？</strong> 通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。</p>
<p>首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，DPR 的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视 DPR 的值而定），就是满屏的宽度了。为了防止某些网站因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。<a href="http://www.quirksmode.org/" target="_blank" rel="external">ppk大神</a> 把这个浏览器默认的viewport叫做 <strong>layout viewport</strong>。这个 layout viewport 的宽度可以通过 document.documentElement.clientWidth 来获取。</p>
<p>然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，我们叫他 <strong>visual viewport</strong>。visual viewport 的宽度可以通过 window.innerWidth 来获取，但在 Android 2, Oprea mini 和 UC 8 中无法正确获取。下图为两个 viewport 的示意图：</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-6.png" alt=""></p>
<p>现在我们已经有两个viewport了 - layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的 viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理，这就是第三个 viewport ——移动设备的理想 viewport (ideal viewport)。</p>
<p>ideal viewport 并没有一个固定的尺寸，不同的设备拥有有不同的 ideal viewport。所有 iPhone 的 ideal viewport 宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在 iPhone 中，css 中的 320px 就代表 iPhone 屏幕的宽度。</p>
<p>但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到 <a href="http://viewportsizes.com" target="_blank" rel="external">http://viewportsizes.com</a> 去查看一下，里面收集了众多设备的理想宽度。</p>
<p>总结一下，ppk把移动设备上的viewport分为layout viewport, visual viewport 和 ideal viewport 三类：</p>
<ul>
<li>ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户；</li>
<li>layout viewport 表示的是浏览器默认的viewport，一般情况下这个宽度要大于浏览器可视区域宽度；</li>
<li>visual viewport 表示浏览器可视区域的大小。</li>
</ul>
<h3 id="利用-meta-标签对-viewport-进行控制"><a href="#利用-meta-标签对-viewport-进行控制" class="headerlink" title="利用 meta 标签对 viewport 进行控制"></a>利用 meta 标签对 viewport 进行控制</h3><p>viewport是专为手机浏览器设计的一个meta标签，一个简单的示例如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，<code>width=device-width</code> 表示此宽度不依赖于原始象素(px)，而依赖于屏幕的宽度。移动设备<strong>默认的viewport是layout viewport</strong>，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。我们在开发移动设备的网站时，最常见的的一个动作就是把上面这个东西复制到我们的head标签中，它的作用是让当前的 viewport 宽度等于设备宽度，同事不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</p>
<p>这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。在苹果的规范中，meta viewport 有6个可以设置的内容：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>设置layout viewport  的宽度，为一个正整数，或字符串”device-width”</td>
</tr>
<tr>
<td>initial-scale</td>
<td>设置页面的初始缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>允许用户的最小缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>允许用户的最大缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>height</td>
<td>设置layout viewport  的高度，这个属性对我们并不重要，很少使用</td>
</tr>
<tr>
<td>user-scalable</td>
<td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td>
</tr>
</tbody>
</table>
<p>这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。此外，在安卓中还支持 <code>target-densitydpi</code> 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素，但作为将要废弃的属性，所以使用中需要避免该用法。我们接下来看看具体的几个用法：</p>
<ul>
<li><strong>width=device-width</strong>: 所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iPhone和iPad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。</li>
<li><strong>initial-scale=1</strong>: 这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。</li>
</ul>
<p>要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的。</p>
<p>但如果width 和 initial-scale=1同时出现，并且还出现了冲突呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=400, initial-scale=1"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>width=400表示把当前viewport的宽度设为400px，initial-scale=1则表示把当前viewport的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度）</p>
<p>最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病。关于缩放，我们可以得出以下一个式子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当前缩放值 = ideal viewport宽度  / visual viewport宽度</div></pre></td></tr></table></figure>
<p>大多数浏览器都符合这个理论，但是安卓上的原生浏览器以及IE有些问题。安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。</p>
<p>好了，现在再来说下initial-scale的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的layout viewport宽度会被设为 ideal viewport的宽度，但前面说了，各浏览器默认的 layout viewport宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport的宽度的，所以 initial-scale的默认值肯定不是1。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的initial-scale默认值。</p>
<p>根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewpor设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的viewport meta标签，此时layout viewport的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了，此时值应为 0.33 左右。</p>
<p>所以总结一下：<strong>在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</strong></p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-7.png" alt=""></p>
<h3 id="JavaScript-动态更改-meta-viewport-标签"><a href="#JavaScript-动态更改-meta-viewport-标签" class="headerlink" title="JavaScript 动态更改 meta viewport 标签"></a>JavaScript 动态更改 meta viewport 标签</h3><ul>
<li><strong>方法一</strong>：可以使用document.write来动态输出meta viewport标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&apos;);</div></pre></td></tr></table></figure>
<ul>
<li><strong>方法二</strong>：通过 <code>setAttribute</code> 方法改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;meta id=&quot;testViewport&quot; name=&quot;viewport&quot; content=&quot;width = 380&quot;&gt;</div><div class="line">&lt;script&gt;</div><div class="line">let mvp = document.getElementById(&apos;testViewport&apos;);</div><div class="line">mvp.setAttribute(&apos;content&apos;,&apos;width=480&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>但是要注意，在安卓2.3(或许是所有2.x版本中)的自带浏览器中，对meta viewport标签进行覆盖或更改，会出现让人非常迷糊的结果。</p>
<p>总结一下，每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。</p>
<p>为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。</p>
<p>当然，以上内容对于了解像素概念及 viewport 原理有很大的帮助，但是实际开发中为了提高效率还是需要我们去复用已经实现的代码 snippet, 千万不要像我刚开始还总是想着“重复制造轮子”，幸好在师兄的指导下改正了过来。感激。</p>
<h2 id="参考整理自如下来源"><a href="#参考整理自如下来源" class="headerlink" title="参考整理自如下来源"></a>参考整理自如下来源</h2><ul>
<li><a href="http://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="external">http://www.cnblogs.com/2050/p/3877280.html</a></li>
<li><a href="http://blog.csdn.net/aiolos1111/article/details/51967744" target="_blank" rel="external">http://blog.csdn.net/aiolos1111/article/details/51967744</a></li>
<li><a href="http://ourjs.com/detail/54c73ba2232227083e00001a" target="_blank" rel="external">http://ourjs.com/detail/54c73ba2232227083e00001a</a></li>
<li><a href="https://github.com/jawil/blog/issues/21" target="_blank" rel="external">https://github.com/jawil/blog/issues/21</a></li>
<li><a href="http://ued.ourfuture.cn/fed/4200.html" target="_blank" rel="external">http://ued.ourfuture.cn/fed/4200.html</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/" target="_blank" rel="external">http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/</a></li>
<li><a href="http://www.jianshu.com/p/76130f4d7cf9" target="_blank" rel="external">http://www.jianshu.com/p/76130f4d7cf9</a></li>
<li><a href="https://yukun.im/css/469" target="_blank" rel="external">https://yukun.im/css/469</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/05/D3.js学习笔记：简单条形图制作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/D3.js学习笔记：简单条形图制作/" itemprop="url">
                  D3.js学习笔记：简单条形图制作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T00:00:00+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>D3简介</strong>：D3.js is a JavaScript library for manipulating documents based on data. D3 helps you bring data to life using HTML, SVG and CSS. D3’s emphasis on web standards gives you the full capabilities of modern browsers without tying yourself to a proprietary framework, combining powerful visualization components and a data-driven approach to DOM manipulation.</p>
<hr>
<h2 id="一、元素选择"><a href="#一、元素选择" class="headerlink" title="一、元素选择"></a>一、元素选择</h2><p>平常的程序如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div = document.createElement("div");</div><div class="line">div.innerHTML = "Hello, world!";</div><div class="line">document.body.appendChild(div);</div></pre></td></tr></table></figure>
<p>通过使用D3.js的selector程序如下所示（网页全代码）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://d3js.org/d3.v3.min.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line"><span class="keyword">var</span> body = d3.select(<span class="string">"body"</span>);</div><div class="line"><span class="keyword">var</span> div = body.append(<span class="string">"div"</span>);</div><div class="line">div.html(<span class="string">"Hello, world!"</span>);</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，d3.select的元素body可以替换成其他很多元素。</p>
<hr>
<h2 id="二、变换方法"><a href="#二、变换方法" class="headerlink" title="二、变换方法"></a>二、变换方法</h2><p>selection.attr返回当前的选择内容，selection.append返回一个新内容。以下为一些示例：</p>
<ul>
<li>改变body样式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> body = d3.select(<span class="string">"body"</span>);</div><div class="line">body.style(<span class="string">"color"</span>, <span class="string">"black"</span>);</div><div class="line">body.style(<span class="string">"background-color"</span>, <span class="string">"white"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>添加一个新div（section需在样式表中提前定义）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3.selectAll(<span class="string">"section"</span>)</div><div class="line">	.attr(<span class="string">"class"</span>, <span class="string">"special"</span>)</div><div class="line">  .append(<span class="string">"div"</span>)</div><div class="line">	.html(<span class="string">"Hello, world!"</span>);</div></pre></td></tr></table></figure>
<hr>
<h2 id="三、手动码表"><a href="#三、手动码表" class="headerlink" title="三、手动码表"></a>三、手动码表</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"></div><div class="line">.chart div &#123;</div><div class="line">  font: 10px sans-serif;</div><div class="line">  background-color: steelblue;</div><div class="line">  text-align: right;</div><div class="line">  padding: 3px;</div><div class="line">  margin: 1px;</div><div class="line">  color: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chart"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 40px;"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 80px;"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 150px;"</span>&gt;</span>15<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 160px;"</span>&gt;</span>16<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 230px;"</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 420px;"</span>&gt;</span>42<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="四、自动码表"><a href="#四、自动码表" class="headerlink" title="四、自动码表"></a>四、自动码表</h2><p>假设我们已经定义了chart的样式，则代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d3.select(<span class="string">".chart"</span>)</div><div class="line">  .selectAll(<span class="string">"div"</span>)</div><div class="line">	.data(data)</div><div class="line">  .enter().append(<span class="string">"div"</span>)</div><div class="line">	.style(<span class="string">"width"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d * <span class="number">10</span> + <span class="string">"px"</span>; &#125;)</div><div class="line">	.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</div></pre></td></tr></table></figure>
<p>select是选中chart块，而selectAll是选中chart中的已有和之后可能有的div块，data是用于数据绑定，enter().append()是为现在不存在的元素增加div块，style是设置显示长度，text是设置显示文字内容。</p>
<p>为了让条形图的长度适合，我们可以定下一个范围，让数据根据自身大小自行处理。x轴的长度设置如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = d3.scale.linear()</div><div class="line">	.domain([<span class="number">0</span>, d3.max(data)])</div><div class="line">	.range([<span class="number">0</span>, <span class="number">420</span>]);</div></pre></td></tr></table></figure>
<p>自动填补长度的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d3.select(<span class="string">".chart"</span>)</div><div class="line">  .selectAll(<span class="string">"div"</span>)</div><div class="line">	.data(data)</div><div class="line">  .enter().append(<span class="string">"div"</span>)</div><div class="line">	.style(<span class="string">"width"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> x(d) + <span class="string">"px"</span>; &#125;)</div><div class="line">	.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</div></pre></td></tr></table></figure>
<p>总代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"></div><div class="line">.chart div &#123;</div><div class="line">  font: 10px sans-serif;</div><div class="line">  background-color: steelblue;</div><div class="line">  text-align: right;</div><div class="line">  padding: 3px;</div><div class="line">  margin: 1px;</div><div class="line">  color: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://d3js.org/d3.v3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = d3.scale.linear()</div><div class="line">	.domain([<span class="number">0</span>, d3.max(data)])</div><div class="line">	.range([<span class="number">0</span>, <span class="number">420</span>]);</div><div class="line"></div><div class="line">d3.select(<span class="string">".chart"</span>)</div><div class="line">  .selectAll(<span class="string">"div"</span>)</div><div class="line">	.data(data)</div><div class="line">  .enter().append(<span class="string">"div"</span>)</div><div class="line">	.style(<span class="string">"width"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> x(d) + <span class="string">"px"</span>; &#125;)</div><div class="line">	.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/03/动手实现一个简单的浏览器端js模块加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/03/动手实现一个简单的浏览器端js模块加载器/" itemprop="url">
                  动手实现一个简单的浏览器端js模块加载器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T00:00:00+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在es6之前，js不像其他语言自带成熟的模块化功能，页面只能靠插入一个个script标签来引入自己的或第三方的脚本，并且容易带来命名冲突的问题。js社区做了很多努力，在当时的运行环境中，实现”模块”的效果。<br>通用的js模块化标准有CommonJS与AMD，前者运用于node环境，后者在浏览器环境中由Require.js等实现。此外还有国内的开源项目Sea.js，遵循CMD规范。（目前随着es6的普及已经停止维护，不论是AMD还是CMD，都将是一段历史了）</p>
<h3 id="浏览器端js加载器"><a href="#浏览器端js加载器" class="headerlink" title="浏览器端js加载器"></a>浏览器端js加载器</h3><p>实现一个简单的js加载器并不复杂，主要可以分为 <strong>解析路径、下载模块、解析模块依赖、解析模块</strong> 四个步骤。<br>首先定义一下模块。在各种规范中，通常一个js文件即表示一个模块。那么，我们可以在模块文件中，构造一个闭包，并传出一个对象，作为模块的导出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(factory() &#123;</div><div class="line">    <span class="keyword">var</span> x = &#123;</div><div class="line">        <span class="attr">a</span>: <span class="number">1</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>define函数接收一个工厂函数参数，浏览器执行该脚本时，define函数执行factory，并把它的return值存储在加载器的模块对象modules里。<br>如何 <strong>标识</strong> 一个模块呢？可以用文件的 <strong>uri</strong>，它是唯一标识，是天然的id。<br>文件路径path有几种形式：</p>
<p>绝对路径：<a href="http://xxx" target="_blank" rel="external">http://xxx</a>, file://xxx</p>
<p>相对路径：./xxx ， ../xxx ， xxx(相对当前页面的文件路径)</p>
<p>虚拟绝对路径：/xxx /表示网站根目录<br>因此，需要一个resolvePath函数来将不同形式的path解析成uri，参照当前页面的文件路径来解析。</p>
<p>接着，假设我们需要引用a.js与b.js两个模块，并设置了需要a与b才能执行的回调函数f。我们希望加载器去拉取a与b，当a与b都加载完成后，从modules里取出a与b作为参数传给f，执行下一步操作。这里可以用观察者模式（即订阅/发布模式）实现，创建一个eventProxy，订阅加载a与加载b事件；define函数执行到最后，已经把导出挂载modules里之后，emit一个本模块加载完成的事件，eventProxy收到后检查a与b是否都加载完成，如果完成，就传参给f执行回调。</p>
<p>同理，eventProxy也可以实现模块依赖加载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define([ <span class="string">'c.js'</span>, <span class="string">'d.js'</span> ], factory (c, d) &#123;</div><div class="line">    <span class="keyword">var</span> x = c + d;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>define函数的第一个参数可以传入一个依赖数组，表示a模块依赖c与d。define执行时，告诉eventProxy订阅c与d加载事件，加载好了就执行回调函数f存储a的导出，并emit事件a已加载。</p>
<p>浏览器端加载脚本的原始方法是插入一个 <strong>script</strong> 标签，指定src之后，浏览器开始下载该脚本。<br>那么加载器中的模块加载可以用dom操作实现，插入一个script标签并指定src，此时该模块为下载中状态。<br>PS：浏览器中，动态插入script标签与初次加载页面dom时的script加载方式不同：</p>
<p>初次加载页面，浏览器会从上到下顺序解析dom，碰到script标签时，下载脚本并阻塞dom解析，等到该脚本下载、执行完毕后再继续解析之后的dom（现代浏览器做了preload优化，会预先下载好多个脚本，但执行顺序与它们在dom中顺序一致，执行时阻塞其他dom解析）</p>
<p>动态插入script，<strong>var a = document.createElement(‘script’); a.src=’xxx’; document.body.appendChild(a)</strong>;浏览器会在该脚本下载完成后执行，过程是异步的。</p>
<p>下载完成后执行上述的操作，解析依赖-&gt;加载依赖-&gt;解析本模块-&gt;加载完成-&gt;执行回调。</p>
<p>模块下载完成后，如何在解析它时知道它的uri呢？有两种发发，一种是用 <strong>srcipt.onload</strong> 获取 <strong>this</strong> 对象的src属性；一种是在define函数中采用 <strong>document.currentScript.src</strong>。</p>
<p>实现基本的功能比较简单，代码不到200行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zmm = &#123;</div><div class="line">    <span class="attr">_modules</span>: &#123;&#125;,</div><div class="line">    <span class="attr">_configs</span>: &#123;</div><div class="line">        <span class="comment">// 用于拼接相对路径</span></div><div class="line">        basePath: (<span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (path.charAt(path.length - <span class="number">1</span>) === <span class="string">'/'</span>) &#123;</div><div class="line">                path = path.substr(<span class="number">0</span>, path.length - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> path.substr(path.indexOf(location.host) + location.host.length + <span class="number">1</span>);</div><div class="line">        &#125;)(location.href),</div><div class="line">        <span class="comment">// 用于拼接相对根路径</span></div><div class="line">        host: location.protocol + <span class="string">'//'</span> + location.host + <span class="string">'/'</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.hasModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断是否已有该模块，不论加载中或已加载好</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._modules.hasOwnProperty(_uri);</div><div class="line">&#125;;</div><div class="line">zmm.isModuleLoaded = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断该模块是否已加载好</span></div><div class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>._modules[_uri];</div><div class="line">&#125;;</div><div class="line">zmm.pushModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 新模块占坑，但此时还未加载完成，表示加载中；防止重复加载</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._modules.hasOwnProperty(_uri)) &#123;</div><div class="line">        <span class="keyword">this</span>._modules[_uri] = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">zmm.installModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri, mod</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._modules[_uri] = mod;</div><div class="line">&#125;;</div><div class="line">zmm.load = <span class="function"><span class="keyword">function</span> (<span class="params">uris</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i, nsc;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; uris.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.hasModule(uris[i])) &#123;</div><div class="line">            <span class="keyword">this</span>.pushModule(uris[i]);</div><div class="line">            <span class="comment">// 开始加载</span></div><div class="line">            <span class="keyword">var</span> nsc = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">                nsc.src = uri;</div><div class="line">            <span class="built_in">document</span>.body.appendChild(nsc);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.resolvePath = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="comment">// 返回绝对路径</span></div><div class="line">    <span class="keyword">var</span> res = <span class="string">''</span>, paths = [], resPaths;</div><div class="line">    <span class="keyword">if</span> (path.match(<span class="regexp">/.*:\/\/.*/</span>)) &#123;</div><div class="line">        <span class="comment">// 绝对路径</span></div><div class="line">        res = path.match(<span class="regexp">/.*:\/\/.*?\//</span>)[<span class="number">0</span>]; <span class="comment">// 协议+域名</span></div><div class="line">        path = path.substr(res.length);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.charAt(<span class="number">0</span>) === <span class="string">'/'</span>) &#123;</div><div class="line">        <span class="comment">// 相对根路径 /开头</span></div><div class="line">        res = <span class="keyword">this</span>._configs.host;</div><div class="line">        path = path.substr(<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 相对路径 ./或../开头或直接文件名</span></div><div class="line">        res = <span class="keyword">this</span>._configs.host;</div><div class="line">        resPaths = <span class="keyword">this</span>._configs.basePath.split(<span class="string">'/'</span>);</div><div class="line">    &#125;</div><div class="line">    resPaths = resPaths || [];</div><div class="line">    paths = path.split(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (paths[i] === <span class="string">'..'</span>) &#123;</div><div class="line">            resPaths.pop();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paths[i] === <span class="string">'.'</span>) &#123;</div><div class="line">            <span class="comment">// do nothing</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            resPaths.push(paths[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    res += resPaths.join(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> define = zmm.define = <span class="function"><span class="keyword">function</span> (<span class="params">dependPaths, fac</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _uri = <span class="built_in">document</span>.currentScript.src;</div><div class="line">    <span class="keyword">if</span> (zmm.isModuleLoaded(_uri)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> factory, depPaths, uris = [];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">        factory = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 挂载到模块组中</span></div><div class="line">        zmm.installModule(_uri, factory());</div><div class="line">        <span class="comment">// 告诉proxy该模块已装载好</span></div><div class="line">        zmm.proxy.emit(_uri);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 有依赖的情况</span></div><div class="line">        factory = <span class="built_in">arguments</span>[<span class="number">1</span>];</div><div class="line">        <span class="comment">// 装载完成的回调函数</span></div><div class="line">        zmm.use(<span class="built_in">arguments</span>[<span class="number">0</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            zmm.installModule(_uri, factory.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</div><div class="line">            zmm.proxy.emit(_uri);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.use = <span class="function"><span class="keyword">function</span> (<span class="params">paths, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(paths)) &#123;</div><div class="line">        paths = [paths];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> uris = [], i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</div><div class="line">        uris.push(<span class="keyword">this</span>.resolvePath(paths[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 先注册事件，再加载</span></div><div class="line">    <span class="keyword">this</span>.proxy.watch(uris, callback);</div><div class="line">    <span class="keyword">this</span>.load(uris);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.proxy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> proxy = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> taskId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> taskList = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> execute = <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> uris = task.uris,</div><div class="line">            callback = task.callback;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arr = []; i &lt; uris.length; i++) &#123;</div><div class="line">            arr.push(zmm._modules[uris[i]]);</div><div class="line">        &#125;</div><div class="line">        callback.apply(<span class="literal">null</span>, arr);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> deal_loaded = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> i, k, task, sum;</div><div class="line">        <span class="comment">// 当一个模块加载完成时，遍历当前任务栈</span></div><div class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> taskList) &#123;</div><div class="line">            <span class="keyword">if</span> (!taskList.hasOwnProperty(k)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            task = taskList[k];</div><div class="line">            <span class="keyword">if</span> (task.uris.indexOf(_uri) &gt; <span class="number">-1</span>) &#123;</div><div class="line">                <span class="comment">// 查看这个任务中的模块是否都已加载好</span></div><div class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; task.uris.length; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (zmm.isModuleLoaded(task.uris[i])) &#123;</div><div class="line">                        sum ++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (sum === task.uris.length) &#123;</div><div class="line">                    <span class="comment">// 都加载完成 删除任务</span></div><div class="line">                    <span class="keyword">delete</span>(taskList[k]);</div><div class="line">                    execute(task);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    proxy.watch = <span class="function"><span class="keyword">function</span> (<span class="params">uris, callback</span>) </span>&#123;</div><div class="line">        <span class="comment">// 先检查一遍是否都加载好了</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; uris.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (zmm.isModuleLoaded(uris[i])) &#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sum === uris.length) &#123;</div><div class="line">            execute(&#123;</div><div class="line">                <span class="attr">uris</span>: uris,</div><div class="line">                <span class="attr">callback</span>: callback</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 订阅新加载任务</span></div><div class="line">            <span class="keyword">var</span> task = &#123;</div><div class="line">                <span class="attr">uris</span>: uris,</div><div class="line">                <span class="attr">callback</span>: callback</div><div class="line">            &#125;;</div><div class="line">            taskList[<span class="string">''</span> + taskId] = task;</div><div class="line">            taskId ++;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    proxy.emit = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(_uri + <span class="string">' is loaded!'</span>);</div><div class="line">        deal_loaded(_uri);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h2 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h2><p>“循环加载”指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。这是一种应该尽量避免的设计。</p>
<h3 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h3><p>用上面的zmm工具加载模块a:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.html</span></div><div class="line">zmm.use(<span class="string">'/a.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</div><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="string">'/b.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  a = b + <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="string">'/a.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> b;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>就会陷入a等待b加载完成、b等待a加载完成的死锁状态。sea.js碰到这种情况也是死锁，也许是默认这种行为不应该出现。<br>seajs里可以通过require.async来缓解循环依赖的问题，但必须改写a.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="string">'./js/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  <span class="built_in">require</span>.async(<span class="string">'./b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</div><div class="line">      a = b + <span class="number">1</span>;</div><div class="line">      <span class="built_in">module</span>.exports = a; <span class="comment">//a= 3</span></div><div class="line">  &#125;);</div><div class="line">  <span class="built_in">module</span>.exports = a; <span class="comment">// a= 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="string">'./js/b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line">  <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">  <span class="built_in">module</span>.exports = b;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// main.html</span></div><div class="line">seajs.use(<span class="string">'./js/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但这么做a就必须先知道b会依赖自己，且use中输出的是b还没加载时a的值，use并不知道a的值之后还会改变。<br>在浏览器端，似乎没有很好的解决方案。node模块加载碰到的循环依赖问题则小得多。</p>
<h3 id="node-CommonJS"><a href="#node-CommonJS" class="headerlink" title="node/CommonJS"></a>node/CommonJS</h3><p>CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。CommonJS的做法是，一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = a;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</div><div class="line">a = b + <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = a;</div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line"><span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = b;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>上面main.js的代码中，先加载模块a，执行require函数，此时内存中已经挂了一个模块a，它的exports为一个空对象a.exports={}；接着执行a.js中的代码；执行var b = require(‘./b’);之前，a.exports=1，接着执行require(b)；b.js被执行时，拿到的是a.exports=1，b加载完成后，执行权回到a.js；最后a模块的输出为3。</p>
<p>CommonJS与浏览器端的加载器有着实现上的差异。node加载的模块都是在本地，执行的是同步的加载过程，即按依赖关系依次加载，执行到加载语句就去加载另一个模块，加载完了再回到函数调用点继续执行；浏览器端加载scripts由于天生限制，只能采取异步加载，执行回调来实现。</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。因此，ES6模块是动态引用，不存在缓存值的问题，而且模块里面的变量，绑定其所在的模块。</p>
<p>这导致ES6处理”循环加载”与CommonJS有本质的不同。ES6根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">'./odd'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123; counter++; <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);&#125;</div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">'./even'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123; <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);&#125;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./even.js'</span>;</div><div class="line">m.even(<span class="number">10</span>); <span class="comment">// true; m.counter = 6</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，even.js里面的函数even有一个参数n，只要不等于0，就会减去1，传入加载的odd()。odd.js也会做类似作。</p>
<p>上面代码中，参数n从10变为0的过程中，foo()一共会执行6次，所以变量counter等于6。第二次调用even（）时，参数n从20变为0，foo()一共会执行11次，加上前面的6次，所以变量counter等于17。</p>
<p>而这个例子要是改写成CommonJS，就根本无法执行，会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">exports.counter = counter;</div><div class="line">exports.even = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">counter++;</div><div class="line"><span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./even'</span>);</div><div class="line">m.even(<span class="number">10</span>); <span class="comment">// TypeError: even is not a function</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成”循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/02/知识点整理 - Redux 介绍与基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/知识点整理 - Redux 介绍与基础/" itemprop="url">
                  知识点整理 - Redux 介绍与基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T00:00:00+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着 JavaScript 单页应用开发日趋复杂，越来越多的 state （状态）需要在前端进行管理。</p>
<blockquote>
<p> 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p>
</blockquote>
<p>为了高效的管理 state 而不是简单的在全局上新建变量，开发者需要捋清 model/view 之间的关系，以降低前端开发的复杂性。此处以 Redux 为例，总结如何利用其设计思想以及实践经验，来使得应用的 state 管理变得容易。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Redux 的核心概念第一点则是 <strong>state</strong> 的表示，你可以用一个对象来表示应用的 state (可以看成 model) 但不能直接修改他（没有 setter）。这一步定义的内容可以看成是用于控制页面效果、动画的一些开关状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    todo: [],</div><div class="line">    name: &apos;me&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想要修改 state 中的数据只能通过发起 <strong>action</strong> 来实现（这样做的好处就是可以清晰的知道应用中到底发生了什么）， action 也是一个普通对象，用来描述将要发生什么。在 action 中我们需要存储发生事件的描述以及用于更新 state 的属性数据，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; type: &apos;ADD_TODO&apos;, text: &apos;Go to swimming pool&apos; &#125;</div></pre></td></tr></table></figure>
<p>那么如何接收 action 并更新返回新的 state 呢？用 <strong>reducer</strong> 函数。它接收 state 和 action，在内部处理后并返回新的 state。考虑到应用的复杂性，我们可以分别编写 reducer 分别独立地操作 state tree 的不同部分。</p>
<h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><ul>
<li><strong>单一数据源</strong>：整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li>
<li><strong>State 是只读的</strong>：唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li>
<li><strong>使用纯函数来执行修改</strong>：为了描述 action 如何改变 state tree ，你需要编写 reducers。</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。除了 type 字段外，对象结构完全由自己决定。但是需要注意的是应该尽量减少在 action 中传递的数据。</p>
<p>为了了解生成 action，还需要知道 action 创建函数，该函数只是简单的返回一个 action，这样做将使 action 创建函数更容易被移植和测试。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function addTodo(text) &#123;</div><div class="line">  return &#123;</div><div class="line">    type: ADD_TODO,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你把 action 创建函数结果传给 dispatch() 方法，即可发起一次 dispatch 过程，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch(addTodo(text))</div></pre></td></tr></table></figure>
<p>在使用过程中可能用到的工具包括 <code>connect()</code>， <code>bindActionCreators()</code></p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。通过 reducer，我们不仅可以修改 state 还可以借机初始化 state。</p>
<p>针对 action 的处理我们需要注意：不要修改 state，且在 default 情况下返回旧的 state。</p>
<p>在使用过程中可能用到的工具包括 <code>combineReducers()</code></p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>在知道了如何用 reducer 来根据 action 更新 state 后，需要进一步了解的就是 store —— 将它们联系到一起的对象。store 具有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <code>getState()</code> 方法获取 state；</li>
<li>提供 <code>dispatch(action)</code> 方法更新 state；</li>
<li>通过 <code>subscribe(listener)</code> 注册监听器;</li>
<li>通过 <code>subscribe(listener)</code> 返回的函数注销监听器。</li>
</ul>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>Redux 应用中的数据的生命周期遵循四个步骤：</p>
<ul>
<li>调用 <code>store.dispatch(action)</code></li>
<li>redux store 调用传入的 reducer 函数</li>
<li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树</li>
<li>Redux store 保存了根 reducer 返回的完整 state 树</li>
</ul>
<h3 id="搭配-react"><a href="#搭配-react" class="headerlink" title="搭配 react"></a>搭配 react</h3><p>结合 react 开发其中比较重要的一点在于如何设计组件层次结构。结合 react 可以知道在组件层次方面，主要需要考虑两点：展示组件和容器组件，当然不好区分的组件可以划分为其他组件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/02/JavaScript面向对象系列：六、对象模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/JavaScript面向对象系列：六、对象模式/" itemprop="url">
                  JavaScript面向对象系列：六、对象模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T00:00:00+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>js有很多创建对象的模式，完成工作的方式也不是只有一种。可以随时定义自己的类型和自己的泛用对象。可以使用继承或者混入等其他技术令对象间行为共享。也可以利用js高级技巧来组织对象结构被改变。</p>
<h2 id="私有成员和特权成员"><a href="#私有成员和特权成员" class="headerlink" title="私有成员和特权成员"></a>私有成员和特权成员</h2><p>js对象对象的所有属性都是公有的，且没有显式的方法指定某个属性不能被外界某个对象访问。然而，有时候可能不希望数据公有。</p>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>模块模式是一种拥有私有数据的单件对象的模式。基本做法就是使用立即调用函数表达式（IIFE）来返回一个对象。IIFE是一种被定义后立即调用并产生结果的函数表达式，该函数表达可以包括任意数量的本地变量，它们在函数外不可见。因为返回的对象被定义在函数内部，对象的方法可以访问这些数据。（IIFE定义的所有对象都可以访问通用的本地变量）以这种方式访问私有数据的方法被称为特权方法。</p>
<p>基本格式如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> yourObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//私有数据</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="comment">//公有方法和属性  </span></div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>IIFE是js中一种很流行的模式，部分原因就是模块模式中的应用。</p>
<p>模块模式允许使用普通变量作为非公有对象属性。通过创建必报函数作为对象方法来操作它们。闭包函数就是一个可以访问其作用域外部数据的普通函数。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">getAge</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">growOlder</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            age++;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<p>模块模式还有一个变种叫暴露模块模式，它将所有的变量和方法都组织在IIFE的顶部，然后将它们设置到需要被返回的对象上。可以使用暴露模块模式改写上面的例子。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">growOlder</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">getAge</span>:getAge,</div><div class="line">        <span class="attr">growOlder</span>:growOlder</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数中的私有成员"><a href="#构造函数中的私有成员" class="headerlink" title="构造函数中的私有成员"></a>构造函数中的私有成员</h2><p>模块模式在定义单个对象的私有属性上十分有效，但是对于那些同样需要私有属性的自定义类型，也可以在构造函数中使用类型的模式来创建每个实例的私有数据。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.growOlder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<p>如果需要所有实例可以共享的私有数据，可以结合模块模式和构造函数。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">InnerPerson</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InnerPerson.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InnerPerson.prototype.growOlder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> InnerPerson;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person1.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">//"xiaowang"</span></div><div class="line"><span class="built_in">console</span>.log(person2.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person1.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person1.getAge()); <span class="comment">//26</span></div><div class="line"><span class="built_in">console</span>.log(person2.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>js中大量使用了伪类继承和原型对象继承，还有另一种伪继承的手段叫混入。一个对象在不改变原型对象链的情况下得到了另一个对象的属性被称为混入。第一个对象（接收者）通过直接复制第二个对象（提供者）的属性从而接收了这些属性。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">receiver,supplier</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> supplier)&#123;</div><div class="line">        <span class="keyword">if</span>(supplier.hasOwnProperty(property))&#123;</div><div class="line">            receiver[property] = supplier[property];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> receiver;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过混入而不是继承给一个对象添加事件支持<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">EventTarget.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:EventTarget,</div><div class="line">    <span class="attr">addListener</span>:<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>) </span>&#123;</div><div class="line">        <span class="comment">//不存在数组就创建一个数组</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(<span class="string">"_listeners"</span>)) &#123;</div><div class="line">            <span class="keyword">this</span>._listeners = [];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._listeners[type] == <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._listeners[type] = [];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>._listeners[type].push(listener);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">fire</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!event.target) &#123;</div><div class="line">            event.target = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!event.type)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Event object missing 'type' propertype."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._listeners &amp;&amp; <span class="keyword">this</span>._listener[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[event.type];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = listeners.length; i &lt; len; i++)&#123;</div><div class="line">                listeners[i].call(<span class="keyword">this</span>,event);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">removeListener</span>:<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._listener &amp;&amp; <span class="keyword">this</span>._listener[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[type];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = listeners.length; i &lt; len; i++)&#123;</div><div class="line">                <span class="keyword">if</span>(listeners[i] === listener)&#123;</div><div class="line">                    listener.split(i,<span class="number">1</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>js对象中支持事件十分有用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> EventTarget();</div><div class="line">person.name = <span class="string">"laowang"</span>;</div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="keyword">this</span>.fire(&#123;<span class="attr">type</span>:<span class="string">"namsaid"</span>,<span class="attr">name</span>:name&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中，person作为EventTarget的实例被创建出来，然后添加各种跟person相关的属性。可惜的是这意味着person实际上是一个EventTarget而不是一个Object或者其他自定义类型。另外，你还需要承受手工添加一批新属性的开销。解决这个问题的方法是使用伪类继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = <span class="built_in">Object</span>.create(EventTarget.prototype);</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="keyword">this</span>.fire(&#123;</div><div class="line">        <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">        <span class="attr">name</span>:name</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> EventTarget); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>这个例子中，一个新的Person类型继承自EventTarget。随后可以在Person的原型对象上添加你需要的方法。然而不够简洁。</p>
<p>更简洁的例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">minix(Person.prototype,<span class="keyword">new</span> EventTarget());</div><div class="line">minix(Person.prototype,&#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> EventTarget); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>有时候可能需要一个对象的属性，但是不想用伪类继承的构造函数。可以使用混入来创建自己的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = mixin(<span class="keyword">new</span> EventTarget(),&#123;</div><div class="line">    get name()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"laowang"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"xiaowang"</span></div></pre></td></tr></table></figure></p>
<p>这段代码定义了仅有getter的访问器属性name。这意味着对该属性赋值应该不起作用。但是，由于在person对象里面该访问器属性变成了数据属性，你就有可能改写name的值。在调用minix()时，提供者name属性的值被读取后赋值给接受者name属性。在这个过程中没有机会定义一个新的访问器属性，从而使接收者的name属性成为了一个数据属性。</p>
<p>如果想要访问器属性被复制成访问器属性，需要一个不同的minix()函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span> (<span class="params">receiver,supplier</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">property</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(supplier,property);</div><div class="line">        <span class="built_in">Object</span>.defineProperty(receiver,property,descriptor);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> receiver;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = mixin(<span class="keyword">new</span> EventTarget(),&#123;</div><div class="line">    get name()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"laowang"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laoawng"</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div></pre></td></tr></table></figure></p>
<h2 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h2><p>构造函数也是函数，所以可以不用 new 操作符直接调用它们来改变this的值。在非严格模式下，this被强制指向全局对象，这个做法会导致无法预知的结果。在严格模式下，构造函数会抛出错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">//"undefined"</span></div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">//"laowang"</span></div></pre></td></tr></table></figure></p>
<p>很多內建构造函数，例如 <strong><em>Array</em></strong> 和 <strong><em>RegExp</em></strong> 不需要new也可以工作，这是因为他们被设计成为作用域安全的构造函数。一个作用域安全的构造函数有没有new都可以工作，并返回同样的对象。</p>
<p>一个作用域安全的构造函数如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js有很多不同的方式创建和组装对象。虽然js没有一个正式的私有属性的概念，但是可以创建仅在对象内可以访问的数据或者函数。对于单件对象，你可以使用模块模式对外界隐藏数据。可以使用立即调用表达式定义仅可被创建的对象访问的本地变量和函数。特权方法是可以访问对象私有数据的方法。你还可以创建具有私有属性的构造函数，一种方法是在构造函数定义变量，另一种方法是使用IIFE来创建所有实例共享的私有数据。</p>
<p>混入是一种给对象添加功能，同时便面继承的强有力方式。混入将一个属性从一个对象复制到另一个，从而使得接收者在不需要继承提供者的情况下获得其功能。和继承不同，混入令你在创建对象后无法检查属性来源。因此，混入最适合被用于数据属性或者小函数。如果需要更强大的功能且知道该功能来自哪里，继承仍然是我们推荐的做法。</p>
<p>作用域安全的构造函数是可以不用new都可以被调用来生成新的对象实例的构造函数。这种模式之所以能工作，是因为this在构造函数一开始执行时就已经指向自定义类型的实例，可以根据new的使用与否来决定构造函数的行为。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/20/JavaScript面向对象系列：五、继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/JavaScript面向对象系列：五、继承/" itemprop="url">
                  JavaScript面向对象系列：五、继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T00:00:00+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原型对象链和-Object-prototype"><a href="#原型对象链和-Object-prototype" class="headerlink" title="原型对象链和 Object.prototype"></a>原型对象链和 <strong><em>Object.prototype</em></strong></h2><p> js內建的继承方法被称为原型对象链，又可以称为原型对象继承。原型对象的属性可以经由对象实例访问，这就是继承的一种形式。对象实例继承了原型对象的属性。因为原型对象也是一个对象，他也有自己的原型对象并继承其属性。这就是原型对象链，而原型对象继承它的原型对象，以此类推。</p>
<p> 所有对象，包括哪些你自己定义的对象都自动继承自 <strong><em>Object</em></strong>，除非另有指定。更确切的说，所有对象都继承自 <strong><em>Object.prototype</em></strong>。任何以队形字面量形式定义的对象，其 <strong><em>[[Prototype]]</em></strong> 的值都被设为 <strong><em>Object.prototype</em></strong>,这意味着它继承 <strong><em>Object.prototype</em></strong> 的属性。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(book);</div><div class="line"><span class="built_in">console</span>.log(prototype === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="继承自-Object-peototype-的方法"><a href="#继承自-Object-peototype-的方法" class="headerlink" title="继承自 Object.peototype 的方法"></a>继承自 <strong><em>Object.peototype</em></strong> 的方法</h2><p>前面说到的很多方法其实都是定义在 <strong><em>Object.prototype</em></strong> 上面的。因此可以被其他对象继承。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>hasOwnProperty()</td>
<td>检查是否存在一个给定名字的自有属性</td>
</tr>
<tr>
<td>propertyIsEnumerable()</td>
<td>检查一个自有属性是否可枚举</td>
</tr>
<tr>
<td>isPrototypeof()</td>
<td>检查一个对象是否是另一个对象的原型对象</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回一个对象的值表达</td>
</tr>
<tr>
<td>toString()</td>
<td>返回一个对象的字符串表达</td>
</tr>
</tbody>
</table>
<p><strong><em>valueOf</em></strong>,每当一个操作符被用于一个对象时就会调用 <strong><em>valueOf()</em></strong> 方法。 <strong><em>valueOf()</em></strong> 默认返回对象实例本身。原始封装类型重写了 <strong><em>valueOf()</em></strong> 以使得它对 <strong><em>String</em></strong> 返回一个字符串，对 <strong><em>Boolean</em></strong> 返回一个布尔值，对 <strong><em>Number</em></strong> 返回一个数字。类似的，<strong><em>Date</em></strong> 对象返回一个 <strong><em>epoch</em></strong> 时间。如果你的对象也要这样使用操作符，也可以自定义 <strong><em>valueOf()</em></strong> 方法.定义的时候并没有改变操作符的行为，仅仅定了操作符默认行为所使用的值。</p>
<p><strong><em>toString()</em></strong>,一旦 <strong><em>valueOf()</em></strong> 方法返回的是一个引用而不是原始值的时候，就会回退调用 <strong><em>toString()</em></strong> 方法。另外，当js期望一个字符串时，也会对原始值隐式调用 <strong><em>toString()</em></strong> .例如，当加号操作符的一边是一个字符串时，另一边会被自动转换成字符串。如果另一边是一个原始值，会自动被转换成一个字符串表达（例如，<strong><em>true</em></strong> 转换成 <strong><em>“true”</em></strong>）。如果另一边是一个引用值，则会调用 <strong><em>valueOf()</em></strong>。如果 <strong><em>valueOf()</em></strong> 返回一个引用值，则调用 <strong><em>toString()</em></strong>。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> message = <span class="string">"Book = "</span> + book;</div><div class="line"><span class="built_in">console</span>.log(message); <span class="comment">//"Book = [object Object]"</span></div></pre></td></tr></table></figure>
<p>这段以 “Book =” 和book来构造字符串。因为book是一个对象，此时调用它的 <strong><em>toString()</em></strong> 方法。该方法继承自 <strong><em>Object.prototype</em></strong>,大部分js引擎返回默认值 “[object Object]”。如果对这个值满意，就不需要改变对象的 <strong><em>toString()</em></strong> 方法。定义自己的 <strong><em>toString()</em></strong> 方法有时候可以为此类字符串转换提供更过信息的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span>,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Book "</span> + <span class="keyword">this</span>.title + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> message = <span class="string">"Book = "</span> + book;</div><div class="line"><span class="built_in">console</span>.log(message); <span class="comment">//"Book = [Book javascript]"</span></div></pre></td></tr></table></figure></p>
<h2 id="修改-Object-pototype"><a href="#修改-Object-pototype" class="headerlink" title="修改 Object.pototype"></a>修改 <strong><em>Object.pototype</em></strong></h2><p>所有的对象都默认继承自 <strong><em>Object.prototype</em></strong>，所以改变 <strong><em>Object.prototype</em></strong> 会影响所有的对象，是非常危险的。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(book.add(<span class="number">5</span>)); <span class="comment">//"[object Object]5";</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"title"</span>.add(<span class="string">"end"</span>)); <span class="comment">//"titleend"</span></div><div class="line"></div><div class="line"><span class="comment">//在浏览器中</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.add(<span class="literal">true</span>)); <span class="comment">//"[object HTMLDocument]true"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.add(<span class="number">5</span>)); <span class="comment">//"[object Window]6"</span></div></pre></td></tr></table></figure></p>
<p>上面给 <strong><em>Object.prototype</em></strong> 添加方法可能会带来不可预知的结果</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prpperty <span class="keyword">in</span> empty)&#123;</div><div class="line">    <span class="built_in">console</span>.log(property);</div><div class="line">&#125;</div><div class="line"><span class="comment">// add</span></div></pre></td></tr></table></figure></p>
<p>空对象依然会输出一个”add”属性。考虑到js中 <strong><em>for-in</em></strong> 使用频繁，为 <strong><em>Object.prototype</em></strong> 添加可枚举属性会影响大量代码。所以可以在 <strong><em>for-in</em></strong> 中使用 <strong><em>hasOwnProperty()</em></strong>.</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prpperty <span class="keyword">in</span> empty)&#123;</div><div class="line">    <span class="keyword">if</span>(empty.hasOwnProperty(property))&#123;</div><div class="line">        <span class="built_in">console</span>.log(property);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure></p>
<p>这样循环只会输出对象自有属性，不会输出原型属性。</p>
<h2 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h2><p>对象继承是最简单的继承类型。唯一需要做的就是制定那个对象是新对象的 <strong><em>[[Prototype]]</em></strong> 。对象字面量形式会隐式指定 <strong><em>Object.prototype</em></strong> 为其 <strong><em>[[Prototype]]</em></strong>,也可以使用 <strong><em>Object.create()</em></strong> 方法显式指定。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//和下面是一样的</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> book = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</div><div class="line">    <span class="attr">title</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:<span class="string">"javascript"</span>,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>继承其他对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1,&#123;</div><div class="line">    <span class="attr">name</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:<span class="string">"xiaowang"</span>,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">person1.sayName(); <span class="comment">//"laowang"</span></div><div class="line">person2.sayName(); <span class="comment">//"xiaowang"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"sayName"</span>)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.isPrototypeOf(person2)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"sayName"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>另外，也可以通过 <strong><em>Object.create()</em></strong> 创建 <strong><em>[[Prototype]]</em></strong> 为null的对象，这样的对象是没有原型对象链的对象。意味着 <strong><em>toString()</em></strong> 和 <strong><em>valueOf()</em></strong> 等內建方法都不存在该对象上面。实际上，这种对象完全就是一个没有任何预定义属性的白板，也是一个完美的哈希容器，因为不会有自由属性和原型属性的冲突。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nakedObject = object.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> nakedObject); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"valueOf"</span> <span class="keyword">in</span> nakedObject); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>js中的对象继承也是构造函数继承的基础。几乎所有的函数都有 <strong><em>prototype</em></strong> 属性，它可以被修改或者换。该 <strong><em>prototype</em></strong> 属性被自动设置为一个新的继承自 <strong><em>Object.prototype</em></strong> 的泛用对象，该对象有一个自有属性 <strong><em>constructor</em></strong> ,实际上js引擎自动做了下面的事情</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">YourConstructor</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//js引擎自动为你做了下面的事情</span></div><div class="line">YourConstructor.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:YourConstructor,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>创建出来的对象都继承自 <strong><em>Object.prototype</em></strong>。YourConstructor 是Object的子类，Object是YourConstructor 的父类。</p>
<p>由于 <strong><em>prototype</em></strong> 属性可写，可以通过改写它来改变原型对象链。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = size;</div><div class="line">    <span class="keyword">this</span>.width = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="keyword">new</span> Rectangle();</div><div class="line">Square.prototype.constuctor = Square;</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">//50</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.toString()); <span class="comment">//"[Rectangle 5X10 ]"</span></div><div class="line"><span class="built_in">console</span>.log(square.toString()); <span class="comment">//"[Square 6X6 ]"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>此时不需要给Rectangle的调用提供参数，因为他们不需要被使用，而且如果提供了，那所有Square的对象实例都会共享同样的维度。用这种方式改变原型对象链时，需要确保构造函数不会再参数缺失时抛出错误（很多构造函数包含的初始化逻辑会需要参数）且构造函数不会改变任何全局状态，比如追踪有多少实例被创建等。</p>
<p>rect作为Rectangle的实例被创建，而square则是作为Square的实例被创建。两个对象都有getArea方法，那是因为继承自Reatangle.prototype。instanceof操作符认为变量square同时是Square、Rectangle、Object的实例，因为instanceof是使用原型对象链检查对象类型。</p>
<p>使用 <strong><em>Object.create()</em></strong> 方法可以简化并且不会导致参数缺失而报错。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = size;</div><div class="line">    <span class="keyword">this</span>.width = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">//50</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.toString()); <span class="comment">//"[Rectangle 5X10 ]"</span></div><div class="line"><span class="built_in">console</span>.log(square.toString()); <span class="comment">//"[Square 6X6 ]"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数窃取"><a href="#构造函数窃取" class="headerlink" title="构造函数窃取"></a>构造函数窃取</h2><p>由于js中的继承是通过原型对象链来实现的，因此不需要调用对象的父类构造函数。如果需要在子类构造函数中调用父类构造函数，就需要用 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong>。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    Retangle.call(<span class="keyword">this</span>,size,size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square.length); <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(square.width); <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div></pre></td></tr></table></figure></p>
<p>由于这种做法模仿了那些基于类语言的类继承，通常被称为伪类继承。</p>
<h2 id="访问父类方法"><a href="#访问父类方法" class="headerlink" title="访问父类方法"></a>访问父类方法</h2><p>子类提供的新功能覆盖父类方法很常见，但是如果还想访问父类方法，只能通过 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 来访问了，而且这是唯一方法。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    Retangle.call(<span class="keyword">this</span>,size,size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> text = Rectangle.prototype.toString().call(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> text.replace(<span class="string">"Rectangle"</span>,<span class="string">"Square"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js通过原型对象链支持继承。当将一个对象的 <strong><em>[[Prototype]]</em></strong> 设置为另一个对象时，就在这两个对象之间创建了一条原型对象链。所有的泛用对象都自动继承自 <strong><em>Object.prototype</em></strong> 。如果你想创建一个继承自其它对象的对象，你可以用 <strong><em>Object.create()</em></strong> 指定 <strong><em>[[Prototype]]</em></strong> 为一个新对象。</p>
<p>可以在构造函数中创建原型对象链来完成自定义类型之间的继承。通过将构造函数的 <strong><em>prototype</em></strong> 属性设置为某一个对象那个，就建立了自定义类型对象和该对象的继承关系。构造函数的所有对象、实例共享同一个原型对象，所以他们都继承自该对象。这个技术在继承其他对象的方式时工作得很好。但是不能用原型继承自有属性。</p>
<p>为了正确继承自有属性，可以使用构造函数窃取。只需要以 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 调用父类的构造函数，就可以在子类里面完成各种初始化。结合构造函数窃取和原型对象链是js中最常见的继承手段。由于和基于类的继承相似，这个组合经常被称为伪类继承。</p>
<p>可以通过直接访问父类原型对象的方式访问父类方法。必须以 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 执行父类方法并传入一个子类的对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/12/JavaScript面向对象系列：四、构造函数和原型对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/12/JavaScript面向对象系列：四、构造函数和原型对象/" itemprop="url">
                  JavaScript面向对象系列：四、构造函数和原型对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T00:00:00+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Prototype-属性"><a href="#Prototype-属性" class="headerlink" title="[[Prototype]] 属性"></a><strong><em>[[Prototype]]</em></strong> 属性</h2><p>一个对象实例通过内部属性 <strong><em>[[Prototype]]</em></strong> 跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针，当你new创建一个新的对象时，构造函数的原型对象会被赋值给该对象的  <strong><em>[[Prototype]]</em></strong> 属性。</p>
<p>可以调用对象的 <strong><em>Object.getPrototypeOf()</em></strong> 方法读取<strong><em>[[Prototype]]</em></strong> 属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(obj);</div><div class="line"><span class="built_in">console</span>.log(prototype === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="大部分js引擎都会提供一个-proto-属性。该属性使你可以直接读写-Prototype-属性。"><a href="#大部分js引擎都会提供一个-proto-属性。该属性使你可以直接读写-Prototype-属性。" class="headerlink" title="大部分js引擎都会提供一个  proto 属性。该属性使你可以直接读写 [[Prototype]] 属性。"></a>大部分js引擎都会提供一个 <strong> </strong>proto<strong> </strong>属性。该属性使你可以直接读写 <strong><em>[[Prototype]]</em></strong> 属性。</h2><h2 id="可以使用-isPrototypeOf-方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有"><a href="#可以使用-isPrototypeOf-方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有" class="headerlink" title="可以使用 isPrototypeOf() 方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有."></a>可以使用 <strong><em>isPrototypeOf()</em></strong> 方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(obj)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>因为obj是一个泛用对象，原型是Object.prototype</p>
<h2 id="当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索-Prototype-中的对象，如果找到则返回。如果找不到，则返回undefined。"><a href="#当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索-Prototype-中的对象，如果找到则返回。如果找不到，则返回undefined。" class="headerlink" title="当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索[[Prototype]] 中的对象，如果找到则返回。如果找不到，则返回undefined。"></a>当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索<strong><em>[[Prototype]]</em></strong> 中的对象，如果找到则返回。如果找不到，则返回undefined。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line">obj.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[object Custom]"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Custom]"</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> obj.toString;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> obj.toString;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div></pre></td></tr></table></figure>
<p>上述例子也说明了，仅当自有属性被删除时，原型属性才会再一次被使用。delete操作符仅对自有属性起作用，无法删除原型对象的属性。</p>
<h2 id="在构造函数中使用原型对象"><a href="#在构造函数中使用原型对象" class="headerlink" title="在构造函数中使用原型对象"></a>在构造函数中使用原型对象</h2><p>使用对象字面量形式改写原型对象时要注意 <strong><em>constructor</em></strong> 属性</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === Person); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>使用这种方式创建原型对象，<strong><em>constructor</em></strong> 属性会有误差。每一个原型对象都有一个 <strong><em>constructor</em></strong> 属性，这是其他对象实例没有的。</p>
<p>当一个函数被创建时，它的 <strong><em>prototype</em></strong> 属性也被创建，且该原型对象的 <strong><em>constructor</em></strong> 属性指向该函数。当使用对象字面量形式改写原型对象的时候，<strong><em>constructor</em></strong> 被置为泛对象Object。得手动修正。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === <span class="built_in">Object</span>); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.constructor === Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.constructor === <span class="built_in">Object</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>构造函数、原型对象和对象实例之间的关系最有趣的一个方面也许就是对象实例和构造函数之间没有直接联系。不过对象实例和原型对象以及原型对象和构造函数之间都有直接联系。</p>
<h2 id="改变原型对象"><a href="#改变原型对象" class="headerlink" title="改变原型对象"></a>改变原型对象</h2><p>给定类型的所有对象实例功效一个原型对象，所以可以一次性扩充所有对象实例。<strong>_[[Prototype]]</strong> 属性只是包含了一个指向原型对象的指针。任何对原型对象的改变都立即反映到所有引用它的对象实例上。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person1); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person2); <span class="comment">//false</span></div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person1.sayHi(); <span class="comment">//"Hi"</span></div><div class="line">person2.sayHi(); <span class="comment">//"Hi"</span></div></pre></td></tr></table></figure></p>
<p>对象封印和对象冻结只能操作对象的自有属性。封印或者冻结之后，无法添加自有属性或者改变冻结对象的自有属性。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(person1);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person1); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person2); <span class="comment">//false</span></div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person1.sayHi(); <span class="comment">//"Hi"</span></div><div class="line">person2.sayHi(); <span class="comment">//"Hi"</span></div></pre></td></tr></table></figure></p>
<p>其实，<strong><em>[[Prototype]]</em></strong> 属性是对象实例的自有属性，属性本身被冻结，但是其指向的值（原型对象）并没有被冻结。</p>
<p>实际开发中，可能不会频繁的使用原型对象，但是理解对象实例及其原型对象之间的关系是非常重要的。</p>
<h2 id="改变内建原型对象"><a href="#改变内建原型对象" class="headerlink" title="改变内建原型对象"></a>改变内建原型对象</h2><p>所有的內建对象都有构造函数，因此也都有原型对象可以改变。</p>
<p>例如，简单修改Array的原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> pre + cur;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = numbers.sum();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//15</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构造函数就是用 <strong><em>new</em></strong> 操作符调用的普通函数。可以随时定义自己的构造函数来创建多个具有同样属性的对象。可以用 <strong><em>instanceof</em></strong> 操作符或直接访问 <strong><em>constructor</em></strong> 属性来鉴别对象是被哪个构造函数创建的。</p>
<p>每一个函数都有都具有 <strong><em>prototype</em></strong> 属性，它定义了该构造函数创建的所有对象共享的属性。通常，共享的方法和原始值属性被定义在原型对象里，而其他属性都定义在构造函数里。 <strong><em>constructor</em></strong> 属性实际上被定义在原型对象里供所有对象实例共享。</p>
<p>原型对象被保存在对象实例内部的 <strong><em>[[Prototype]]</em></strong> 属性中。这个属性时一个引用而不是副本。由于js查找属性的机制，对原型对象的修改都立刻出现在所有对象实例中。当试图访问一个对象的某个属性时，js首先在自有属性里查找该名字，如果自有属性中没有找到则在原型属性中查找。这样的机制意味着原型对象可以随时改变而引用它的对象实例则立即反映出这些改变。</p>
<p>內建对象也有可以被修改的原型对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/07/JavaScript 中至关重要的 Apply, Call 和 Bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/07/JavaScript 中至关重要的 Apply, Call 和 Bind/" itemprop="url">
                  JavaScript 中至关重要的 Apply, Call 和 Bind
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-07T00:00:00+08:00">
                2017-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文基于 <a href="http://javascriptissexy.com/javascript-apply-call-and-bind-methods-are-essential-for-javascript-professionals/#" target="_blank" rel="external">JavaScript’s Apply, Call, and Bind Methods are Essential for JavaScript Professionals</a> 阅读整理而来, 其中对于原文中的内容进行了部分翻译与增删, 例如 ES6 中开发的注意事项以及三者之间的区别等等, 望周知. 阅读本文内容的先备知识包括:</p>
<ul>
<li>理解 JavaScript 中的 this 关键字</li>
<li>JavaScript 对象概念</li>
<li>JavaScript 闭包概念</li>
</ul>
<p>如果你对前面提到的先备知识有所了解, 你应该知道 JavaScript 中的函数其实是一种对象. 而作为对象, 函数是可以有方法的, 包括非常强大的 <code>Apply</code>, <code>Call</code> 以及 <code>Bind</code> 方法. 一方面, Apply 方法和 Call 方法的用途几乎相同, 在 JavaScript 中被频繁使用于方法借用和明确 this 关键字指向等场景. 我们也将 Apply 用于参数可变的函数; 在后文中你将会对此有更多的了解. 另一方面, 我们会使用 Bind 来给方法指定 this 指向值或者函数柯里化 (currying functions).</p>
<p>我们会讨论在 JavaScript 中使用这三种方法的每一个场景. Apply 和 Call 方法是在 ECMAScript 3 标准中出现的(可以在IE 6, 7, 8 以及现代浏览器中使用), ECAMScript 5 标准添加了 Bind 这个方法. 由于三种方法都非常强大, 开发时你一定会用到其中一个. 让我们先从 Bind 方法说起.</p>
<h2 id="Bind-方法"><a href="#Bind-方法" class="headerlink" title="Bind 方法"></a>Bind 方法</h2><p>我们用 Bind() 来实现在指明函数内部 this 指向的情况下去调用该函数, 换句话说, bind() 允许我们非常简单的在函数或者方法被调用时绑定 this 到指定对象上.</p>
<p>当我们在一个方法中用到了 this, 而这个方法调用于一个接收器对象, 我们会需要使用到 bind() 方法; 在这种情况下, 由于 this 不一定完全如我们所期待的绑定在目标对象上, 程序有时便会出错;</p>
<h2 id="Bind-允许我们明确指定方法中的-this-指向"><a href="#Bind-允许我们明确指定方法中的-this-指向" class="headerlink" title="Bind 允许我们明确指定方法中的 this 指向"></a>Bind 允许我们明确指定方法中的 this 指向</h2><p>当以下按钮被点击的时候, 文本输入框会被随机填入一个名字.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;button&gt;Get Random Person&lt;/button&gt;​</span></div><div class="line"><span class="comment">// &lt;input type="text"&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="attr">data</span>        :[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"T. Woods"</span>, <span class="attr">age</span>:<span class="number">37</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"P. Mickelson"</span>, <span class="attr">age</span>:<span class="number">43</span>&#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">clickHandler</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> randomNum = ((<span class="built_in">Math</span>.random () * <span class="number">2</span> | <span class="number">0</span>) + <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// random number between 0 and 1​</span></div><div class="line">​</div><div class="line">        <span class="comment">// 从 data 数组中随机选取一个名字填入 input 框内</span></div><div class="line">        $(<span class="string">"input"</span>).val(<span class="keyword">this</span>.data[randomNum].name + <span class="string">" "</span> + <span class="keyword">this</span>.data[randomNum].age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 给点击事件添加一个事件处理器</span></div><div class="line">$(<span class="string">"button"</span>).click(user.clickHandler);</div></pre></td></tr></table></figure>
<p>当你点击按钮时, 会发现一个报错信息: 因为 clickHandler() 方法中的 this 绑定的是按钮 HTML 内容的上下文, 因为这才是 clickHandler 方法的执行时的调用对象.</p>
<p>在 JavaScript 中这种问题比较常见, JavaScript 框架中例如 Backbone.js, jQuery 都自动为我们做好了绑定的工作, 所以在使用时 this 总是可以绑定到我们所期望的那个对象上.</p>
<p>为了解决之前例子中存在的问题, 我们利用 bind() 方法将 <code>$(&quot;button&quot;).click(user.clickHandler);</code> 换成以下形式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"button"</span>).click(user.clickHandler.bind(user));</div></pre></td></tr></table></figure>
<p>再考虑另一个方法来修复 this 的值: 你可以给 click() 方法传递一个匿名回调函数, jQuery 会将匿名函数的 this 绑定到按钮对象上.</p>
<blockquote>
<p>bind() 函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。 - MDN</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</div><div class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></div><div class="line">      <span class="comment">// internal IsCallable function</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </div><div class="line">        fToBind = <span class="keyword">this</span>, <span class="comment">// 此处的 this 指向目标函数</span></div><div class="line">        fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</div><div class="line">            ? <span class="keyword">this</span> <span class="comment">// 此处 this 为 调用 new obj() 时所生成的 obj 本身</span></div><div class="line">            : oThis || <span class="keyword">this</span>, <span class="comment">// 若 oThis 无效则将 fBound 绑定到 this</span></div><div class="line">            <span class="comment">// 将通过 bind 传递的参数和调用时传递的参数进行合并, 并作为最终的参数传递</span></div><div class="line">            aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用</span></div><div class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</div><div class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fBound;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续之前的例子, 如果我们将包含 this 的方法赋值给一个变量, 那么 this 的指向也会绑定到另一个对象上, 如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量 data</span></div><div class="line"><span class="keyword">var</span> data = [</div><div class="line">    &#123;<span class="attr">name</span>:<span class="string">"Samantha"</span>, <span class="attr">age</span>:<span class="number">12</span>&#125;,</div><div class="line">    &#123;<span class="attr">name</span>:<span class="string">"Alexis"</span>, <span class="attr">age</span>:<span class="number">14</span>&#125;</div><div class="line">]</div><div class="line">​</div><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="comment">// 局部变量 data</span></div><div class="line">    data    :[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"T. Woods"</span>, <span class="attr">age</span>:<span class="number">37</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"P. Mickelson"</span>, <span class="attr">age</span>:<span class="number">43</span>&#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">showData</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> randomNum = ((<span class="built_in">Math</span>.random () * <span class="number">2</span> | <span class="number">0</span>) + <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// random number between 0 and 1​</span></div><div class="line">​</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data[randomNum].name + <span class="string">" "</span> + <span class="keyword">this</span>.data[randomNum].age);</div><div class="line">    &#125;</div><div class="line">​</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 将 user 对象的 showData 方法赋值给一个变量</span></div><div class="line"><span class="keyword">var</span> showDataVar = user.showData;</div><div class="line">​</div><div class="line">showDataVar(); <span class="comment">// Samantha 12 (来自全局变量数组而非局部变量数组)​</span></div></pre></td></tr></table></figure>
<p>当我们执行 showDataVar() 函数时, 输出到 console 的数值来自全局 data 数组, 而不是 user 对象. 这是因为 showDataVar() 函数是被当做一个全局函数执行的, 所以在函数内部 this 被绑定位全局对象, 即浏览器中的 window 对象.</p>
<p>来, 我们用 bind 方法来修复这个 bug.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bind the showData method to the user object</span></div><div class="line"><span class="keyword">var</span> showDataVar = user.showData.bind(user);</div></pre></td></tr></table></figure>
<h2 id="Bind-方法允许我们实现函数借用"><a href="#Bind-方法允许我们实现函数借用" class="headerlink" title="Bind 方法允许我们实现函数借用"></a>Bind 方法允许我们实现函数借用</h2><p>在 JavaScript 中, 我们可以传递函数, 返回函数, 借用他们等等, 而 bind() 方法使函数借用变得极其简单. 以下为一个函数借用的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// cars 对象</span></div><div class="line"><span class="keyword">var</span> cars = &#123;</div><div class="line">    <span class="attr">data</span>:[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Honda Accord"</span>, <span class="attr">age</span>:<span class="number">14</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Tesla Model S"</span>, <span class="attr">age</span>:<span class="number">2</span>&#125;</div><div class="line">    ]</div><div class="line">​</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 我们从之前定义的 user 对象借用 showData 方法</span></div><div class="line"><span class="comment">// 这里我们将 user.showData 方法绑定到刚刚新建的 cars 对象上​</span></div><div class="line">cars.showData = user.showData.bind(cars);</div><div class="line">cars.showData(); <span class="comment">// Honda Accord 14​</span></div></pre></td></tr></table></figure>
<p>这里存在一个问题, 当我们在 cars 对象上添加一个新方法(showData)时我们可能不想只是简单的借用一个函数那样, 因为 cars 本身可能已经有一个方法或者属性叫做 showData 了, 我们不想意外的将这个方法覆盖了. 正如在之后的 <em>Apply 和 Call 方法</em> 章节我们会介绍, 借用函数的最佳实践应该是使用 Apply 或者 Call 方法.</p>
<h2 id="Bind-方法允许我们柯里化一个函数"><a href="#Bind-方法允许我们柯里化一个函数" class="headerlink" title="Bind 方法允许我们柯里化一个函数"></a>Bind 方法允许我们柯里化一个函数</h2><blockquote>
<p>柯里化的概念很简单, 只传递给函数一部分参数来调用它, 让它返回一个函数去处理剩下的参数. 你可以一次性地调用 curry 函数, 也可以每次只传一个参数分多次调用, 以下为一个简单的示例. - <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html" target="_blank" rel="external">JS 函数是编程指南 第 4 章: 柯里化（curry）</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</div><div class="line"></div><div class="line">increment(<span class="number">2</span>);</div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">addTen(<span class="number">2</span>);</div><div class="line"><span class="comment">// 12</span></div></pre></td></tr></table></figure>
<p>现在, 我们使用 bind() 方法来实现函数的柯里化. 我们首先定义一个接收三个参数的 greet() 函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">gender, age, name</span>) </span>&#123;</div><div class="line">    <span class="comment">// if a male, use Mr., else use Ms.​</span></div><div class="line">    <span class="keyword">var</span> salutation = gender === <span class="string">"male"</span> ? <span class="string">"Mr. "</span> : <span class="string">"Ms. "</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (age &gt; <span class="number">25</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + salutation + name + <span class="string">"."</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hey, "</span> + name + <span class="string">"."</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们使用 bind() 方法柯里化 greet() 方法. bind() 接收的第一个参数指定了 this 的值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 在 greet 函数中我们可以传递 null, 因为函数中并未使用到 this 关键字</span></div><div class="line"><span class="keyword">var</span> greetAnAdultMale = greet.bind (<span class="literal">null</span>, <span class="string">"male"</span>, <span class="number">45</span>);</div><div class="line">​</div><div class="line">greetAnAdultMale(<span class="string">"John Hartlove"</span>); <span class="comment">// "Hello, Mr. John Hartlove."​</span></div><div class="line">​</div><div class="line"><span class="keyword">var</span> greetAYoungster = greet.bind(<span class="literal">null</span>, <span class="string">""</span>, <span class="number">16</span>);</div><div class="line">greetAYoungster(<span class="string">"Alex"</span>); <span class="comment">// "Hey, Alex."​</span></div><div class="line">greetAYoungster(<span class="string">"Emma Waterloo"</span>); <span class="comment">// "Hey, Emma Waterloo."​</span></div></pre></td></tr></table></figure>
<p>当我们用 bind() 实现柯里化时, greet() 函数参数中除了最后一个参数都被预定义好了, 所以当我们调用柯里化后的新函数时只需要指定最后一位参数.</p>
<p>所以小结一下, bind() 方法允许我们明确指定对象方法中的 this 指向, 我们可以借用, 复制一个方法或者将方法赋值为一个可作为函数执行的变量. 我们以可以借用 bind 实现函数柯里化.</p>
<h2 id="JavaScript-中的-Apply-和-Call-方法"><a href="#JavaScript-中的-Apply-和-Call-方法" class="headerlink" title="JavaScript 中的 Apply 和 Call 方法"></a>JavaScript 中的 Apply 和 Call 方法</h2><p>作为 JavaScript 中最常用的两个函数方法, apply 和 call 允许我们借用函数以及在函数调用中指定 this 指向. 除此外, apply 函数允许我们在执行函数时传入一个参数数组, 以此使函数在执行可变参数的函数时可以将每个参数单独的传入函数并得到处理.</p>
<h2 id="使用-apply-或者-call-设置-this"><a href="#使用-apply-或者-call-设置-this" class="headerlink" title="使用 apply 或者 call 设置 this"></a>使用 apply 或者 call 设置 this</h2><p>当我们使用 apply 或者 call 时, 传入的第一个参数为目标函数中 this 指向的对象, 以下为一个简单的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量​</span></div><div class="line"><span class="keyword">var</span> avgScore = <span class="string">"global avgScore"</span>;</div><div class="line">​</div><div class="line"><span class="comment">// 全局函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">avg</span>(<span class="params">arrayOfScores</span>) </span>&#123;</div><div class="line">    <span class="comment">// 分数相加并返回结果</span></div><div class="line">    <span class="keyword">var</span> sumOfScores = arrayOfScores.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> prev + cur;</div><div class="line">    &#125;);</div><div class="line">​</div><div class="line">    <span class="comment">// 这里的 "this" 会被绑定到全局对象上, 除非使用 Call 或者 Apply 明确指定 this 的指向</span></div><div class="line">    <span class="keyword">this</span>.avgScore = sumOfScores / arrayOfScores.length;</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="keyword">var</span> gameController = &#123;</div><div class="line">    <span class="attr">scores</span>  :[<span class="number">20</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">77</span>],</div><div class="line">    <span class="attr">avgScore</span>:<span class="literal">null</span>​</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 调用 avg 函数, this 指向 window 对象​</span></div><div class="line">avg(gameController.scores);</div><div class="line"><span class="comment">// 证明 avgScore 已经被设置为 window 对象的属性​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.avgScore); <span class="comment">// 46.4​</span></div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// null​</span></div><div class="line">​</div><div class="line"><span class="comment">// 重置全局变量</span></div><div class="line">avgScore = <span class="string">"global avgScore"</span>;</div><div class="line">​</div><div class="line"><span class="comment">// 使用 call() 方法明确将 "this" 绑定到 gameController 对象​</span></div><div class="line">avg.call(gameController, gameController.scores);</div><div class="line">​</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.avgScore); <span class="comment">// 全局变量 avgScore 的值​</span></div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// 46.4</span></div></pre></td></tr></table></figure>
<p>以上例子中 call() 中的第一个参数明确了 this 的指向, 第二参数被传递给了 avg() 函数.</p>
<p>apply 和 call 的用法几乎相同, 唯一的差别在于当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量.</p>
<h3 id="在灰调函数中用-call-或者-apply-设置-this"><a href="#在灰调函数中用-call-或者-apply-设置-this" class="headerlink" title="在灰调函数中用 call 或者 apply 设置 this"></a>在灰调函数中用 call 或者 apply 设置 this</h3><p>以下为一个例子, 这种做法允许我们在执行 callback 函数时能够明确 其内部的 this 指向</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个方法</span></div><div class="line"><span class="keyword">var</span> clientData = &#123;</div><div class="line">    <span class="attr">id</span>: <span class="number">094545</span>,</div><div class="line">    <span class="attr">fullName</span>: <span class="string">"Not Set"</span>,</div><div class="line">    <span class="comment">// clientData 对象中的一个方法</span></div><div class="line">    setUserName: <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>)  </span>&#123;</div><div class="line">        <span class="keyword">this</span>.fullName = firstName + <span class="string">" "</span> + lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInput</span>(<span class="params">firstName, lastName, callback, callbackObj</span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用 apply 方法将 "this" 绑定到 callbackObj 对象</span></div><div class="line">    callback.apply(callbackObj, [firstName, lastName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下样例中传递给 callback 函数<br>中的参数将会在 clientData 对象中被设置/更新.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getUserInput(<span class="string">"Barack"</span>, <span class="string">"Obama"</span>, clientData.setUserName, clientData);</div><div class="line"><span class="built_in">console</span>.log(clientData.fullName); <span class="comment">// Barack Obama​</span></div></pre></td></tr></table></figure>
<h2 id="使用-Apply-或者-Call-借用函数-必备知识"><a href="#使用-Apply-或者-Call-借用函数-必备知识" class="headerlink" title="使用 Apply 或者 Call 借用函数(必备知识)"></a>使用 Apply 或者 Call 借用函数(必备知识)</h2><p>相比 bind 方法, 我们使用 apply 或者 call 方法实现函数借用能够有很大的施展空间. 接下来我们考虑从 Array 中借用方法的问题, 让我们定义一个<strong>类数组对象(array-like object)</strong>然后从数组中借用方法来处理我们定义的这个对象, 不过在这之前请记住我们要操作的是一个对象, 而不是数组;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// An array-like object: note the non-negative integers used as keys​</span></div><div class="line"><span class="keyword">var</span> anArrayLikeObj = &#123;<span class="number">0</span>:<span class="string">"Martin"</span>, <span class="number">1</span>:<span class="number">78</span>, <span class="number">2</span>:<span class="number">67</span>, <span class="number">3</span>:[<span class="string">"Letta"</span>, <span class="string">"Marieta"</span>, <span class="string">"Pauline"</span>], <span class="attr">length</span>:<span class="number">4</span> &#125;;</div></pre></td></tr></table></figure>
<p>接下来我们可以这样使用数组的原生方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Make a quick copy and save the results in a real array:​</span></div><div class="line"><span class="comment">// First parameter sets the "this" value​</span></div><div class="line"><span class="keyword">var</span> newArray = <span class="built_in">Array</span>.prototype.slice.call(anArrayLikeObj, <span class="number">0</span>);</div><div class="line">​</div><div class="line"><span class="built_in">console</span>.log(newArray); <span class="comment">// ["Martin", 78, 67, Array[3]]​</span></div><div class="line">​</div><div class="line"><span class="comment">// Search for "Martin" in the array-like object​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.indexOf.call(anArrayLikeObj, <span class="string">"Martin"</span>) === <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>); <span class="comment">// true​</span></div><div class="line">​</div><div class="line"><span class="comment">// Try using an Array method without the call () or apply ()​</span></div><div class="line"><span class="built_in">console</span>.log(anArrayLikeObj.indexOf(<span class="string">"Martin"</span>) === <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>); <span class="comment">// Error: Object has no method 'indexOf'​</span></div><div class="line">​</div><div class="line"><span class="comment">// Reverse the object:​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.reverse.call(anArrayLikeObj));</div><div class="line"><span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, 3: "Martin", length: 4&#125;​</span></div><div class="line">​</div><div class="line"><span class="comment">// Sweet. We can pop too:​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.pop.call(anArrayLikeObj));</div><div class="line"><span class="built_in">console</span>.log(anArrayLikeObj); <span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, length: 3&#125;​</span></div><div class="line">​</div><div class="line"><span class="comment">// What about push?​</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.push.call(anArrayLikeObj, <span class="string">"Jackie"</span>));</div><div class="line"><span class="built_in">console</span>.log(anArrayLikeObj); <span class="comment">// &#123;0: Array[3], 1: 67, 2: 78, 3: "Jackie", length: 4&#125;​</span></div></pre></td></tr></table></figure>
<p>这样的操作使得我们定义的对象既保留有所有对象的属性, 同时也能够在对象上使用数组方法.</p>
<p><strong>arguments</strong> 对象是所有 JavaScript 函数中的一个类数组对象, 因此 call() 和 apply() 的一个最常用的用法是从 arguments 中提取参数并将其传递给一个函数.</p>
<p>以下为 Ember.js 源码中的一部分, 加上了我的一些注释:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">transitionTo</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">// 因为 arguments 是一个类数组对象, 所以我们可以使用 slice()来处理它</span></div><div class="line">    <span class="comment">// 参数 "1" 表示我们返回一个从下标为1到结尾元素的数组</span></div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">​</div><div class="line">    <span class="comment">// 添加该行代码用于查看 args 的值</span></div><div class="line">    <span class="built_in">console</span>.log(args);</div><div class="line">​</div><div class="line">    <span class="comment">// 注释本例不需要使用到的代码</span></div><div class="line">    <span class="comment">//doTransition(this, name, this.updateURL, args);​</span></div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// 使用案例</span></div><div class="line">transitionTo(<span class="string">"contact"</span>, <span class="string">"Today"</span>, <span class="string">"20"</span>); <span class="comment">// ["Today", "20"]​</span></div></pre></td></tr></table></figure>
<p>以上例子中, args 变量是一个真正的数组. 从以上案例中我们可以写一个得到快速得到传递给函数的所有参数(以数组形式)的函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="built_in">console</span>.log(args);</div><div class="line">&#125;</div><div class="line">​</div><div class="line">doSomething(<span class="string">"Water"</span>, <span class="string">"Salt"</span>, <span class="string">"Glue"</span>); <span class="comment">// ["Water", "Salt", "Glue"]​</span></div></pre></td></tr></table></figure>
<p>考虑到字符串是不可变的, 如果使用 apply 或者 call 方法借用字符串的方法, 不可变的数组操作对他们来说才是有效的, 所以你不能使用类似 reverse 或者 pop 等等这类的方法. 除此外, 我们也可以用他们借用我们自定义的方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gameController = &#123;</div><div class="line">    <span class="attr">scores</span>  :[<span class="number">20</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">77</span>],</div><div class="line">    <span class="attr">avgScore</span>:<span class="literal">null</span>,</div><div class="line">    <span class="attr">players</span> :[</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Tommy"</span>, <span class="attr">playerID</span>:<span class="number">987</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"Pau"</span>, <span class="attr">playerID</span>:<span class="number">87</span>, <span class="attr">age</span>:<span class="number">33</span>&#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="keyword">var</span> appController = &#123;</div><div class="line">    <span class="attr">scores</span>  :[<span class="number">900</span>, <span class="number">845</span>, <span class="number">809</span>, <span class="number">950</span>],</div><div class="line">    <span class="attr">avgScore</span>:<span class="literal">null</span>,</div><div class="line">    <span class="attr">avg</span>     :<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> sumOfScores = <span class="keyword">this</span>.scores.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> prev + cur;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">this</span>.avgScore = sumOfScores / <span class="keyword">this</span>.scores.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">​</div><div class="line"><span class="comment">// Note that we are using the apply() method, so the 2nd argument has to be an array​</span></div><div class="line">appController.avg.apply(gameController);</div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// 46.4​</span></div><div class="line">​</div><div class="line"><span class="comment">// appController.avgScore is still null; it was not updated, only gameController.avgScore was updated​</span></div><div class="line"><span class="built_in">console</span>.log(appController.avgScore); <span class="comment">// null​</span></div></pre></td></tr></table></figure>
<p>这个例子非常简单, 我们定义的 gameController 对象借用了 appController 对象的 avg() 方法. 你也许会想, 如果我们借用的函数定义发生了变化, 那么我们的代码会发生什么变化. 借用(复制后)的函数也会变化么, 还是说他在完整复制后已经和原始的方法切断了联系? 让我们用下面这个小例子来说明这个问题:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">appController.maxNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.avgScore = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, <span class="keyword">this</span>.scores);</div><div class="line">&#125;</div><div class="line">​</div><div class="line">appController.maxNum.apply(gameController, gameController.scores);</div><div class="line"><span class="built_in">console</span>.log(gameController.avgScore); <span class="comment">// 77​</span></div></pre></td></tr></table></figure>
<p>正如我们所期望的那样, 如果我们修改原始的方法, 这样的变化会在借用实例的方法上体现出来. 我们总是希望如此, 因为我们从来不希望完整的复制一个方法, 我们只是想简单的借用一下.</p>
<h2 id="使用-apply-执行参数可变的函数"><a href="#使用-apply-执行参数可变的函数" class="headerlink" title="使用 apply() 执行参数可变的函数"></a>使用 apply() 执行参数可变的函数</h2><p>关于 Apply, Call 和 Bind 方法的多功能性和实用性, 我们将讨论一下Apply方法的一个很简单的功能: 使用参数数组执行函数.</p>
<p>Math.max() 方法是 JavaScript 中一个常见的参数可变函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">23</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">56</span>)); <span class="comment">// 56</span></div></pre></td></tr></table></figure>
<p>但如果我们有一个数组要传递给 Math.max(), 是不能这样做的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allNumbers = [<span class="number">23</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">56</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(allNumbers)); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<p>使用 apply 我们可以像下面这样传递数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allNumbers = [<span class="number">23</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">56</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, allNumbers)); <span class="comment">// 56</span></div></pre></td></tr></table></figure>
<p>正如之前讨论, apply() 的第一个参数用于设置 this 的指向, 但是 Math.max() 并未使用到 this, 所以我们传递 null 给他.</p>
<p>为了更进一步解释 apply() 在 参数可变函数上的能力, 我们自定义了一个参数可变函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> students = [<span class="string">"Peter Alexander"</span>, <span class="string">"Michael Woodruff"</span>, <span class="string">"Judy Archer"</span>, <span class="string">"Malcolm Khan"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 不定义参数, 因为我们可以传递任意多个参数进入该函数​</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">welcomeStudents</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">​</div><div class="line">    <span class="keyword">var</span> lastItem = args.pop();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Welcome "</span> + args.join (<span class="string">", "</span>) + <span class="string">", and "</span> + lastItem + <span class="string">"."</span>);</div><div class="line">&#125;</div><div class="line">​</div><div class="line">welcomeStudents.apply(<span class="literal">null</span>, students);</div><div class="line"><span class="comment">// Welcome Peter Alexander, Michael Woodruff, Judy Archer, and Malcolm Khan.</span></div></pre></td></tr></table></figure>
<h2 id="区别与注意事项"><a href="#区别与注意事项" class="headerlink" title="区别与注意事项"></a>区别与注意事项</h2><p>三个函数存在的区别, 用一句话来说的话就是: bind是返回对应函数, 便于稍后调用; apply, call则是立即调用. 除此外, 在 ES6 的箭头函数下, call 和 apply 的失效, 对于箭头函数来说:</p>
<ul>
<li>函数体内的 this 对象, 就是定义时所在的对象, 而不是使用时所在的对象;</li>
<li>不可以当作构造函数, 也就是说不可以使用 new 命令, 否则会抛出一个错误;</li>
<li>不可以使用 arguments 对象, 该对象在函数体内不存在. 如果要用, 可以用 Rest 参数代替;</li>
<li>不可以使用 yield 命令, 因此箭头函数不能用作 Generator 函数;</li>
</ul>
<p>更多关于箭头函数的介绍在这里就不做过多介绍了, 详情可以查看 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">Arrow functions</a>.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的叙述, Call, Apply 和 Bind 在设置 this 指向, 声称与执行参数可变函数以及函数借用方面的强大之处已经非常明显. 作为一名 JavaScript 开发者, 你一定会经常见到这种用法, 或者在开发中尝试使用他. 请确保你已经很好的了解了如上所述的概念与用法.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/06/JavaScript面向对象系列：三、理解对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/06/JavaScript面向对象系列：三、理解对象/" itemprop="url">
                  JavaScript面向对象系列：三、理解对象构造函数和原型对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-06T00:00:00+08:00">
                2017-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。"><a href="#js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。" class="headerlink" title="js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。"></a>js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。</h2><h2 id="当一个属性第一次被添加给对象时，js在对象上调用一个名为-Put-的内部方法。-Put-方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用-Put-的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。"><a href="#当一个属性第一次被添加给对象时，js在对象上调用一个名为-Put-的内部方法。-Put-方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用-Put-的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。" class="headerlink" title="当一个属性第一次被添加给对象时，js在对象上调用一个名为 [[Put]] 的内部方法。 [[Put]] 方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用 [[Put]] 的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。"></a>当一个属性第一次被添加给对象时，js在对象上调用一个名为 <strong><em>[[Put]]</em></strong> 的内部方法。 <strong><em>[[Put]]</em></strong> 方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用 <strong><em>[[Put]]</em></strong> 的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。</h2><h2 id="当一个已有的属性被赋予一个新值的时候，调用一个名为-Set-的方法。该方法将属性的当前方法替换为新值。"><a href="#当一个已有的属性被赋予一个新值的时候，调用一个名为-Set-的方法。该方法将属性的当前方法替换为新值。" class="headerlink" title="当一个已有的属性被赋予一个新值的时候，调用一个名为 [[Set]] 的方法。该方法将属性的当前方法替换为新值。"></a>当一个已有的属性被赋予一个新值的时候，调用一个名为 <strong><em>[[Set]]</em></strong> 的方法。该方法将属性的当前方法替换为新值。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span> <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">&#125;;</div><div class="line">person.age = <span class="number">25</span>; <span class="comment">//调用 [[Put]] 方法</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>; <span class="comment">//调用 [[Set]] 方法</span></div></pre></td></tr></table></figure>
<h2 id="属性探测"><a href="#属性探测" class="headerlink" title="属性探测"></a>属性探测</h2><p>不要使用一下模式探测属性是否存在<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(person.age)&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为当person.age 为一个对象、非空字符串、非零数字、true时，会判断为真。当person为 null、undefined、0、false、NaN或空字符串会判断为假。</p>
<p>更可靠的属性探测方式是使用 <strong><em>in</em></strong> 操作符。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sex"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>使用 <strong><em>in</em></strong> 操作符，在大多数情况下是属性探测的最好的办法。它还有一个额外的好处是不会评估属性的值。当此类评估会导致性能问题或者错误时，这一点很重要。</p>
<h2 id="在某些情况下，希望检查一个属性是不是自有属性。"><a href="#在某些情况下，希望检查一个属性是不是自有属性。" class="headerlink" title="在某些情况下，希望检查一个属性是不是自有属性。"></a>在某些情况下，希望检查一个属性是不是自有属性。</h2><p><strong><em>in</em></strong> 操作符会检查自有属性和原型属性，所以不能检查出正确结果。</p>
<p>另一个方法是 hasOwnProperty方法，这个方法只有在属性存在并且是自有属性时才返回true。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span> <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">"toString"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>##删除对象属性</p>
<p>使用 <strong><em>delete</em></strong> 操作符可以将属性从一个对象中删除。将对象的一个属性设置为null并不能将属性从对象中彻底删除，这种做法只会将原值替换为null。</p>
<p>使用 <strong><em>delete</em></strong> 操作符会调用对象内部名为 <strong><em>[[Delete]]</em></strong> 的内部方法。相当于从哈希表中移除了一个键值对。</p>
<h2 id="属性枚举"><a href="#属性枚举" class="headerlink" title="属性枚举"></a>属性枚举</h2><p>对象内部属性 <strong><em>[[Enumerable]]</em></strong> 设置为true，则属性可以循环遍历。可以使用 <strong><em>for-in</em></strong> 操作符来遍历一个对象。es5中新增 <strong><em>Object.keys()</em></strong> 来遍历对象的键，返回一个键组成的数组。</p>
<p>这两种操作符循环遍历有区别， <strong><em>for-in</em></strong> 操作符会遍历自有属性和原型属性，<strong><em>Object.keys()</em></strong> 只会遍历自由属性。</p>
<p>并不是所有属性都是可枚举的，实际上，对象大部分原生方法的 <strong><em>[[Enumerable]]</em></strong> 设置为false,可以使用 <strong><em>propertyIsEnumerable()</em></strong> 方法来检查一个属性是否为可枚举，每个对象都有这个方法。</p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p><strong><em>get</em></strong> 和 <strong><em>set</em></strong> 属性时访问器属性，可以定义属性被读取或者写入时候的行为。这两个属性可以只设置其中一个，如果只设置 <strong><em>get</em></strong> 这个属性变为只读，如果只设置 <strong><em>set</em></strong> 这个属性变为只写，这两种情况在严格模式下会报错.</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>, <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">    set name(value)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>);</div><div class="line">        <span class="keyword">this</span>.name = value;</div><div class="line">    &#125;,</div><div class="line">    get name()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person.name; <span class="comment">//get</span></div><div class="line">person.name = <span class="string">'xiaowang'</span>; <span class="comment">//set</span></div></pre></td></tr></table></figure>
<p>##通用特征</p>
<p>有两个属性是数据和访问器都具有的。一个是 <strong><em>[[Enumerable]]</em></strong> ，决定了你是否可以遍历该属性。另一个是<br><strong><em>[[Configurable]]</em></strong> ,决定了该属性是否可配置.可以随时删除或改变一个可配置属性。改变属性特征，可以使用 <strong><em>Object.defineProperty()</em></strong> 方法。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.propertyIsEnumerable(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> propertites = <span class="built_in">Object</span>.keys(person);</div><div class="line"><span class="built_in">console</span>.log(propertites.length); <span class="comment">//0</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></div><div class="line">&#125;);  <span class="comment">//报错</span></div></pre></td></tr></table></figure>
<p>一个属性被设置为不可配置了，就不能再修改了。<strong>无法将一个不可配置属性变成可配置属性</strong> 。删除一个不可配置属性，非严格模式下会失败，严格模式下会报错。</p>
<h2 id="数据属性特征"><a href="#数据属性特征" class="headerlink" title="数据属性特征"></a>数据属性特征</h2><p>数据属性拥有两个访问器属性不具备的特征：</p>
<p>第一个是 <strong><em>[[Value]]</em></strong> ,包含属性的值，在对象上创建属性时该特征被自动赋值。所有的属性的值都保存在 <strong><em>[[Value]]</em></strong> 中，即使值是一个函数。</p>
<p>第二个是 <strong><em>[[Writable]]</em></strong> ,该特种是一个布尔值，只是该属性是否可以写入，所有的属性默认是可写的。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">value</span>:<span class="string">"laowang"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.propertyIsEnumerable(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div></pre></td></tr></table></figure>
<p>使用 <strong><em>Object.defineProperty()</em></strong> 定义新的属性时，一定要为所有特征指定一个值，否则布尔值类型的特征会被默认设置为false。上面这个name就是不可枚举，不可配置，不可写。</p>
<h2 id="定义多重属性"><a href="#定义多重属性" class="headerlink" title="定义多重属性"></a>定义多重属性</h2><p>使用 <strong><em>Object.defineProperty()</em></strong> 可以定义一个属性的特征。使用 <strong><em>Object.defineProperties()</em></strong> 可以定义多个属性的特征。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperties(person,&#123;</div><div class="line">    <span class="attr">name</span>:&#123;</div><div class="line">        <span class="attr">value</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">age</span>:&#123;</div><div class="line">        <span class="attr">value</span>:<span class="number">25</span>,</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">false</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="获取属性特征"><a href="#获取属性特征" class="headerlink" title="获取属性特征"></a>获取属性特征</h2><p>使用 <strong><em>Object.getOwnPropertyDescriptor()</em></strong> 可以获取一个属性的所有特征</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.writable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">//laowang</span></div></pre></td></tr></table></figure>
<h2 id="对象禁止扩展"><a href="#对象禁止扩展" class="headerlink" title="对象禁止扩展"></a>对象禁止扩展</h2><p>对象也有内部特征，禁止扩展方法是 <strong><em>Object.preventExtensions()</em></strong> 。可以用 <strong><em>Object.isExtensible()</em></strong> 来检查对象的 <strong><em>[[Extensible]]</em></strong> 的值。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h2 id="对象封印"><a href="#对象封印" class="headerlink" title="对象封印"></a>对象封印</h2><p>对象封印时创建不可扩展对象的第二种方法。对象被封印后是不可扩展的并且所有属性都不可配置。不仅不能给对象添加新属性，也不能删除属性或改变其类型（从数据属性编程访问器属性或者相反）。一个对象被封印，则只能读写它的属性。</p>
<p>使用 <strong><em>Object.seal()</em></strong> 方法来封印一个对象。对象的 <strong><em>[[Extensible]]</em></strong> 被设置为false。 其余所有属性的 <strong><em>[[Configurate]]</em></strong> 特征被设置为false。可以使用 <strong><em>Object.isSealed()</em></strong>  来判断一个对象是否被封印。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.seal(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//xiaowang</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//xiaowang</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="对象冻结"><a href="#对象冻结" class="headerlink" title="对象冻结"></a>对象冻结</h2><p>创建不可扩展对象的最后一种方法是冻结对象。如果一个对象被冻结，则不能在对象上添加或者删除属性，不能改变属性类型，也不能写入任何数据属性。被冻结对象是一个数据属性都为只读的封印对象。被冻结的对象无法解冻。使用 <strong><em>Object.freeze()</em></strong> 来冻结一个对象，使用 <strong><em>Object.isFrozen()</em></strong> 来判断一个对象是否被冻结。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.writable); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>属性有两种类型：数据属性、访问器属性。数据属性可以保存值，访问器属性不保存值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/05/24/JavaScript面向对象系列：二、函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/24/JavaScript面向对象系列：二、函数/" itemprop="url">
                  JavaScript面向对象系列：二、函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T00:00:00+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为-Call-的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。"><a href="#在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为-Call-的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。" class="headerlink" title="在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 [[Call]] 的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。"></a>在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 <strong><em>[[Call]]</em></strong> 的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。</h2><h2 id="Call-属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有-Call-属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含-Call-属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof-不会再将正则表达式鉴别为函数了"><a href="#Call-属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有-Call-属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含-Call-属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof-不会再将正则表达式鉴别为函数了" class="headerlink" title="[[Call]] 属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有 [[Call]] 属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含 [[Call]] 属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof 不会再将正则表达式鉴别为函数了."></a><strong><em>[[Call]]</em></strong> 属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有 <strong><em>[[Call]]</em></strong> 属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含 <strong><em>[[Call]]</em></strong> 属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof 不会再将正则表达式鉴别为函数了.</h2><h2 id="声明还是表达式"><a href="#声明还是表达式" class="headerlink" title="声明还是表达式"></a>声明还是表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数具有两种字面形式</div></pre></td></tr></table></figure>
<p>第一种：函数声明<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种：函数表达式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两种看起来相似，实际上有一个非常重要的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数名声形式的会被提升至上下文（context）顶部，而函数表达式不会</div></pre></td></tr></table></figure></p>
<p>所以就会有下面的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种实际上是能正确运行的，这是因为函数声明被提升至上下文顶部，好像被写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>但是下面这种就会报错<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为函数表达式不会被提升，所以上面执行时找不到函数。<br>不过，只要你始终在使用函数前定义他们，你就可以随意使用者两种字面形式.</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>js的函数另一个独特之处在于你可以给函数传递任意数量的参数却不造成错误。因为函数参数实际被保存在arguments的类数组对象中。</p>
<p>函数的命名参数只不过是为了方便使用，并不是真正的限制了该函数可接受参数的个数。</p>
<p>函数的命名参数都是函数的期望参数，函数的length属性只会显示出期望参数的个数。</p>
<p>例如</p>
<p>情况一<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflect</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>)); <span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>),<span class="number">25</span>); <span class="comment">//"1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect.length); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>情况二<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflect</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>)); <span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>),<span class="number">25</span>); <span class="comment">//"1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect.length); <span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>大多数面向对象语言支持函数重载，它能让一个函数具有多个 <strong><em>函数签名（函数签名由函数的名字，参数的个数以及其类型组成）</em></strong> ,因为js可以接受任意数量的参数且没有类型限制，所以js没有函数重载。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Default message"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayMessage(<span class="string">"Hello"</span>); <span class="comment">//"Default message"</span></div></pre></td></tr></table></figure></p>
<p>这里为什么是 “Default message”,可以用对象来帮助理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sayMessage = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"message"</span>,<span class="string">"console.log(message);"</span>);</div><div class="line">sayMessage = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"message"</span>,<span class="string">"console.log(\"Default message\");"</span>);</div><div class="line">sayMessage(<span class="string">"Hello!"</span>); <span class="comment">//Default message</span></div></pre></td></tr></table></figure></p>
<p>但是js可以模仿函数重载</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</div><div class="line">        message = <span class="string">"Default message"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line">sayMessage(<span class="string">"Hello!"</span>); <span class="comment">//Hello!</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js函数的独特之处在于它们同时也是对象，也就是说它们可以被访问、复制、覆盖，就像其他对象一样。js中的函数和其他对象最大区别在于函数对象有一个特殊的内部属性 <strong><em>[[Call]]</em></strong>,包含了该函数的执行指令。typeof 操作符会在对象内部查找这个内部属性，如果找到，就返回 “function”</p>
<p>函数字面形式有两种：声明和表达式。函数声明会被提升至上下文顶部，而函数表达式不会。但是函数表达式可以用于任何可以使用值的地方，例如赋值语句、函数参数或者另一个函数的返回值。</p>
<p>函数是对象，所以存在一个构造函数 Function。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="赖宝" />
          <p class="site-author-name" itemprop="name">赖宝</p>
           
              <p class="site-description motion-element" itemprop="description">努力学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖宝</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
