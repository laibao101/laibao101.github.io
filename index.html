<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="努力学习">
<meta property="og:type" content="website">
<meta property="og:title" content="赖宝的宝">
<meta property="og:url" content="http://blog.webtoatl.cn/index.html">
<meta property="og:site_name" content="赖宝的宝">
<meta property="og:description" content="努力学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赖宝的宝">
<meta name="twitter:description" content="努力学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.webtoatl.cn/"/>





  <title> 赖宝的宝 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖宝的宝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端技能分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/20/2017-07-20-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/20/2017-07-20-01/" itemprop="url">
                  在浏览器地址栏输入url,按下回车后究竟发生了什么?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T00:00:00+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h2><p>当你在浏览器地址栏输入一个URL后回车，将会发生的事情？这是一道经典的面试题，同时也是一道复杂的题目，涉及到很多东西，不同的软件开发者对于此道问题有不同的答案，对于其中的某一点也能无限深究，今天我们就来侧重于web前端来看一下究竟发生了什么。</p>
<h2 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h2><h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>①查询ip地址</p>
<p>②建立tcp连接，接入服务器</p>
<p>③浏览器发起http请求</p>
<p>④服务器后台操作并做出响应</p>
<p>⑤网页的解析与渲染</p>
<h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h2><h3 id="查询ip地址"><a href="#查询ip地址" class="headerlink" title="查询ip地址"></a>查询ip地址</h3><p>①浏览器解析出url中的域名。</p>
<p>②查询浏览器的DNS缓存。</p>
<p>③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。</p>
<p>④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。</p>
<p>⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。</p>
<p>⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。</p>
<h3 id="tcp连接与http连接"><a href="#tcp连接与http连接" class="headerlink" title="tcp连接与http连接"></a>tcp连接与http连接</h3><p>①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服。</p>
<p>②务器的稳定的通道。俗称TCP的三次握手。</p>
<p>③tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。</p>
<p>④http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</p>
<p>⑤服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</p>
<p>⑥文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</p>
<p>⑦经过网络传输，文件被下载到本地客户端，客户端开始加载。</p>
<h3 id="html渲染"><a href="#html渲染" class="headerlink" title="html渲染"></a>html渲染</h3><p>①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。</p>
<p>②遇到css文件，css中的url发起http请求。</p>
<p>③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。</p>
<p>④http连接是无状态连接，客户端与服务器端需要重新发起请求–响应。</p>
<p>在请求css的过程中，解析器继续解析html，然后到了script标签。</p>
<p>⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。</p>
<p>⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。</p>
<p>⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。</p>
<p>⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</p>
<p>⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</p>
<p>⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</p>
<p>⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</p>
<p>⑫DOM树遇到html结束标签，停止解析，进而渲染结束。</p>
<h2 id="4-扩展思考"><a href="#4-扩展思考" class="headerlink" title="4.扩展思考"></a>4.扩展思考</h2><h3 id="有那些网站优化的方法？"><a href="#有那些网站优化的方法？" class="headerlink" title="有那些网站优化的方法？"></a>有那些网站优化的方法？</h3><p>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p>
<p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p>
<p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p>
<p>④提前渲染开始时间：将css链接放在html头部。</p>
<p>⑤减轻解析器的阻塞：将js链接放在body尾部。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/15/2分钟学会数据mock，独立于后端开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/15/2分钟学会数据mock，独立于后端开发/" itemprop="url">
                  2分钟学会数据mock，独立于后端开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-15T12:47:44+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么说两分钟就能学会？ 因为你看完这篇文章只需要两分钟。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>相对于其他同类的框架的实现，mock.js超出了大家的意料。</li>
</ul>
<ol>
<li>基于 数据模板 生成模拟数据。</li>
<li>基于 HTML模板 生成模拟数据。</li>
<li>拦截并模拟 ajax 请求。</li>
</ol>
<ul>
<li>是的，mock.js只做上述的几件事，但做的足够出色。</li>
</ul>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>开发时，后端还没完成数据输出，前端只好写静态模拟数据。</p>
<ul>
<li>数据太长了，将数据写在js文件里，完成后挨个改url。</li>
<li>某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。</li>
<li>想要尽可能还原真实的数据，要么编写更多代码，要么手动修改模拟数据。</li>
<li>特殊的格式，例如IP,随机数，图片，地址，需要去收集。</li>
<li>超烂的破网速…</li>
<li>…</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装太简单，跳过</p>
<h2 id="mockjs基本语法"><a href="#mockjs基本语法" class="headerlink" title="mockjs基本语法"></a>mockjs基本语法</h2><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 属性名   name</span></div><div class="line"><span class="comment">// 生成规则 rule</span></div><div class="line"><span class="comment">// 属性值   value</span></div><div class="line"><span class="string">'name|rule'</span>: value</div><div class="line">注意：</div><div class="line"></div><div class="line">属性名 和 生成规则 之间用竖线 | 分隔。</div><div class="line">生成规则 是可选的。</div><div class="line">生成规则 有 <span class="number">7</span> 种格式：</div><div class="line"><span class="string">'name|min-max'</span>: value</div><div class="line"><span class="string">'name|count'</span>: value</div><div class="line"><span class="string">'name|min-max.dmin-dmax'</span>: value</div><div class="line"><span class="string">'name|min-max.dcount'</span>: value</div><div class="line"><span class="string">'name|count.dmin-dmax'</span>: value</div><div class="line"><span class="string">'name|count.dcount'</span>: value</div><div class="line"><span class="string">'name|+step'</span>: value</div><div class="line">生成规则 的 含义 需要依赖 属性值的类型 才能确定。</div><div class="line">属性值 中可以含有 @占位符。</div><div class="line">属性值 还指定了最终值的初始值和类型。</div></pre></td></tr></table></figure></p>
<h2 id="mockjs-官网"><a href="#mockjs-官网" class="headerlink" title="mockjs 官网"></a>mockjs 官网</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://mockjs.com/</div></pre></td></tr></table></figure>
<h2 id="配置模拟数据"><a href="#配置模拟数据" class="headerlink" title="配置模拟数据"></a>配置模拟数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mock.mock(<span class="string">'http://g.cn'</span>, &#123;</div><div class="line">    <span class="string">'name'</span>     : <span class="string">'@cname'</span>,</div><div class="line">    <span class="string">'age|1-100'</span>: <span class="number">100</span>,</div><div class="line">    <span class="string">'color'</span>    : <span class="string">'@color'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="发送ajax请求-jquery版"><a href="#发送ajax请求-jquery版" class="headerlink" title="发送ajax请求(jquery版)"></a>发送ajax请求(jquery版)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">'http://g.cn'</span>,</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(</div><div class="line">        <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">4</span>)</div><div class="line">    )    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="查看响应的结果"><a href="#查看响应的结果" class="headerlink" title="查看响应的结果"></a>查看响应的结果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 结果1</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"Elizabeth Hall"</span>,</div><div class="line">    <span class="string">"age"</span>: <span class="number">91</span>,</div><div class="line">    <span class="string">"color"</span>: <span class="string">"#0e64ea"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果2</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"Michael Taylor"</span>,</div><div class="line">    <span class="string">"age"</span>: <span class="number">61</span>,</div><div class="line">    <span class="string">"color"</span>: <span class="string">"#081086"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果N ..</span></div></pre></td></tr></table></figure>
<h3 id="数据模板用法"><a href="#数据模板用法" class="headerlink" title="数据模板用法"></a>数据模板用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin/a1'</span>: &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">msg</span>: <span class="string">'成功'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;&#125;,</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'/admin/a2'</span>: &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">msg</span>: <span class="string">'成功'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'@cname'</span>,</div><div class="line">            <span class="attr">address</span>: <span class="string">'@province'</span>,</div><div class="line">            <span class="attr">email</span>: <span class="string">'@email'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin/a2'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'%s'</span>, <span class="string">'这是a2'</span>, data)</div><div class="line">    &#125;);</div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin/a1'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'%s'</span>, <span class="string">'这是a1'</span>, data)</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h2 id="高级用法（根据请求方法来返回数据）"><a href="#高级用法（根据请求方法来返回数据）" class="headerlink" title="高级用法（根据请求方法来返回数据）"></a>高级用法（根据请求方法来返回数据）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (req.type === <span class="string">'GET'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"接到get请求"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.type === <span class="string">'POST'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">'接到post请求'</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'post'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h3 id="高级用法（根据请求参数来返回数据）"><a href="#高级用法（根据请求参数来返回数据）" class="headerlink" title="高级用法（根据请求参数来返回数据）"></a>高级用法（根据请求参数来返回数据）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> param = str2obj(req.body);</div><div class="line">        <span class="keyword">if</span> (param.type === <span class="string">'1'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是1"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.type === <span class="string">'2'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是2"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2obj</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/ig</span>;</div><div class="line">    str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">        obj[b] = c;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'post'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">type</span>: <span class="number">2</span>,</div><div class="line">            <span class="attr">status</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h2 id="高级用法（特殊处理get请求）"><a href="#高级用法（特殊处理get请求）" class="headerlink" title="高级用法（特殊处理get请求）"></a>高级用法（特殊处理get请求）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(req)</div><div class="line">        <span class="keyword">var</span> param = str2obj(req.url);</div><div class="line">        <span class="keyword">if</span> (param.type === <span class="string">'1'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是1"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.type === <span class="string">'2'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是2"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2obj</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/ig</span>;</div><div class="line">    str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">        obj[b] = c;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        <span class="keyword">var</span> url = <span class="keyword">new</span> <span class="built_in">RegExp</span>(key);</div><div class="line">        Mock.mock(url, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'get'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">type</span>: <span class="number">2</span>,</div><div class="line">            <span class="attr">status</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/09/react为什么需要key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/09/react为什么需要key/" itemprop="url">
                  react为什么需要key
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T00:00:00+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多个react组件性能优化"><a href="#多个react组件性能优化" class="headerlink" title="多个react组件性能优化"></a>多个react组件性能优化</h2><h3 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h3><ol>
<li><p>当一个react组件被装载、更新和卸载时，组件的一系列生命周期函数会被调用。不过这些生命周期函数是针对某一个特定的react组件的函数，在一个应用中，从上到下有很多react组件组合起来，它们之间的渲染过程更加复杂。</p>
</li>
<li><p>其中，装载阶段基本上没有什么选择，当一个react组件第一次出现在DOM树中时，无论如何都是要彻底渲染一次的，从这个react组件往下的所有子组件，都要经历一遍react组件的装载生命周期，因为这部分的的工作没有什么可以省略的，所以没有多少性能优化的事情可以做。</p>
</li>
<li><p>至于卸载阶段，只有一个生命周期函数 <strong>componentWillUnmount</strong>，这个函数做的事情知识清理 <strong>componentDidMount</strong> 添加的事件处理监听等收尾工作，做的事情比装载过程要少很多，所以也没什么可以优化的空间。</p>
</li>
<li><p>所以值得关注的过程，就只剩下了更新过程。</p>
</li>
</ol>
<h3 id="1-2-react的调和-reconciliation-过程"><a href="#1-2-react的调和-reconciliation-过程" class="headerlink" title="1.2 react的调和(reconciliation)过程"></a>1.2 react的调和(reconciliation)过程</h3><p>react在更新阶段很巧妙地对比原有的 <strong>Virtual DOM</strong> 和新生成的 <strong>Virtual DOM</strong> ,找出两者的不同之处，根据不同来修改DOM树，这样只需要做做小的必要改动。react在更新这个“找不同”的过程，就叫做(reconciliation)过程。</p>
<h3 id="1-3-react的算法时间复杂度"><a href="#1-3-react的算法时间复杂度" class="headerlink" title="1.3 react的算法时间复杂度"></a>1.3 react的算法时间复杂度</h3><ol>
<li>Facebook推出的react之初打出的旗号之一就是“高性能”，所以react的(reconciliation)过程必须快速。但是，找出两个树形结构的区别，从计算机科学的角度来说，真的不是一件快速的事。</li>
<li>按照计算机科学目前的算法研究结果，对比两个N个节点的树形结构的算法，时间复杂度是 <strong>O(N^3)</strong>,打个比方，假如两个树形结构上各有100节点，那么找出这两个树形结构差别的操作，需要100*100*100次操作，也就是一百万次当量的操作，假如有一千个节点，那么需要相当于1000*1000*1000次操作，这是一亿次的操作当量，这么巨大数量的操作在强调快速反应的网页中是不可想象的，所以react不可能采用这样的算法。</li>
<li>react实际采用的算法需要的时间复杂度是 <strong>O(N)</strong> ，因为对比两个树形怎么着都要对比两个树形上的节点，似乎也不可能有比 <strong>O(N)</strong> 时间复杂度更低的算法。react采用的算法肯定不是最精准的，但是对于react英语的场景来说，绝对是性能和复杂度的最好折衷，让这个算法发挥作用，还需要开发者一点配合。</li>
<li>其实，react的reconciliation算法并不是很复杂，当react要对比两个 <strong>Virtual DOM</strong> 的树形结构的时候，从根节点开始递归往下比对，在树形结构上，每个阶段都可以看做一个这个阶段以下部分子树的根节点。所以其实这个对比算法可以从 <strong>Virtual DOM</strong> 上任何一个节点开始执行。</li>
</ol>
<h3 id="1-4-react检查两个树形结构的根节点的不同处理方式"><a href="#1-4-react检查两个树形结构的根节点的不同处理方式" class="headerlink" title="1.4 react检查两个树形结构的根节点的不同处理方式"></a>1.4 react检查两个树形结构的根节点的不同处理方式</h3><ol>
<li>节点类型不同的情况</li>
</ol>
<p>如果树形结构的根节点类型不相同，那就意味着改动太大了，也不需要去费心考虑是不是原来那个树形的根节点被移动到其他地方去了，直接认为原来那个树形结构会已经没用，可以扔掉，需要重新构建新的DOM树，原有的树形结构上的react组件都会经历“卸载”的生命周期。也就是，对于 <strong>Virtual DOM</strong> 树这是一个“更新”的过程，但是却可能引发这个树形结构上某些组件的“装载”和“卸载”过程。例如，在更新之前，组件的结构是这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;Todos /&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>我们想要更新成这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;</div><div class="line">    &lt;Todos /&gt;</div><div class="line">&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p>那么react会认为要废掉之前的div节点，包括下面的所有的子节点，一切推到重新来，重新构建一个span节点以及其子节点。看似浪费，但是为了避免 <strong>O(N^3)</strong> 的时间复杂度，react必须要选一个更简单更快的算法，也就只能用这种方式。</p>
<p>作为开发者，很显然要避免作为包裹功能的节点类型被随意改变。</p>
<ol>
<li>节点类型相同的情况</li>
</ol>
<p>如果两个树形结构的根节点类型相同，react就会认为原来的根节点只需要更新过程，不会将其卸载，也不会引发根节点的重新装载。这时候要区分一下节点类型。节点可以分为两类：一类是DOM元素类型对应的就是HTML直接支持的元素类型，比如div,span,p。另一类是react组件，也就是利用react库订制的类型。</p>
<p>对于DOM类型，react会保留节点对应的DOM元素，支队树形结构根节点上的树形和内容做一下对比，然后只更新修改的部分。<br>比如原来的jsx表示是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&#123;&#123;color:&quot;red&quot;,fontSize:16&#125;&#125; className=&quot;welcome&quot;&gt;</div><div class="line">    hello</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>改变后jsx表示是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&#123;&#123;color:&quot;green&quot;,fontSize:16&#125;&#125; className=&quot;farewell&quot;&gt;</div><div class="line">    good bye</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这两个的差别就是颜色和className发生了改变，在操作DOM树节点的时候，只修改这些发生变化的部分，让DOM操作尽可能少。</p>
<p>如果树形结构的根节点不是DOM元素类型，react所做的工作类似，只是react不知道如何去更新DOM树，因为这些逻辑还在react组件之中，react能做的只是根据新节点的props去更新原来根节点的组件实例，引发这个组件的实例的更新过程。也就会触发react更新阶段的生命周期函数，这个过程中，如果 <strong>shouldComponentUpdate</strong> 返回false。更新就会停止。</p>
<ol>
<li>多个子组件的情况</li>
</ol>
<p>当一个组件包含多个子组件的情况，react的处理方式也非常简单的直接。例如最初组件形态用jsx表示是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>更新之后，jsx表示是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;third&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>这种情况react的更新过程，只要 <strong>shouldComponentUpdate</strong> 使用恰当，可以避免实质性的更新操作。</p>
<p>但是，在序列前面增加一个 TodoItem实例的时候。需要更新后的形态jsx表示为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;zero&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>这种情况下，react会首先认为把text为first的组件实例的text改为zero，text为second的组件实例的text改为first，最后增加一个一个实例，text为second。这种情况下，<strong>shouldComponentUpdate</strong> 也无法判断是否返回false。想要增加一个组件实例，却引发了另外两个组件的更新。</p>
<p>这种情况，react的key就凸显出作用了。react通过这个key就能判断每一个组件在组件序列中的位置了。</p>
<p>上面的情况变为，最初形态为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem key=&#123;1&#125; text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;2&#125; text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>新增组件的时候,形态为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem key=&#123;0&#125; text=&quot;zero&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;1&#125; text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;2&#125; text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>react就知道把组件插在组件序列的第一位了。对原有的两个组件，只用props来启用更新过程，_shouldComponentUpdate__ 就能根据key来判断是否返回false来中断更新了，避免无用的更新操作了。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>所以，碰到数组-&gt;列表的映射，或是同级元素需要移位的情况，一定要给元素加上key属性！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/03/动手实现一个简单的浏览器端js模块加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/03/动手实现一个简单的浏览器端js模块加载器/" itemprop="url">
                  动手实现一个简单的浏览器端js模块加载器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T00:00:00+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在es6之前，js不像其他语言自带成熟的模块化功能，页面只能靠插入一个个script标签来引入自己的或第三方的脚本，并且容易带来命名冲突的问题。js社区做了很多努力，在当时的运行环境中，实现”模块”的效果。<br>通用的js模块化标准有CommonJS与AMD，前者运用于node环境，后者在浏览器环境中由Require.js等实现。此外还有国内的开源项目Sea.js，遵循CMD规范。（目前随着es6的普及已经停止维护，不论是AMD还是CMD，都将是一段历史了）</p>
<h3 id="浏览器端js加载器"><a href="#浏览器端js加载器" class="headerlink" title="浏览器端js加载器"></a>浏览器端js加载器</h3><p>实现一个简单的js加载器并不复杂，主要可以分为 <strong>解析路径、下载模块、解析模块依赖、解析模块</strong> 四个步骤。<br>首先定义一下模块。在各种规范中，通常一个js文件即表示一个模块。那么，我们可以在模块文件中，构造一个闭包，并传出一个对象，作为模块的导出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(factory() &#123;</div><div class="line">    <span class="keyword">var</span> x = &#123;</div><div class="line">        <span class="attr">a</span>: <span class="number">1</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>define函数接收一个工厂函数参数，浏览器执行该脚本时，define函数执行factory，并把它的return值存储在加载器的模块对象modules里。<br>如何 <strong>标识</strong> 一个模块呢？可以用文件的 <strong>uri</strong>，它是唯一标识，是天然的id。<br>文件路径path有几种形式：</p>
<p>绝对路径：<a href="http://xxx" target="_blank" rel="external">http://xxx</a>, file://xxx</p>
<p>相对路径：./xxx ， ../xxx ， xxx(相对当前页面的文件路径)</p>
<p>虚拟绝对路径：/xxx /表示网站根目录<br>因此，需要一个resolvePath函数来将不同形式的path解析成uri，参照当前页面的文件路径来解析。</p>
<p>接着，假设我们需要引用a.js与b.js两个模块，并设置了需要a与b才能执行的回调函数f。我们希望加载器去拉取a与b，当a与b都加载完成后，从modules里取出a与b作为参数传给f，执行下一步操作。这里可以用观察者模式（即订阅/发布模式）实现，创建一个eventProxy，订阅加载a与加载b事件；define函数执行到最后，已经把导出挂载modules里之后，emit一个本模块加载完成的事件，eventProxy收到后检查a与b是否都加载完成，如果完成，就传参给f执行回调。</p>
<p>同理，eventProxy也可以实现模块依赖加载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define([ <span class="string">'c.js'</span>, <span class="string">'d.js'</span> ], factory (c, d) &#123;</div><div class="line">    <span class="keyword">var</span> x = c + d;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>define函数的第一个参数可以传入一个依赖数组，表示a模块依赖c与d。define执行时，告诉eventProxy订阅c与d加载事件，加载好了就执行回调函数f存储a的导出，并emit事件a已加载。</p>
<p>浏览器端加载脚本的原始方法是插入一个 <strong>script</strong> 标签，指定src之后，浏览器开始下载该脚本。<br>那么加载器中的模块加载可以用dom操作实现，插入一个script标签并指定src，此时该模块为下载中状态。<br>PS：浏览器中，动态插入script标签与初次加载页面dom时的script加载方式不同：</p>
<p>初次加载页面，浏览器会从上到下顺序解析dom，碰到script标签时，下载脚本并阻塞dom解析，等到该脚本下载、执行完毕后再继续解析之后的dom（现代浏览器做了preload优化，会预先下载好多个脚本，但执行顺序与它们在dom中顺序一致，执行时阻塞其他dom解析）</p>
<p>动态插入script，<strong>var a = document.createElement(‘script’); a.src=’xxx’; document.body.appendChild(a)</strong>;浏览器会在该脚本下载完成后执行，过程是异步的。</p>
<p>下载完成后执行上述的操作，解析依赖-&gt;加载依赖-&gt;解析本模块-&gt;加载完成-&gt;执行回调。</p>
<p>模块下载完成后，如何在解析它时知道它的uri呢？有两种发发，一种是用 <strong>srcipt.onload</strong> 获取 <strong>this</strong> 对象的src属性；一种是在define函数中采用 <strong>document.currentScript.src</strong>。</p>
<p>实现基本的功能比较简单，代码不到200行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zmm = &#123;</div><div class="line">    <span class="attr">_modules</span>: &#123;&#125;,</div><div class="line">    <span class="attr">_configs</span>: &#123;</div><div class="line">        <span class="comment">// 用于拼接相对路径</span></div><div class="line">        basePath: (<span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (path.charAt(path.length - <span class="number">1</span>) === <span class="string">'/'</span>) &#123;</div><div class="line">                path = path.substr(<span class="number">0</span>, path.length - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> path.substr(path.indexOf(location.host) + location.host.length + <span class="number">1</span>);</div><div class="line">        &#125;)(location.href),</div><div class="line">        <span class="comment">// 用于拼接相对根路径</span></div><div class="line">        host: location.protocol + <span class="string">'//'</span> + location.host + <span class="string">'/'</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.hasModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断是否已有该模块，不论加载中或已加载好</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._modules.hasOwnProperty(_uri);</div><div class="line">&#125;;</div><div class="line">zmm.isModuleLoaded = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断该模块是否已加载好</span></div><div class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>._modules[_uri];</div><div class="line">&#125;;</div><div class="line">zmm.pushModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">    <span class="comment">// 新模块占坑，但此时还未加载完成，表示加载中；防止重复加载</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._modules.hasOwnProperty(_uri)) &#123;</div><div class="line">        <span class="keyword">this</span>._modules[_uri] = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">zmm.installModule = <span class="function"><span class="keyword">function</span> (<span class="params">_uri, mod</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._modules[_uri] = mod;</div><div class="line">&#125;;</div><div class="line">zmm.load = <span class="function"><span class="keyword">function</span> (<span class="params">uris</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i, nsc;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; uris.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.hasModule(uris[i])) &#123;</div><div class="line">            <span class="keyword">this</span>.pushModule(uris[i]);</div><div class="line">            <span class="comment">// 开始加载</span></div><div class="line">            <span class="keyword">var</span> nsc = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">                nsc.src = uri;</div><div class="line">            <span class="built_in">document</span>.body.appendChild(nsc);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.resolvePath = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="comment">// 返回绝对路径</span></div><div class="line">    <span class="keyword">var</span> res = <span class="string">''</span>, paths = [], resPaths;</div><div class="line">    <span class="keyword">if</span> (path.match(<span class="regexp">/.*:\/\/.*/</span>)) &#123;</div><div class="line">        <span class="comment">// 绝对路径</span></div><div class="line">        res = path.match(<span class="regexp">/.*:\/\/.*?\//</span>)[<span class="number">0</span>]; <span class="comment">// 协议+域名</span></div><div class="line">        path = path.substr(res.length);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.charAt(<span class="number">0</span>) === <span class="string">'/'</span>) &#123;</div><div class="line">        <span class="comment">// 相对根路径 /开头</span></div><div class="line">        res = <span class="keyword">this</span>._configs.host;</div><div class="line">        path = path.substr(<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 相对路径 ./或../开头或直接文件名</span></div><div class="line">        res = <span class="keyword">this</span>._configs.host;</div><div class="line">        resPaths = <span class="keyword">this</span>._configs.basePath.split(<span class="string">'/'</span>);</div><div class="line">    &#125;</div><div class="line">    resPaths = resPaths || [];</div><div class="line">    paths = path.split(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (paths[i] === <span class="string">'..'</span>) &#123;</div><div class="line">            resPaths.pop();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paths[i] === <span class="string">'.'</span>) &#123;</div><div class="line">            <span class="comment">// do nothing</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            resPaths.push(paths[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    res += resPaths.join(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> define = zmm.define = <span class="function"><span class="keyword">function</span> (<span class="params">dependPaths, fac</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _uri = <span class="built_in">document</span>.currentScript.src;</div><div class="line">    <span class="keyword">if</span> (zmm.isModuleLoaded(_uri)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> factory, depPaths, uris = [];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">        factory = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 挂载到模块组中</span></div><div class="line">        zmm.installModule(_uri, factory());</div><div class="line">        <span class="comment">// 告诉proxy该模块已装载好</span></div><div class="line">        zmm.proxy.emit(_uri);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 有依赖的情况</span></div><div class="line">        factory = <span class="built_in">arguments</span>[<span class="number">1</span>];</div><div class="line">        <span class="comment">// 装载完成的回调函数</span></div><div class="line">        zmm.use(<span class="built_in">arguments</span>[<span class="number">0</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            zmm.installModule(_uri, factory.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</div><div class="line">            zmm.proxy.emit(_uri);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.use = <span class="function"><span class="keyword">function</span> (<span class="params">paths, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(paths)) &#123;</div><div class="line">        paths = [paths];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> uris = [], i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</div><div class="line">        uris.push(<span class="keyword">this</span>.resolvePath(paths[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 先注册事件，再加载</span></div><div class="line">    <span class="keyword">this</span>.proxy.watch(uris, callback);</div><div class="line">    <span class="keyword">this</span>.load(uris);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zmm.proxy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> proxy = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> taskId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> taskList = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> execute = <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> uris = task.uris,</div><div class="line">            callback = task.callback;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, arr = []; i &lt; uris.length; i++) &#123;</div><div class="line">            arr.push(zmm._modules[uris[i]]);</div><div class="line">        &#125;</div><div class="line">        callback.apply(<span class="literal">null</span>, arr);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> deal_loaded = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> i, k, task, sum;</div><div class="line">        <span class="comment">// 当一个模块加载完成时，遍历当前任务栈</span></div><div class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> taskList) &#123;</div><div class="line">            <span class="keyword">if</span> (!taskList.hasOwnProperty(k)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            task = taskList[k];</div><div class="line">            <span class="keyword">if</span> (task.uris.indexOf(_uri) &gt; <span class="number">-1</span>) &#123;</div><div class="line">                <span class="comment">// 查看这个任务中的模块是否都已加载好</span></div><div class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; task.uris.length; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (zmm.isModuleLoaded(task.uris[i])) &#123;</div><div class="line">                        sum ++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (sum === task.uris.length) &#123;</div><div class="line">                    <span class="comment">// 都加载完成 删除任务</span></div><div class="line">                    <span class="keyword">delete</span>(taskList[k]);</div><div class="line">                    execute(task);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    proxy.watch = <span class="function"><span class="keyword">function</span> (<span class="params">uris, callback</span>) </span>&#123;</div><div class="line">        <span class="comment">// 先检查一遍是否都加载好了</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; uris.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (zmm.isModuleLoaded(uris[i])) &#123;</div><div class="line">                sum ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sum === uris.length) &#123;</div><div class="line">            execute(&#123;</div><div class="line">                <span class="attr">uris</span>: uris,</div><div class="line">                <span class="attr">callback</span>: callback</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 订阅新加载任务</span></div><div class="line">            <span class="keyword">var</span> task = &#123;</div><div class="line">                <span class="attr">uris</span>: uris,</div><div class="line">                <span class="attr">callback</span>: callback</div><div class="line">            &#125;;</div><div class="line">            taskList[<span class="string">''</span> + taskId] = task;</div><div class="line">            taskId ++;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    proxy.emit = <span class="function"><span class="keyword">function</span> (<span class="params">_uri</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(_uri + <span class="string">' is loaded!'</span>);</div><div class="line">        deal_loaded(_uri);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h2 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h2><p>“循环加载”指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。这是一种应该尽量避免的设计。</p>
<h3 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h3><p>用上面的zmm工具加载模块a:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.html</span></div><div class="line">zmm.use(<span class="string">'/a.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</div><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="string">'/b.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  a = b + <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="string">'/a.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> b;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>就会陷入a等待b加载完成、b等待a加载完成的死锁状态。sea.js碰到这种情况也是死锁，也许是默认这种行为不应该出现。<br>seajs里可以通过require.async来缓解循环依赖的问题，但必须改写a.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="string">'./js/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  <span class="built_in">require</span>.async(<span class="string">'./b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</div><div class="line">      a = b + <span class="number">1</span>;</div><div class="line">      <span class="built_in">module</span>.exports = a; <span class="comment">//a= 3</span></div><div class="line">  &#125;);</div><div class="line">  <span class="built_in">module</span>.exports = a; <span class="comment">// a= 1</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="string">'./js/b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line">  <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">  <span class="built_in">module</span>.exports = b;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// main.html</span></div><div class="line">seajs.use(<span class="string">'./js/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但这么做a就必须先知道b会依赖自己，且use中输出的是b还没加载时a的值，use并不知道a的值之后还会改变。<br>在浏览器端，似乎没有很好的解决方案。node模块加载碰到的循环依赖问题则小得多。</p>
<h3 id="node-CommonJS"><a href="#node-CommonJS" class="headerlink" title="node/CommonJS"></a>node/CommonJS</h3><p>CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。CommonJS的做法是，一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = a;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</div><div class="line">a = b + <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = a;</div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line"><span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = b;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>上面main.js的代码中，先加载模块a，执行require函数，此时内存中已经挂了一个模块a，它的exports为一个空对象a.exports={}；接着执行a.js中的代码；执行var b = require(‘./b’);之前，a.exports=1，接着执行require(b)；b.js被执行时，拿到的是a.exports=1，b加载完成后，执行权回到a.js；最后a模块的输出为3。</p>
<p>CommonJS与浏览器端的加载器有着实现上的差异。node加载的模块都是在本地，执行的是同步的加载过程，即按依赖关系依次加载，执行到加载语句就去加载另一个模块，加载完了再回到函数调用点继续执行；浏览器端加载scripts由于天生限制，只能采取异步加载，执行回调来实现。</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。因此，ES6模块是动态引用，不存在缓存值的问题，而且模块里面的变量，绑定其所在的模块。</p>
<p>这导致ES6处理”循环加载”与CommonJS有本质的不同。ES6根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">'./odd'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123; counter++; <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);&#125;</div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">'./even'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123; <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);&#125;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./even.js'</span>;</div><div class="line">m.even(<span class="number">10</span>); <span class="comment">// true; m.counter = 6</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，even.js里面的函数even有一个参数n，只要不等于0，就会减去1，传入加载的odd()。odd.js也会做类似作。</p>
<p>上面代码中，参数n从10变为0的过程中，foo()一共会执行6次，所以变量counter等于6。第二次调用even（）时，参数n从20变为0，foo()一共会执行11次，加上前面的6次，所以变量counter等于17。</p>
<p>而这个例子要是改写成CommonJS，就根本无法执行，会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">exports.counter = counter;</div><div class="line">exports.even = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">counter++;</div><div class="line"><span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./even'</span>);</div><div class="line">m.even(<span class="number">10</span>); <span class="comment">// TypeError: even is not a function</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成”循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/02/JavaScript面向对象系列：六、对象模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/JavaScript面向对象系列：六、对象模式/" itemprop="url">
                  JavaScript面向对象系列：六、对象模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T00:00:00+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>js有很多创建对象的模式，完成工作的方式也不是只有一种。可以随时定义自己的类型和自己的泛用对象。可以使用继承或者混入等其他技术令对象间行为共享。也可以利用js高级技巧来组织对象结构被改变。</p>
<h2 id="私有成员和特权成员"><a href="#私有成员和特权成员" class="headerlink" title="私有成员和特权成员"></a>私有成员和特权成员</h2><p>js对象对象的所有属性都是公有的，且没有显式的方法指定某个属性不能被外界某个对象访问。然而，有时候可能不希望数据公有。</p>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>模块模式是一种拥有私有数据的单件对象的模式。基本做法就是使用立即调用函数表达式（IIFE）来返回一个对象。IIFE是一种被定义后立即调用并产生结果的函数表达式，该函数表达可以包括任意数量的本地变量，它们在函数外不可见。因为返回的对象被定义在函数内部，对象的方法可以访问这些数据。（IIFE定义的所有对象都可以访问通用的本地变量）以这种方式访问私有数据的方法被称为特权方法。</p>
<p>基本格式如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> yourObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//私有数据</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="comment">//公有方法和属性  </span></div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>IIFE是js中一种很流行的模式，部分原因就是模块模式中的应用。</p>
<p>模块模式允许使用普通变量作为非公有对象属性。通过创建必报函数作为对象方法来操作它们。闭包函数就是一个可以访问其作用域外部数据的普通函数。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">getAge</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">growOlder</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            age++;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<p>模块模式还有一个变种叫暴露模块模式，它将所有的变量和方法都组织在IIFE的顶部，然后将它们设置到需要被返回的对象上。可以使用暴露模块模式改写上面的例子。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">growOlder</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">getAge</span>:getAge,</div><div class="line">        <span class="attr">growOlder</span>:growOlder</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数中的私有成员"><a href="#构造函数中的私有成员" class="headerlink" title="构造函数中的私有成员"></a>构造函数中的私有成员</h2><p>模块模式在定义单个对象的私有属性上十分有效，但是对于那些同样需要私有属性的自定义类型，也可以在构造函数中使用类型的模式来创建每个实例的私有数据。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.growOlder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<p>如果需要所有实例可以共享的私有数据，可以结合模块模式和构造函数。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">InnerPerson</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InnerPerson.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InnerPerson.prototype.growOlder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        age++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> InnerPerson;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//"laowang"</span></div><div class="line"><span class="built_in">console</span>.log(person1.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">//"xiaowang"</span></div><div class="line"><span class="built_in">console</span>.log(person2.getAge()); <span class="comment">//25</span></div><div class="line"></div><div class="line">person1.growOlder();</div><div class="line"><span class="built_in">console</span>.log(person1.getAge()); <span class="comment">//26</span></div><div class="line"><span class="built_in">console</span>.log(person2.getAge()); <span class="comment">//26</span></div></pre></td></tr></table></figure></p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>js中大量使用了伪类继承和原型对象继承，还有另一种伪继承的手段叫混入。一个对象在不改变原型对象链的情况下得到了另一个对象的属性被称为混入。第一个对象（接收者）通过直接复制第二个对象（提供者）的属性从而接收了这些属性。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">receiver,supplier</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> supplier)&#123;</div><div class="line">        <span class="keyword">if</span>(supplier.hasOwnProperty(property))&#123;</div><div class="line">            receiver[property] = supplier[property];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> receiver;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过混入而不是继承给一个对象添加事件支持<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">EventTarget.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:EventTarget,</div><div class="line">    <span class="attr">addListener</span>:<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>) </span>&#123;</div><div class="line">        <span class="comment">//不存在数组就创建一个数组</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(<span class="string">"_listeners"</span>)) &#123;</div><div class="line">            <span class="keyword">this</span>._listeners = [];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._listeners[type] == <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._listeners[type] = [];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>._listeners[type].push(listener);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">fire</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!event.target) &#123;</div><div class="line">            event.target = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!event.type)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Event object missing 'type' propertype."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._listeners &amp;&amp; <span class="keyword">this</span>._listener[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[event.type];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = listeners.length; i &lt; len; i++)&#123;</div><div class="line">                listeners[i].call(<span class="keyword">this</span>,event);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">removeListener</span>:<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._listener &amp;&amp; <span class="keyword">this</span>._listener[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners[type];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = listeners.length; i &lt; len; i++)&#123;</div><div class="line">                <span class="keyword">if</span>(listeners[i] === listener)&#123;</div><div class="line">                    listener.split(i,<span class="number">1</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>js对象中支持事件十分有用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> EventTarget();</div><div class="line">person.name = <span class="string">"laowang"</span>;</div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="keyword">this</span>.fire(&#123;<span class="attr">type</span>:<span class="string">"namsaid"</span>,<span class="attr">name</span>:name&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中，person作为EventTarget的实例被创建出来，然后添加各种跟person相关的属性。可惜的是这意味着person实际上是一个EventTarget而不是一个Object或者其他自定义类型。另外，你还需要承受手工添加一批新属性的开销。解决这个问题的方法是使用伪类继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = <span class="built_in">Object</span>.create(EventTarget.prototype);</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="keyword">this</span>.fire(&#123;</div><div class="line">        <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">        <span class="attr">name</span>:name</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> EventTarget); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>这个例子中，一个新的Person类型继承自EventTarget。随后可以在Person的原型对象上添加你需要的方法。然而不够简洁。</p>
<p>更简洁的例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">minix(Person.prototype,<span class="keyword">new</span> EventTarget());</div><div class="line">minix(Person.prototype,&#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> EventTarget); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>有时候可能需要一个对象的属性，但是不想用伪类继承的构造函数。可以使用混入来创建自己的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = mixin(<span class="keyword">new</span> EventTarget(),&#123;</div><div class="line">    get name()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"laowang"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"xiaowang"</span></div></pre></td></tr></table></figure></p>
<p>这段代码定义了仅有getter的访问器属性name。这意味着对该属性赋值应该不起作用。但是，由于在person对象里面该访问器属性变成了数据属性，你就有可能改写name的值。在调用minix()时，提供者name属性的值被读取后赋值给接受者name属性。在这个过程中没有机会定义一个新的访问器属性，从而使接收者的name属性成为了一个数据属性。</p>
<p>如果想要访问器属性被复制成访问器属性，需要一个不同的minix()函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span> (<span class="params">receiver,supplier</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">property</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(supplier,property);</div><div class="line">        <span class="built_in">Object</span>.defineProperty(receiver,property,descriptor);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> receiver;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = mixin(<span class="keyword">new</span> EventTarget(),&#123;</div><div class="line">    get name()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"laowang"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.fire(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">"namesaid"</span>,</div><div class="line">            <span class="attr">name</span>:name</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laoawng"</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//"laowang"</span></div></pre></td></tr></table></figure></p>
<h2 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h2><p>构造函数也是函数，所以可以不用 new 操作符直接调用它们来改变this的值。在非严格模式下，this被强制指向全局对象，这个做法会导致无法预知的结果。在严格模式下，构造函数会抛出错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">//"undefined"</span></div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">//"laowang"</span></div></pre></td></tr></table></figure></p>
<p>很多內建构造函数，例如 <strong><em>Array</em></strong> 和 <strong><em>RegExp</em></strong> 不需要new也可以工作，这是因为他们被设计成为作用域安全的构造函数。一个作用域安全的构造函数有没有new都可以工作，并返回同样的对象。</p>
<p>一个作用域安全的构造函数如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js有很多不同的方式创建和组装对象。虽然js没有一个正式的私有属性的概念，但是可以创建仅在对象内可以访问的数据或者函数。对于单件对象，你可以使用模块模式对外界隐藏数据。可以使用立即调用表达式定义仅可被创建的对象访问的本地变量和函数。特权方法是可以访问对象私有数据的方法。你还可以创建具有私有属性的构造函数，一种方法是在构造函数定义变量，另一种方法是使用IIFE来创建所有实例共享的私有数据。</p>
<p>混入是一种给对象添加功能，同时便面继承的强有力方式。混入将一个属性从一个对象复制到另一个，从而使得接收者在不需要继承提供者的情况下获得其功能。和继承不同，混入令你在创建对象后无法检查属性来源。因此，混入最适合被用于数据属性或者小函数。如果需要更强大的功能且知道该功能来自哪里，继承仍然是我们推荐的做法。</p>
<p>作用域安全的构造函数是可以不用new都可以被调用来生成新的对象实例的构造函数。这种模式之所以能工作，是因为this在构造函数一开始执行时就已经指向自定义类型的实例，可以根据new的使用与否来决定构造函数的行为。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/20/JavaScript面向对象系列：五、继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/JavaScript面向对象系列：五、继承/" itemprop="url">
                  JavaScript面向对象系列：五、继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T00:00:00+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原型对象链和-Object-prototype"><a href="#原型对象链和-Object-prototype" class="headerlink" title="原型对象链和 Object.prototype"></a>原型对象链和 <strong><em>Object.prototype</em></strong></h2><p> js內建的继承方法被称为原型对象链，又可以称为原型对象继承。原型对象的属性可以经由对象实例访问，这就是继承的一种形式。对象实例继承了原型对象的属性。因为原型对象也是一个对象，他也有自己的原型对象并继承其属性。这就是原型对象链，而原型对象继承它的原型对象，以此类推。</p>
<p> 所有对象，包括哪些你自己定义的对象都自动继承自 <strong><em>Object</em></strong>，除非另有指定。更确切的说，所有对象都继承自 <strong><em>Object.prototype</em></strong>。任何以队形字面量形式定义的对象，其 <strong><em>[[Prototype]]</em></strong> 的值都被设为 <strong><em>Object.prototype</em></strong>,这意味着它继承 <strong><em>Object.prototype</em></strong> 的属性。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(book);</div><div class="line"><span class="built_in">console</span>.log(prototype === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="继承自-Object-peototype-的方法"><a href="#继承自-Object-peototype-的方法" class="headerlink" title="继承自 Object.peototype 的方法"></a>继承自 <strong><em>Object.peototype</em></strong> 的方法</h2><p>前面说到的很多方法其实都是定义在 <strong><em>Object.prototype</em></strong> 上面的。因此可以被其他对象继承。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>hasOwnProperty()</td>
<td>检查是否存在一个给定名字的自有属性</td>
</tr>
<tr>
<td>propertyIsEnumerable()</td>
<td>检查一个自有属性是否可枚举</td>
</tr>
<tr>
<td>isPrototypeof()</td>
<td>检查一个对象是否是另一个对象的原型对象</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回一个对象的值表达</td>
</tr>
<tr>
<td>toString()</td>
<td>返回一个对象的字符串表达</td>
</tr>
</tbody>
</table>
<p><strong><em>valueOf</em></strong>,每当一个操作符被用于一个对象时就会调用 <strong><em>valueOf()</em></strong> 方法。 <strong><em>valueOf()</em></strong> 默认返回对象实例本身。原始封装类型重写了 <strong><em>valueOf()</em></strong> 以使得它对 <strong><em>String</em></strong> 返回一个字符串，对 <strong><em>Boolean</em></strong> 返回一个布尔值，对 <strong><em>Number</em></strong> 返回一个数字。类似的，<strong><em>Date</em></strong> 对象返回一个 <strong><em>epoch</em></strong> 时间。如果你的对象也要这样使用操作符，也可以自定义 <strong><em>valueOf()</em></strong> 方法.定义的时候并没有改变操作符的行为，仅仅定了操作符默认行为所使用的值。</p>
<p><strong><em>toString()</em></strong>,一旦 <strong><em>valueOf()</em></strong> 方法返回的是一个引用而不是原始值的时候，就会回退调用 <strong><em>toString()</em></strong> 方法。另外，当js期望一个字符串时，也会对原始值隐式调用 <strong><em>toString()</em></strong> .例如，当加号操作符的一边是一个字符串时，另一边会被自动转换成字符串。如果另一边是一个原始值，会自动被转换成一个字符串表达（例如，<strong><em>true</em></strong> 转换成 <strong><em>“true”</em></strong>）。如果另一边是一个引用值，则会调用 <strong><em>valueOf()</em></strong>。如果 <strong><em>valueOf()</em></strong> 返回一个引用值，则调用 <strong><em>toString()</em></strong>。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> message = <span class="string">"Book = "</span> + book;</div><div class="line"><span class="built_in">console</span>.log(message); <span class="comment">//"Book = [object Object]"</span></div></pre></td></tr></table></figure>
<p>这段以 “Book =” 和book来构造字符串。因为book是一个对象，此时调用它的 <strong><em>toString()</em></strong> 方法。该方法继承自 <strong><em>Object.prototype</em></strong>,大部分js引擎返回默认值 “[object Object]”。如果对这个值满意，就不需要改变对象的 <strong><em>toString()</em></strong> 方法。定义自己的 <strong><em>toString()</em></strong> 方法有时候可以为此类字符串转换提供更过信息的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span>,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Book "</span> + <span class="keyword">this</span>.title + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> message = <span class="string">"Book = "</span> + book;</div><div class="line"><span class="built_in">console</span>.log(message); <span class="comment">//"Book = [Book javascript]"</span></div></pre></td></tr></table></figure></p>
<h2 id="修改-Object-pototype"><a href="#修改-Object-pototype" class="headerlink" title="修改 Object.pototype"></a>修改 <strong><em>Object.pototype</em></strong></h2><p>所有的对象都默认继承自 <strong><em>Object.prototype</em></strong>，所以改变 <strong><em>Object.prototype</em></strong> 会影响所有的对象，是非常危险的。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(book.add(<span class="number">5</span>)); <span class="comment">//"[object Object]5";</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"title"</span>.add(<span class="string">"end"</span>)); <span class="comment">//"titleend"</span></div><div class="line"></div><div class="line"><span class="comment">//在浏览器中</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.add(<span class="literal">true</span>)); <span class="comment">//"[object HTMLDocument]true"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.add(<span class="number">5</span>)); <span class="comment">//"[object Window]6"</span></div></pre></td></tr></table></figure></p>
<p>上面给 <strong><em>Object.prototype</em></strong> 添加方法可能会带来不可预知的结果</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prpperty <span class="keyword">in</span> empty)&#123;</div><div class="line">    <span class="built_in">console</span>.log(property);</div><div class="line">&#125;</div><div class="line"><span class="comment">// add</span></div></pre></td></tr></table></figure></p>
<p>空对象依然会输出一个”add”属性。考虑到js中 <strong><em>for-in</em></strong> 使用频繁，为 <strong><em>Object.prototype</em></strong> 添加可枚举属性会影响大量代码。所以可以在 <strong><em>for-in</em></strong> 中使用 <strong><em>hasOwnProperty()</em></strong>.</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prpperty <span class="keyword">in</span> empty)&#123;</div><div class="line">    <span class="keyword">if</span>(empty.hasOwnProperty(property))&#123;</div><div class="line">        <span class="built_in">console</span>.log(property);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure></p>
<p>这样循环只会输出对象自有属性，不会输出原型属性。</p>
<h2 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h2><p>对象继承是最简单的继承类型。唯一需要做的就是制定那个对象是新对象的 <strong><em>[[Prototype]]</em></strong> 。对象字面量形式会隐式指定 <strong><em>Object.prototype</em></strong> 为其 <strong><em>[[Prototype]]</em></strong>,也可以使用 <strong><em>Object.create()</em></strong> 方法显式指定。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">title</span>:<span class="string">"javascript"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//和下面是一样的</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> book = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</div><div class="line">    <span class="attr">title</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:<span class="string">"javascript"</span>,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>继承其他对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1,&#123;</div><div class="line">    <span class="attr">name</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:<span class="string">"xiaowang"</span>,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">person1.sayName(); <span class="comment">//"laowang"</span></div><div class="line">person2.sayName(); <span class="comment">//"xiaowang"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"sayName"</span>)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.isPrototypeOf(person2)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"sayName"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>另外，也可以通过 <strong><em>Object.create()</em></strong> 创建 <strong><em>[[Prototype]]</em></strong> 为null的对象，这样的对象是没有原型对象链的对象。意味着 <strong><em>toString()</em></strong> 和 <strong><em>valueOf()</em></strong> 等內建方法都不存在该对象上面。实际上，这种对象完全就是一个没有任何预定义属性的白板，也是一个完美的哈希容器，因为不会有自由属性和原型属性的冲突。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nakedObject = object.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> nakedObject); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"valueOf"</span> <span class="keyword">in</span> nakedObject); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>js中的对象继承也是构造函数继承的基础。几乎所有的函数都有 <strong><em>prototype</em></strong> 属性，它可以被修改或者换。该 <strong><em>prototype</em></strong> 属性被自动设置为一个新的继承自 <strong><em>Object.prototype</em></strong> 的泛用对象，该对象有一个自有属性 <strong><em>constructor</em></strong> ,实际上js引擎自动做了下面的事情</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">YourConstructor</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//js引擎自动为你做了下面的事情</span></div><div class="line">YourConstructor.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:YourConstructor,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>创建出来的对象都继承自 <strong><em>Object.prototype</em></strong>。YourConstructor 是Object的子类，Object是YourConstructor 的父类。</p>
<p>由于 <strong><em>prototype</em></strong> 属性可写，可以通过改写它来改变原型对象链。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = size;</div><div class="line">    <span class="keyword">this</span>.width = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="keyword">new</span> Rectangle();</div><div class="line">Square.prototype.constuctor = Square;</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">//50</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.toString()); <span class="comment">//"[Rectangle 5X10 ]"</span></div><div class="line"><span class="built_in">console</span>.log(square.toString()); <span class="comment">//"[Square 6X6 ]"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>此时不需要给Rectangle的调用提供参数，因为他们不需要被使用，而且如果提供了，那所有Square的对象实例都会共享同样的维度。用这种方式改变原型对象链时，需要确保构造函数不会再参数缺失时抛出错误（很多构造函数包含的初始化逻辑会需要参数）且构造函数不会改变任何全局状态，比如追踪有多少实例被创建等。</p>
<p>rect作为Rectangle的实例被创建，而square则是作为Square的实例被创建。两个对象都有getArea方法，那是因为继承自Reatangle.prototype。instanceof操作符认为变量square同时是Square、Rectangle、Object的实例，因为instanceof是使用原型对象链检查对象类型。</p>
<p>使用 <strong><em>Object.create()</em></strong> 方法可以简化并且不会导致参数缺失而报错。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = size;</div><div class="line">    <span class="keyword">this</span>.width = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">//50</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect.toString()); <span class="comment">//"[Rectangle 5X10 ]"</span></div><div class="line"><span class="built_in">console</span>.log(square.toString()); <span class="comment">//"[Square 6X6 ]"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure></p>
<h2 id="构造函数窃取"><a href="#构造函数窃取" class="headerlink" title="构造函数窃取"></a>构造函数窃取</h2><p>由于js中的继承是通过原型对象链来实现的，因此不需要调用对象的父类构造函数。如果需要在子类构造函数中调用父类构造函数，就需要用 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong>。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    Retangle.call(<span class="keyword">this</span>,size,size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Square "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square.length); <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(square.width); <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">//36</span></div></pre></td></tr></table></figure></p>
<p>由于这种做法模仿了那些基于类语言的类继承，通常被称为伪类继承。</p>
<h2 id="访问父类方法"><a href="#访问父类方法" class="headerlink" title="访问父类方法"></a>访问父类方法</h2><p>子类提供的新功能覆盖父类方法很常见，但是如果还想访问父类方法，只能通过 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 来访问了，而且这是唯一方法。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Rectangle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[Rectangle "</span> + <span class="keyword">this</span>.length + <span class="string">"X"</span> + <span class="keyword">this</span>.width + <span class="string">" ]"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Reactangle</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    Retangle.call(<span class="keyword">this</span>,size,size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype.&#123;</div><div class="line">    <span class="attr">constructor</span>:&#123;</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Square.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> text = Rectangle.prototype.toString().call(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> text.replace(<span class="string">"Rectangle"</span>,<span class="string">"Square"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js通过原型对象链支持继承。当将一个对象的 <strong><em>[[Prototype]]</em></strong> 设置为另一个对象时，就在这两个对象之间创建了一条原型对象链。所有的泛用对象都自动继承自 <strong><em>Object.prototype</em></strong> 。如果你想创建一个继承自其它对象的对象，你可以用 <strong><em>Object.create()</em></strong> 指定 <strong><em>[[Prototype]]</em></strong> 为一个新对象。</p>
<p>可以在构造函数中创建原型对象链来完成自定义类型之间的继承。通过将构造函数的 <strong><em>prototype</em></strong> 属性设置为某一个对象那个，就建立了自定义类型对象和该对象的继承关系。构造函数的所有对象、实例共享同一个原型对象，所以他们都继承自该对象。这个技术在继承其他对象的方式时工作得很好。但是不能用原型继承自有属性。</p>
<p>为了正确继承自有属性，可以使用构造函数窃取。只需要以 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 调用父类的构造函数，就可以在子类里面完成各种初始化。结合构造函数窃取和原型对象链是js中最常见的继承手段。由于和基于类的继承相似，这个组合经常被称为伪类继承。</p>
<p>可以通过直接访问父类原型对象的方式访问父类方法。必须以 <strong><em>call()</em></strong> 或者 <strong><em>apply()</em></strong> 执行父类方法并传入一个子类的对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/12/JavaScript面向对象系列：四、构造函数和原型对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/12/JavaScript面向对象系列：四、构造函数和原型对象/" itemprop="url">
                  JavaScript面向对象系列：四、构造函数和原型对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T00:00:00+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Prototype-属性"><a href="#Prototype-属性" class="headerlink" title="[[Prototype]] 属性"></a><strong><em>[[Prototype]]</em></strong> 属性</h2><p>一个对象实例通过内部属性 <strong><em>[[Prototype]]</em></strong> 跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针，当你new创建一个新的对象时，构造函数的原型对象会被赋值给该对象的  <strong><em>[[Prototype]]</em></strong> 属性。</p>
<p>可以调用对象的 <strong><em>Object.getPrototypeOf()</em></strong> 方法读取<strong><em>[[Prototype]]</em></strong> 属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(obj);</div><div class="line"><span class="built_in">console</span>.log(prototype === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="大部分js引擎都会提供一个-proto-属性。该属性使你可以直接读写-Prototype-属性。"><a href="#大部分js引擎都会提供一个-proto-属性。该属性使你可以直接读写-Prototype-属性。" class="headerlink" title="大部分js引擎都会提供一个  proto 属性。该属性使你可以直接读写 [[Prototype]] 属性。"></a>大部分js引擎都会提供一个 <strong> </strong>proto<strong> </strong>属性。该属性使你可以直接读写 <strong><em>[[Prototype]]</em></strong> 属性。</h2><h2 id="可以使用-isPrototypeOf-方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有"><a href="#可以使用-isPrototypeOf-方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有" class="headerlink" title="可以使用 isPrototypeOf() 方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有."></a>可以使用 <strong><em>isPrototypeOf()</em></strong> 方法检查某个对象是否是另一个对象的原型对象，该方法在所有对象中都有.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(obj)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>因为obj是一个泛用对象，原型是Object.prototype</p>
<h2 id="当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索-Prototype-中的对象，如果找到则返回。如果找不到，则返回undefined。"><a href="#当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索-Prototype-中的对象，如果找到则返回。如果找不到，则返回undefined。" class="headerlink" title="当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索[[Prototype]] 中的对象，如果找到则返回。如果找不到，则返回undefined。"></a>当读取一个对象的属性时，js引擎首先在该对象的自有属性中查找属性名。如果找到则返回。如果自有属性中不包含该名字，则js引擎会搜索<strong><em>[[Prototype]]</em></strong> 中的对象，如果找到则返回。如果找不到，则返回undefined。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line">obj.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"[object Custom]"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Custom]"</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> obj.toString;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> obj.toString;</div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//"[object Object]"</span></div></pre></td></tr></table></figure>
<p>上述例子也说明了，仅当自有属性被删除时，原型属性才会再一次被使用。delete操作符仅对自有属性起作用，无法删除原型对象的属性。</p>
<h2 id="在构造函数中使用原型对象"><a href="#在构造函数中使用原型对象" class="headerlink" title="在构造函数中使用原型对象"></a>在构造函数中使用原型对象</h2><p>使用对象字面量形式改写原型对象时要注意 <strong><em>constructor</em></strong> 属性</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === Person); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>使用这种方式创建原型对象，<strong><em>constructor</em></strong> 属性会有误差。每一个原型对象都有一个 <strong><em>constructor</em></strong> 属性，这是其他对象实例没有的。</p>
<p>当一个函数被创建时，它的 <strong><em>prototype</em></strong> 属性也被创建，且该原型对象的 <strong><em>constructor</em></strong> 属性指向该函数。当使用对象字面量形式改写原型对象的时候，<strong><em>constructor</em></strong> 被置为泛对象Object。得手动修正。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor === <span class="built_in">Object</span>); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.constructor === Person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person2.constructor === <span class="built_in">Object</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>构造函数、原型对象和对象实例之间的关系最有趣的一个方面也许就是对象实例和构造函数之间没有直接联系。不过对象实例和原型对象以及原型对象和构造函数之间都有直接联系。</p>
<h2 id="改变原型对象"><a href="#改变原型对象" class="headerlink" title="改变原型对象"></a>改变原型对象</h2><p>给定类型的所有对象实例功效一个原型对象，所以可以一次性扩充所有对象实例。<strong>_[[Prototype]]</strong> 属性只是包含了一个指向原型对象的指针。任何对原型对象的改变都立即反映到所有引用它的对象实例上。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person1); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person2); <span class="comment">//false</span></div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person1.sayHi(); <span class="comment">//"Hi"</span></div><div class="line">person2.sayHi(); <span class="comment">//"Hi"</span></div></pre></td></tr></table></figure></p>
<p>对象封印和对象冻结只能操作对象的自有属性。封印或者冻结之后，无法添加自有属性或者改变冻结对象的自有属性。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:Person,</div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[Person "</span> + <span class="keyword">this</span>.name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"laowang"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaowang"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(person1);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person1); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayHi"</span> <span class="keyword">in</span> person2); <span class="comment">//false</span></div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person1.sayHi(); <span class="comment">//"Hi"</span></div><div class="line">person2.sayHi(); <span class="comment">//"Hi"</span></div></pre></td></tr></table></figure></p>
<p>其实，<strong><em>[[Prototype]]</em></strong> 属性是对象实例的自有属性，属性本身被冻结，但是其指向的值（原型对象）并没有被冻结。</p>
<p>实际开发中，可能不会频繁的使用原型对象，但是理解对象实例及其原型对象之间的关系是非常重要的。</p>
<h2 id="改变内建原型对象"><a href="#改变内建原型对象" class="headerlink" title="改变内建原型对象"></a>改变内建原型对象</h2><p>所有的內建对象都有构造函数，因此也都有原型对象可以改变。</p>
<p>例如，简单修改Array的原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> pre + cur;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> result = numbers.sum();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//15</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构造函数就是用 <strong><em>new</em></strong> 操作符调用的普通函数。可以随时定义自己的构造函数来创建多个具有同样属性的对象。可以用 <strong><em>instanceof</em></strong> 操作符或直接访问 <strong><em>constructor</em></strong> 属性来鉴别对象是被哪个构造函数创建的。</p>
<p>每一个函数都有都具有 <strong><em>prototype</em></strong> 属性，它定义了该构造函数创建的所有对象共享的属性。通常，共享的方法和原始值属性被定义在原型对象里，而其他属性都定义在构造函数里。 <strong><em>constructor</em></strong> 属性实际上被定义在原型对象里供所有对象实例共享。</p>
<p>原型对象被保存在对象实例内部的 <strong><em>[[Prototype]]</em></strong> 属性中。这个属性时一个引用而不是副本。由于js查找属性的机制，对原型对象的修改都立刻出现在所有对象实例中。当试图访问一个对象的某个属性时，js首先在自有属性里查找该名字，如果自有属性中没有找到则在原型属性中查找。这样的机制意味着原型对象可以随时改变而引用它的对象实例则立即反映出这些改变。</p>
<p>內建对象也有可以被修改的原型对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/06/06/JavaScript面向对象系列：三、理解对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/06/JavaScript面向对象系列：三、理解对象/" itemprop="url">
                  JavaScript面向对象系列：三、理解对象构造函数和原型对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-06T00:00:00+08:00">
                2017-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。"><a href="#js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。" class="headerlink" title="js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。"></a>js中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，js对象没有这种限制。js编程的一大重点就是管理对象。</h2><h2 id="当一个属性第一次被添加给对象时，js在对象上调用一个名为-Put-的内部方法。-Put-方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用-Put-的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。"><a href="#当一个属性第一次被添加给对象时，js在对象上调用一个名为-Put-的内部方法。-Put-方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用-Put-的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。" class="headerlink" title="当一个属性第一次被添加给对象时，js在对象上调用一个名为 [[Put]] 的内部方法。 [[Put]] 方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用 [[Put]] 的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。"></a>当一个属性第一次被添加给对象时，js在对象上调用一个名为 <strong><em>[[Put]]</em></strong> 的内部方法。 <strong><em>[[Put]]</em></strong> 方法会在对象上创建一个新的节点来保存属性们就像第一次在哈希表上添加一个键一样。这个操作不仅指定了初始值，也定义了属性的一些特征。调用 <strong><em>[[Put]]</em></strong> 的结果是在对象上创建了一个自有属性。一个自有属性表明仅仅该指定对象实例拥有该属性。该属性被直接保存在实力内，对该属性的所有操作都必须通过该对象进项。</h2><h2 id="当一个已有的属性被赋予一个新值的时候，调用一个名为-Set-的方法。该方法将属性的当前方法替换为新值。"><a href="#当一个已有的属性被赋予一个新值的时候，调用一个名为-Set-的方法。该方法将属性的当前方法替换为新值。" class="headerlink" title="当一个已有的属性被赋予一个新值的时候，调用一个名为 [[Set]] 的方法。该方法将属性的当前方法替换为新值。"></a>当一个已有的属性被赋予一个新值的时候，调用一个名为 <strong><em>[[Set]]</em></strong> 的方法。该方法将属性的当前方法替换为新值。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span> <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">&#125;;</div><div class="line">person.age = <span class="number">25</span>; <span class="comment">//调用 [[Put]] 方法</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>; <span class="comment">//调用 [[Set]] 方法</span></div></pre></td></tr></table></figure>
<h2 id="属性探测"><a href="#属性探测" class="headerlink" title="属性探测"></a>属性探测</h2><p>不要使用一下模式探测属性是否存在<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(person.age)&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为当person.age 为一个对象、非空字符串、非零数字、true时，会判断为真。当person为 null、undefined、0、false、NaN或空字符串会判断为假。</p>
<p>更可靠的属性探测方式是使用 <strong><em>in</em></strong> 操作符。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sex"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>使用 <strong><em>in</em></strong> 操作符，在大多数情况下是属性探测的最好的办法。它还有一个额外的好处是不会评估属性的值。当此类评估会导致性能问题或者错误时，这一点很重要。</p>
<h2 id="在某些情况下，希望检查一个属性是不是自有属性。"><a href="#在某些情况下，希望检查一个属性是不是自有属性。" class="headerlink" title="在某些情况下，希望检查一个属性是不是自有属性。"></a>在某些情况下，希望检查一个属性是不是自有属性。</h2><p><strong><em>in</em></strong> 操作符会检查自有属性和原型属性，所以不能检查出正确结果。</p>
<p>另一个方法是 hasOwnProperty方法，这个方法只有在属性存在并且是自有属性时才返回true。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span> <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">"toString"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>##删除对象属性</p>
<p>使用 <strong><em>delete</em></strong> 操作符可以将属性从一个对象中删除。将对象的一个属性设置为null并不能将属性从对象中彻底删除，这种做法只会将原值替换为null。</p>
<p>使用 <strong><em>delete</em></strong> 操作符会调用对象内部名为 <strong><em>[[Delete]]</em></strong> 的内部方法。相当于从哈希表中移除了一个键值对。</p>
<h2 id="属性枚举"><a href="#属性枚举" class="headerlink" title="属性枚举"></a>属性枚举</h2><p>对象内部属性 <strong><em>[[Enumerable]]</em></strong> 设置为true，则属性可以循环遍历。可以使用 <strong><em>for-in</em></strong> 操作符来遍历一个对象。es5中新增 <strong><em>Object.keys()</em></strong> 来遍历对象的键，返回一个键组成的数组。</p>
<p>这两种操作符循环遍历有区别， <strong><em>for-in</em></strong> 操作符会遍历自有属性和原型属性，<strong><em>Object.keys()</em></strong> 只会遍历自由属性。</p>
<p>并不是所有属性都是可枚举的，实际上，对象大部分原生方法的 <strong><em>[[Enumerable]]</em></strong> 设置为false,可以使用 <strong><em>propertyIsEnumerable()</em></strong> 方法来检查一个属性是否为可枚举，每个对象都有这个方法。</p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p><strong><em>get</em></strong> 和 <strong><em>set</em></strong> 属性时访问器属性，可以定义属性被读取或者写入时候的行为。这两个属性可以只设置其中一个，如果只设置 <strong><em>get</em></strong> 这个属性变为只读，如果只设置 <strong><em>set</em></strong> 这个属性变为只写，这两种情况在严格模式下会报错.</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>, <span class="comment">//调用 [[Put]] 方法</span></div><div class="line">    set name(value)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>);</div><div class="line">        <span class="keyword">this</span>.name = value;</div><div class="line">    &#125;,</div><div class="line">    get name()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person.name; <span class="comment">//get</span></div><div class="line">person.name = <span class="string">'xiaowang'</span>; <span class="comment">//set</span></div></pre></td></tr></table></figure>
<p>##通用特征</p>
<p>有两个属性是数据和访问器都具有的。一个是 <strong><em>[[Enumerable]]</em></strong> ，决定了你是否可以遍历该属性。另一个是<br><strong><em>[[Configurable]]</em></strong> ,决定了该属性是否可配置.可以随时删除或改变一个可配置属性。改变属性特征，可以使用 <strong><em>Object.defineProperty()</em></strong> 方法。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">enumerable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.propertyIsEnumerable(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> propertites = <span class="built_in">Object</span>.keys(person);</div><div class="line"><span class="built_in">console</span>.log(propertites.length); <span class="comment">//0</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></div><div class="line">&#125;);  <span class="comment">//报错</span></div></pre></td></tr></table></figure>
<p>一个属性被设置为不可配置了，就不能再修改了。<strong>无法将一个不可配置属性变成可配置属性</strong> 。删除一个不可配置属性，非严格模式下会失败，严格模式下会报错。</p>
<h2 id="数据属性特征"><a href="#数据属性特征" class="headerlink" title="数据属性特征"></a>数据属性特征</h2><p>数据属性拥有两个访问器属性不具备的特征：</p>
<p>第一个是 <strong><em>[[Value]]</em></strong> ,包含属性的值，在对象上创建属性时该特征被自动赋值。所有的属性的值都保存在 <strong><em>[[Value]]</em></strong> 中，即使值是一个函数。</p>
<p>第二个是 <strong><em>[[Writable]]</em></strong> ,该特种是一个布尔值，只是该属性是否可以写入，所有的属性默认是可写的。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    <span class="attr">value</span>:<span class="string">"laowang"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.propertyIsEnumerable(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div></pre></td></tr></table></figure>
<p>使用 <strong><em>Object.defineProperty()</em></strong> 定义新的属性时，一定要为所有特征指定一个值，否则布尔值类型的特征会被默认设置为false。上面这个name就是不可枚举，不可配置，不可写。</p>
<h2 id="定义多重属性"><a href="#定义多重属性" class="headerlink" title="定义多重属性"></a>定义多重属性</h2><p>使用 <strong><em>Object.defineProperty()</em></strong> 可以定义一个属性的特征。使用 <strong><em>Object.defineProperties()</em></strong> 可以定义多个属性的特征。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperties(person,&#123;</div><div class="line">    <span class="attr">name</span>:&#123;</div><div class="line">        <span class="attr">value</span>:<span class="string">"laowang"</span>,</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">age</span>:&#123;</div><div class="line">        <span class="attr">value</span>:<span class="number">25</span>,</div><div class="line">        <span class="attr">configurable</span>:<span class="literal">false</span>,</div><div class="line">        <span class="attr">enumerable</span>:<span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="获取属性特征"><a href="#获取属性特征" class="headerlink" title="获取属性特征"></a>获取属性特征</h2><p>使用 <strong><em>Object.getOwnPropertyDescriptor()</em></strong> 可以获取一个属性的所有特征</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.writable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">//laowang</span></div></pre></td></tr></table></figure>
<h2 id="对象禁止扩展"><a href="#对象禁止扩展" class="headerlink" title="对象禁止扩展"></a>对象禁止扩展</h2><p>对象也有内部特征，禁止扩展方法是 <strong><em>Object.preventExtensions()</em></strong> 。可以用 <strong><em>Object.isExtensible()</em></strong> 来检查对象的 <strong><em>[[Extensible]]</em></strong> 的值。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h2 id="对象封印"><a href="#对象封印" class="headerlink" title="对象封印"></a>对象封印</h2><p>对象封印时创建不可扩展对象的第二种方法。对象被封印后是不可扩展的并且所有属性都不可配置。不仅不能给对象添加新属性，也不能删除属性或改变其类型（从数据属性编程访问器属性或者相反）。一个对象被封印，则只能读写它的属性。</p>
<p>使用 <strong><em>Object.seal()</em></strong> 方法来封印一个对象。对象的 <strong><em>[[Extensible]]</em></strong> 被设置为false。 其余所有属性的 <strong><em>[[Configurate]]</em></strong> 特征被设置为false。可以使用 <strong><em>Object.isSealed()</em></strong>  来判断一个对象是否被封印。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.seal(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//xiaowang</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//xiaowang</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="对象冻结"><a href="#对象冻结" class="headerlink" title="对象冻结"></a>对象冻结</h2><p>创建不可扩展对象的最后一种方法是冻结对象。如果一个对象被冻结，则不能在对象上添加或者删除属性，不能改变属性类型，也不能写入任何数据属性。被冻结对象是一个数据属性都为只读的封印对象。被冻结的对象无法解冻。使用 <strong><em>Object.freeze()</em></strong> 来冻结一个对象，使用 <strong><em>Object.isFrozen()</em></strong> 来判断一个对象是否被冻结。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"laowang"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(peson)); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.freeze(peson);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(peson)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(peson)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(peson)); <span class="comment">//true</span></div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"sayName"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></div><div class="line"></div><div class="line">person.name = <span class="string">"xiaowang"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//laowang</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.writable); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.configurate); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>属性有两种类型：数据属性、访问器属性。数据属性可以保存值，访问器属性不保存值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/05/24/JavaScript面向对象系列：二、函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/24/JavaScript面向对象系列：二、函数/" itemprop="url">
                  JavaScript面向对象系列：二、函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T00:00:00+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为-Call-的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。"><a href="#在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为-Call-的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。" class="headerlink" title="在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 [[Call]] 的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。"></a>在js中，函数气死就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 <strong><em>[[Call]]</em></strong> 的内部属性。内部属性无法通过代码访问而是定义了代码执行时的行为。es为js的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。</h2><h2 id="Call-属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有-Call-属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含-Call-属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof-不会再将正则表达式鉴别为函数了"><a href="#Call-属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有-Call-属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含-Call-属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof-不会再将正则表达式鉴别为函数了" class="headerlink" title="[[Call]] 属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有 [[Call]] 属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含 [[Call]] 属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof 不会再将正则表达式鉴别为函数了."></a><strong><em>[[Call]]</em></strong> 属性是函数独有的，表明该对象是可以被执行的。由于仅函数拥有该属性，es定义typeof操作符对任何具有 <strong><em>[[Call]]</em></strong> 属性的对象返回”function”。这在过去曾导致一些问题，因为某些浏览器曾经在正则表达式中包含 <strong><em>[[Call]]</em></strong> 属性，导致后者被错误鉴别为函数。现在，所有的浏览器行为都一致。typeof 不会再将正则表达式鉴别为函数了.</h2><h2 id="声明还是表达式"><a href="#声明还是表达式" class="headerlink" title="声明还是表达式"></a>声明还是表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数具有两种字面形式</div></pre></td></tr></table></figure>
<p>第一种：函数声明<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种：函数表达式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两种看起来相似，实际上有一个非常重要的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数名声形式的会被提升至上下文（context）顶部，而函数表达式不会</div></pre></td></tr></table></figure></p>
<p>所以就会有下面的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种实际上是能正确运行的，这是因为函数声明被提升至上下文顶部，好像被写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>但是下面这种就会报错<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = add(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为函数表达式不会被提升，所以上面执行时找不到函数。<br>不过，只要你始终在使用函数前定义他们，你就可以随意使用者两种字面形式.</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>js的函数另一个独特之处在于你可以给函数传递任意数量的参数却不造成错误。因为函数参数实际被保存在arguments的类数组对象中。</p>
<p>函数的命名参数只不过是为了方便使用，并不是真正的限制了该函数可接受参数的个数。</p>
<p>函数的命名参数都是函数的期望参数，函数的length属性只会显示出期望参数的个数。</p>
<p>例如</p>
<p>情况一<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflect</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>)); <span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>),<span class="number">25</span>); <span class="comment">//"1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect.length); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>情况二<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflect</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>)); <span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect(<span class="string">"1"</span>),<span class="number">25</span>); <span class="comment">//"1"</span></div><div class="line"><span class="built_in">console</span>.log(reflect.length); <span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>大多数面向对象语言支持函数重载，它能让一个函数具有多个 <strong><em>函数签名（函数签名由函数的名字，参数的个数以及其类型组成）</em></strong> ,因为js可以接受任意数量的参数且没有类型限制，所以js没有函数重载。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Default message"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayMessage(<span class="string">"Hello"</span>); <span class="comment">//"Default message"</span></div></pre></td></tr></table></figure></p>
<p>这里为什么是 “Default message”,可以用对象来帮助理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sayMessage = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"message"</span>,<span class="string">"console.log(message);"</span>);</div><div class="line">sayMessage = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"message"</span>,<span class="string">"console.log(\"Default message\");"</span>);</div><div class="line">sayMessage(<span class="string">"Hello!"</span>); <span class="comment">//Default message</span></div></pre></td></tr></table></figure></p>
<p>但是js可以模仿函数重载</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</div><div class="line">        message = <span class="string">"Default message"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line">sayMessage(<span class="string">"Hello!"</span>); <span class="comment">//Hello!</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js函数的独特之处在于它们同时也是对象，也就是说它们可以被访问、复制、覆盖，就像其他对象一样。js中的函数和其他对象最大区别在于函数对象有一个特殊的内部属性 <strong><em>[[Call]]</em></strong>,包含了该函数的执行指令。typeof 操作符会在对象内部查找这个内部属性，如果找到，就返回 “function”</p>
<p>函数字面形式有两种：声明和表达式。函数声明会被提升至上下文顶部，而函数表达式不会。但是函数表达式可以用于任何可以使用值的地方，例如赋值语句、函数参数或者另一个函数的返回值。</p>
<p>函数是对象，所以存在一个构造函数 Function。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/05/20/JavaScript面向对象系列：一、类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/20/JavaScript面向对象系列：一、类型/" itemprop="url">
                  JavaScript面向对象系列：一、类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T00:00:00+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js有5中原始类型-Boolean-number-string-null-undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。"><a href="#js有5中原始类型-Boolean-number-string-null-undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。" class="headerlink" title="js有5中原始类型 Boolean number string null undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。"></a>js有5中原始类型 Boolean number string null undefined，所有原始类型的值都有字面形式。字面形式是不被保存在变量中的值。</h2><h2 id="js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝-例如"><a href="#js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝-例如" class="headerlink" title="js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝.例如"></a>js和其他许多语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。当你将原始值赋值给一个变量时，改值将被赋值到变量中。也是就说，如果你使一个变量等于另一个变量时，每一个变量都有它自己的一份数据拷贝.例如</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color1 = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> color2 = color1;</div></pre></td></tr></table></figure>
<h2 id="每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量"><a href="#每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量" class="headerlink" title="每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量."></a>每个含有原始变量的变量使用自己的存储空间，一个变量的改变不会影响到其他变量.</h2><h2 id="虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）"><a href="#虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）" class="headerlink" title="虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）."></a>虽然字符串、数字和布尔值是原始类型，但是他们也拥有方法（null和undefined没有方法）.</h2><h2 id="尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。"><a href="#尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。" class="headerlink" title="尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。"></a>尽管原始类型拥有方法，但是他们不是对象，js使他们看上起像对象一样，以此来提供语言上的一致性体验。</h2><h2 id="引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。"><a href="#引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。" class="headerlink" title="引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。"></a>引用类型是指js中的对象，同时也是在语言中能找到的最接近类的东西。引用值就是引用类型的实例，也是对象的同义词。对象是属性的无序列表。</h2><h2 id="当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。"><a href="#当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。" class="headerlink" title="当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。"></a>当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的一个对象。</h2><h2 id="js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。"><a href="#js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。" class="headerlink" title="js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。"></a>js语言有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但是最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为null。</h2><h2 id="js内建类型-Array-Date-Error-Function-Object-RegExp"><a href="#js内建类型-Array-Date-Error-Function-Object-RegExp" class="headerlink" title="js内建类型 Array Date Error Function Object RegExp"></a>js内建类型 Array Date Error Function Object RegExp</h2><h2 id="鉴别引用类型，对于函数，typeof-返回的是-funcion-但是其他引用类型的返回都是object-其他的引用类型可以使用instanceof来鉴别。"><a href="#鉴别引用类型，对于函数，typeof-返回的是-funcion-但是其他引用类型的返回都是object-其他的引用类型可以使用instanceof来鉴别。" class="headerlink" title="鉴别引用类型，对于函数，typeof 返回的是 funcion,但是其他引用类型的返回都是object.其他的引用类型可以使用instanceof来鉴别。"></a>鉴别引用类型，对于函数，typeof 返回的是 funcion,但是其他引用类型的返回都是object.其他的引用类型可以使用instanceof来鉴别。</h2><h2 id="es5引入Array-isArray-item-来鉴别数组"><a href="#es5引入Array-isArray-item-来鉴别数组" class="headerlink" title="es5引入Array.isArray(item)来鉴别数组"></a>es5引入Array.isArray(item)来鉴别数组</h2><h2 id="原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。"><a href="#原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。" class="headerlink" title="原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。"></a>原始封装类型共有三种，String，Number，Boolean。这些特殊引用类型的存在使得原始类型用起来和对象一样方便。</h2><h2 id="字符串对象的存在仅用于该语句并在随后被销毁。"><a href="#字符串对象的存在仅用于该语句并在随后被销毁。" class="headerlink" title="字符串对象的存在仅用于该语句并在随后被销毁。"></a>字符串对象的存在仅用于该语句并在随后被销毁。</h2><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"aaaa"</span>;</div><div class="line">name.last = <span class="string">"bbbb"</span></div><div class="line"><span class="built_in">console</span>.log(name.last);  <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>下面是实际在js引擎中实际发生的事</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name  = <span class="string">"aaaa"</span>;</div><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(name);</div><div class="line">temp.last = <span class="string">"bbbb"</span>;</div><div class="line">temp = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(name);</div><div class="line"><span class="built_in">console</span>.log(temp);  <span class="comment">//undefined</span></div><div class="line">temp = <span class="literal">null</span></div></pre></td></tr></table></figure>
<p>实际上是在一个立刻就被销毁的临时对象上而不是字符串上添加了新的属性。之后当你试图访问该属性时，另一个不同的临时对象被创建，而新属性并不存在。虽然原始封装类型会被自动创建，在这些值上进行instanceof检查对应类型的返回值却都是false。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"aaa"</span>;</div><div class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(name <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(count <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(found <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>这是因为临时对象仅在值被读取时被创建。instanceof操作符并没有真的读取任何东西，也就是没有临时对象的创建，于是它告诉我们这些值并不属于原始封装类型。<br>你也可以手动创建原始封装类型，但是有某些副作用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"aaa"</span>);</div><div class="line"><span class="keyword">var</span> count = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> found = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">//"object"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> count); <span class="comment">//"object"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> found); <span class="comment">//"object"</span></div></pre></td></tr></table></figure>
<p>手动创建原始封装类型实际会创建出一个object，这意味着typeof无法手动鉴别出你实际保存的数据类型</p>
<h2 id="一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。"><a href="#一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。" class="headerlink" title="一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。"></a>一个对象在条件判断语句中总被认为是true，无论该对象的值是不是等于false。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found =  <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"><span class="keyword">if</span>(found)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Found"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//结果执行了，"Found"</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>javascript中虽然没有类，但是有类型。每个变量或数据都有一个对应的原始类型或者引用类型。5种原始类型（字符串、数字、布尔值、空类型、未定义）的值会被直接保存在变量对象中。除了空类型，都可以用typeof来鉴别。空类型必须直接跟null进行比较才能鉴别。

引用类型是js中最接近类的东西，而对象则是引用类型的实例。可以使用new操作符或者字面量的形式创建新对象。通常可以用点号访问属性和方法，也可以用中括号。函数在js中也是对象，可以使用typeof来鉴别他们。至于其他引用类型，你应该用instanceof和一个构造函数来鉴别。

为了让原始类型看上去更像引用类型，js提供了三种原始封装类型：String、Number、Boolean。js会在背后创建这些对象是的你能够像使用普通对象那样直接使用原始值，但是这些临时对象在使用它们的语句结束时就立刻被销毁。虽然你也可以自己创建原始封装类型的实例，但是它们太容易令人误解，所以最好别这么干。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="赖宝" />
          <p class="site-author-name" itemprop="name">赖宝</p>
           
              <p class="site-description motion-element" itemprop="description">努力学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖宝</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
