<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="努力学习">
<meta property="og:type" content="website">
<meta property="og:title" content="赖宝的宝">
<meta property="og:url" content="http://blog.webtoatl.cn/index.html">
<meta property="og:site_name" content="赖宝的宝">
<meta property="og:description" content="努力学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赖宝的宝">
<meta name="twitter:description" content="努力学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.webtoatl.cn/"/>





  <title> 赖宝的宝 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖宝的宝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端技能分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/09/01/js 深拷贝和浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/01/js 深拷贝和浅拷贝/" itemprop="url">
                  js 深拷贝和浅拷贝
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-01T00:00:00+08:00">
                2017-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://user-gold-cdn.xitu.io/2017/9/3/998e84124743f57f2f7e4005773baa0c?imageView2/0/w/1280/h/960" alt="image"></p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。</p>
<p>堆和栈都是内存中划分出来用来存储的区域。</p>
<blockquote>
<p>栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。</p>
</blockquote>
<h2 id="ECMAScript-的数据类型"><a href="#ECMAScript-的数据类型" class="headerlink" title="ECMAScript 的数据类型"></a>ECMAScript 的数据类型</h2><p>在将深拷贝和浅拷贝之前，我们先来重新回顾一下 ECMAScript 中的数据类型。主要分为</p>
<h3 id="基本数据类型（undefined，boolean，number，string，null）"><a href="#基本数据类型（undefined，boolean，number，string，null）" class="headerlink" title="基本数据类型（undefined，boolean，number，string，null）"></a>基本数据类型（undefined，boolean，number，string，null）</h3><p>基本数据类型主要是：undefined，boolean，number，string，null。</p>
<h3 id="基本数据类型存放在栈中"><a href="#基本数据类型存放在栈中" class="headerlink" title="基本数据类型存放在栈中"></a>基本数据类型存放在栈中</h3><p>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。</p>
<h3 id="基本数据类型值不可变"><a href="#基本数据类型值不可变" class="headerlink" title="基本数据类型值不可变"></a>基本数据类型值不可变</h3><blockquote>
<p>javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。</p>
</blockquote>
<p>基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> str = <span class="string">"abc"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str[<span class="number">1</span>]=<span class="string">"f"</span>);    <span class="comment">// f</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str);           <span class="comment">// abc</span></div></pre></td></tr></table></figure>
<p>这一点其实开始我是比较迷惑的，总是感觉 js 是一个灵活的语言，任何值应该都是可变的，真是图样图森破，我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。就如上述引用所说的那样，在 js 中没有方法是可以改变布尔值和数字的。倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。</p>
<p>所以，记住这一点：<strong>基本数据类型值不可变</strong></p>
<h3 id="基本类型的比较是值的比较"><a href="#基本类型的比较是值的比较" class="headerlink" title="基本类型的比较是值的比较"></a>基本类型的比较是值的比较</h3><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(a === b);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="基本数据类型存放在堆中"><a href="#基本数据类型存放在堆中" class="headerlink" title="基本数据类型存放在堆中"></a>基本数据类型存放在堆中</h3><p>引用类型（<strong>object</strong>）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;<span class="attr">name</span>:<span class="string">'jozo'</span>&#125;;</div><div class="line"><span class="keyword">var</span> person2 = &#123;<span class="attr">name</span>:<span class="string">'xiaom'</span>&#125;;</div><div class="line"><span class="keyword">var</span> person3 = &#123;<span class="attr">name</span>:<span class="string">'xiaoq'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/6fb2c3d13d830efc6ae07ac368df0816?imageView2/0/w/1280/h/960" alt="image"></p>
<h3 id="引用类型值可变"><a href="#引用类型值可变" class="headerlink" title="引用类型值可变"></a>引用类型值可变</h3><p>引用类型是可以直接改变其值的，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">a[<span class="number">1</span>] = <span class="number">5</span>;</div><div class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="引用类型的比较是引用的比较"><a href="#引用类型的比较是引用的比较" class="headerlink" title="引用类型的比较是引用的比较"></a>引用类型的比较是引用的比较</h3><p>所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/a32ee86b9f3e303216d19240441cedfd?imageView2/0/w/1280/h/960" alt="image"></p>
<h2 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h2><p>了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。<br>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line"></div><div class="line">a ++ ;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 11</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/8d973a9718da1806d19db0c1541ff425?imageView2/0/w/1280/h/960" alt="image"><br>所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。</p>
<p>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;; <span class="comment">// a保存了一个空对象的实例</span></div><div class="line"><span class="keyword">var</span> b = a;  <span class="comment">// a和b都指向了这个空对象</span></div><div class="line"></div><div class="line">a.name = <span class="string">'jozo'</span>;</div><div class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// 'jozo'</span></div><div class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">// 'jozo'</span></div><div class="line"></div><div class="line">b.age = <span class="number">22</span>;</div><div class="line"><span class="built_in">console</span>.log(b.age);<span class="comment">// 22</span></div><div class="line"><span class="built_in">console</span>.log(a.age);<span class="comment">// 22</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/01dad9dc00fb0efe81d9bcbe9d30a1bd?imageView2/0/w/1280/h/960" alt="image"></p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>在深入了解之前，我认为上面的赋值就是浅拷贝，哇哈哈，真的是图样图森破。上面那个应该只能算是“引用”，并不算是真正的浅拷贝。</p>
<h2 id="赋值（-）和浅拷贝的区别"><a href="#赋值（-）和浅拷贝的区别" class="headerlink" title="赋值（=）和浅拷贝的区别"></a>赋值（=）和浅拷贝的区别</h2><p>那么赋值和浅拷贝有什么区别呢，我们看下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    <span class="string">'name'</span> : <span class="string">'zhangsan'</span>,</div><div class="line">    <span class="string">'age'</span> :  <span class="string">'18'</span>,</div><div class="line">    <span class="string">'language'</span> : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]],</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dst = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</div><div class="line">        <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</div><div class="line">            dst[prop] = src[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj2.name = <span class="string">"lisi"</span>;</div><div class="line">obj3.age = <span class="string">"20"</span>;</div><div class="line"></div><div class="line">obj2.language[<span class="number">1</span>] = [<span class="string">"二"</span>,<span class="string">"三"</span>];</div><div class="line">obj3.language[<span class="number">2</span>] = [<span class="string">"四"</span>,<span class="string">"五"</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj1);  </div><div class="line"><span class="comment">//obj1 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'lisi',</span></div><div class="line"><span class="comment">//    'age' :  '18',</span></div><div class="line"><span class="comment">//    'language' : [1,["二","三"],["四","五"]],</span></div><div class="line"><span class="comment">//&#125;;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj2);</div><div class="line"><span class="comment">//obj2 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'lisi',</span></div><div class="line"><span class="comment">//    'age' :  '18',</span></div><div class="line"><span class="comment">//    'language' : [1,["二","三"],["四","五"]],</span></div><div class="line"><span class="comment">//&#125;;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj3);</div><div class="line"><span class="comment">//obj3 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'zhangsan',</span></div><div class="line"><span class="comment">//    'age' :  '20',</span></div><div class="line"><span class="comment">//    'language' : [1,["二","三"],["四","五"]],</span></div><div class="line"><span class="comment">//&#125;;</span></div></pre></td></tr></table></figure></p>
<p>先定义个一个原始的对象 <strong>obj1</strong>，然后使用赋值得到第二个对象 <strong>obj2</strong>，然后通过浅拷贝，将 <strong>obj1</strong> 里面的属性都赋值到 <strong>obj3</strong> 中。也就是说：</p>
<ul>
<li>obj1：原始数据</li>
<li>obj2：赋值操作得到</li>
<li>obj3：浅拷贝得到</li>
</ul>
<p>然后我们改变 <strong>obj2</strong> 的 <strong>name</strong> 属性和 <strong>obj3</strong> 的 <strong>name</strong> 属性，可以看到，改变赋值得到的对象 <strong>obj2</strong> 同时也会改变原始值 <strong>obj1</strong>，而改变浅拷贝得到的的 <strong>obj3</strong> 则不会改变原始对象 <strong>obj1</strong>。这就可以说明赋值得到的对象 <strong>obj2</strong> 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 <strong>obj3</strong> 则是重新创建了新对象。</p>
<p>然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 <strong>obj2</strong> 和浅拷贝得到的 <strong>obj3</strong> 中的 <strong>language</strong> 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 <strong>obj2</strong> 和浅拷贝得到的 <strong>obj3</strong> 都会改变原始数据。</p>
<p>这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 <strong>obj3</strong> 中的引用类型时，会使原始数据得到改变。</p>
<p>深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，</p>
<p>浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象</p>
<table>
<thead>
<tr>
<th>–</th>
<th>和原数据是否指向同一对象</th>
<th>第一层数据为基本数据类型</th>
<th>原数据中包含子对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>赋值</td>
<td>是</td>
<td>改变会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>浅拷贝</td>
<td>否</td>
<td>改变不会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>深拷贝</td>
<td>否</td>
<td>改变不会使原数据一同改变</td>
<td>改变不会使原数据一同改变</td>
</tr>
</tbody>
</table>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>看了这么半天，你也应该清楚什么是深拷贝了吧，如果还不清楚，我就剖腹自尽(ಥ_ಥ)</p>
<p>深拷贝是对对象以及对象的所有子对象进行拷贝。</p>
<p>那么问题来了，怎么进行深拷贝呢？</p>
<p>思路就是递归调用刚刚的浅拷贝，把所有属于对象的属性类型都遍历赋给另一个对象即可。我们直接来看一下 Zepto 中深拷贝的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内部方法：用户合并一个或多个对象到第一个对象</span></div><div class="line"><span class="comment">// 参数：</span></div><div class="line"><span class="comment">// target 目标对象  对象都合并到target里</span></div><div class="line"><span class="comment">// source 合并对象</span></div><div class="line"><span class="comment">// deep 是否执行深度合并</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> source)</div><div class="line">    <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</div><div class="line">        <span class="comment">// source[key] 是对象，而 target[key] 不是对象， 则 target[key] = &#123;&#125; 初始化一下，否则递归会出错的</span></div><div class="line">        <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</div><div class="line">            target[key] = &#123;&#125;</div><div class="line"></div><div class="line">        <span class="comment">// source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的</span></div><div class="line">        <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</div><div class="line">            target[key] = []</div><div class="line">        <span class="comment">// 执行递归</span></div><div class="line">        extend(target[key], source[key], deep)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Copy all but undefined properties from one or more</span></div><div class="line"><span class="comment">// objects to the `target` object.</span></div><div class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">//第一个参数为boolean值时，表示是否深度合并</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</div><div class="line">    deep = target;</div><div class="line">    <span class="comment">//target取第二个参数</span></div><div class="line">    target = args.shift()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 遍历后面的参数，都合并到target上</span></div><div class="line">args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123; extend(target, arg, deep) &#125;)</div><div class="line"><span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Zepto 中的 <strong>$.extend</strong> 方法判断的第一个参数传入的是一个布尔值，判断是否进行深拷贝。</p>
<p>在 <strong>$.extend</strong> 方法内部，只有一个形参 <strong>target</strong>，这个设计你真的很巧妙。<br>因为形参只有一个，所以 target 就是传入的第一个参数的值，并在函数内部设置一个变量 args 来接收去除第一个参数的其余参数，如果该值是一个布尔类型的值的话，说明要启用深拷贝，就将 deep 设置为 true，并将 target 赋值为 args 的第一个值（也就是真正的 target）。如果该值不是一个布尔类型的话，那么传入的第一个值仍为 target 不需要进行处理，只需要遍历使用 extend 方法就可以。</p>
<p>这里有点绕，但是真的设计的很精妙，建议自己打断点试一下，会有意外收获（玩转 js 的大神请忽略）。</p>
<p>而在 extend 的内部，是拷贝的过程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/08/JavaScript 专题之如何判断两个对象相等/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/08/JavaScript 专题之如何判断两个对象相等/" itemprop="url">
                  JavaScript 专题之如何判断两个对象相等
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T00:00:00+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然标题写的是如何判断两个对象相等，但本篇我们不仅仅判断两个对象相等，实际上，我们要做到的是如何判断两个参数相等，而这必然会涉及到多种类型的判断。</p>
<h2 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h2><p>什么是相等？，我们认为只要 === 的结果为 true，两者就相等，然而今天我们重新定义相等：</p>
<p>我们认为：</p>
<p>NaN 和 NaN 是相等<br>[1] 和 [1] 是相等<br>{value: 1} 和 {value: 1} 是相等<br>不仅仅是这些长得一样的，还有</p>
<p>1 和 new Number(1) 是相等<br>‘Curly’ 和 new String(‘Curly’) 是相等<br>true 和 new Boolean(true) 是相等<br>更复杂的我们会在接下来的内容中看到。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们的目标是写一个 eq 函数用来判断两个参数是否相等，使用效果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>];</div><div class="line"><span class="built_in">console</span>.log(eq(a, b)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>在写这个看似很简单的函数之前，我们首先了解在一些简单的情况下是如何判断的？</p>
<h2 id="0-与-0"><a href="#0-与-0" class="headerlink" title="+0 与 -0"></a>+0 与 -0</h2><p>如果 a === b 的结果为 true， 那么 a 和 b 就是相等的吗？一般情况下，当然是这样的，但是有一个特殊的例子，就是 +0 和 -0。</p>
<p>JavaScript “处心积虑”的想抹平两者的差异：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 表现1</span></div><div class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 表现2</span></div><div class="line">(<span class="number">-0</span>).toString() <span class="comment">// '0'</span></div><div class="line">(+<span class="number">0</span>).toString() <span class="comment">// '0'</span></div><div class="line"></div><div class="line"><span class="comment">// 表现3</span></div><div class="line"><span class="number">-0</span> &lt; +<span class="number">0</span> <span class="comment">// false</span></div><div class="line">+<span class="number">0</span> &lt; <span class="number">-0</span> <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>即便如此，两者依然是不同的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> / +<span class="number">0</span> <span class="comment">// Infinity</span></div><div class="line"><span class="number">1</span> / <span class="number">-0</span> <span class="comment">// -Infinity</span></div><div class="line"></div><div class="line"><span class="number">1</span> / +<span class="number">0</span> === <span class="number">1</span> / <span class="number">-0</span> <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>也许你会好奇为什么要有 +0 和 -0 呢？</p>
<p>这是因为 JavaScript 采用了IEEE_754 浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，按照这个标准，最高位是符号位(0 代表正，1 代表负)，剩下的用于表示大小。而对于零这个边界值 ，1000(-0) 和 0000(0)都是表示 0 ，这才有了正负零的区别。</p>
<p>也许你会好奇什么时候会产生 -0 呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.round(-0.1) // -0</div></pre></td></tr></table></figure></p>
<p>那么我们又该如何在 === 结果为 true 的时候，区别 0 和 -0 得出正确的结果呢？我们可以这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>在本篇，我们认为 NaN 和 NaN 是相等的，那又该如何判断出 NaN 呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>利用 NaN 不等于自身的特性，我们可以区别出 NaN，那么这个 eq 函数又该怎么写呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="eq-函数"><a href="#eq-函数" class="headerlink" title="eq 函数"></a>eq 函数</h2><p>现在，我们已经可以去写 eq 函数的第一版了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// eq 第一版</span></div><div class="line"><span class="comment">// 用来过滤掉简单的类型比较，复杂的对象使用 deepEq 函数进行处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// === 结果为 true 的区别出 +0 和 -0</span></div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line"></div><div class="line">    <span class="comment">// typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断 NaN</span></div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line"></div><div class="line">    <span class="comment">// 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false</span></div><div class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</div><div class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更复杂的对象使用 deepEq 函数进行深度比较</span></div><div class="line">    <span class="keyword">return</span> deepEq(a, b);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>也许你会好奇是不是少了一个 <strong>typeof b !== function</strong>?<br>试想如果我们添加上了这句，当 a 是基本类型，而 b 是函数的时候，就会进入 deepEq 函数，而去掉这一句，就会进入直接进入 false，实际上 基本类型和函数肯定是不会相等的，所以这样做代码又少，又可以让一种情况更早退出。</p>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><p>现在我们开始写 deepEq 函数，一个要处理的重大难题就是 ‘Curly’ 和 new String(‘Curly’) 如何判断成相等？</p>
<p>两者的类型都不一样呐！不信我们看 typeof 的操作结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'Curly'</span>); <span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>)); <span class="comment">// object</span></div></pre></td></tr></table></figure></p>
<p>可是我们还有更多的方法判断类型，比如 Object.prototype.toString：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line">toString.call(<span class="string">'Curly'</span>); <span class="comment">// "[object String]"</span></div><div class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>)); <span class="comment">// "[object String]"</span></div></pre></td></tr></table></figure></p>
<p>神奇的是使用 toString 方法两者判断的结果却是一致的，可是就算知道了这一点，还是不知道如何判断字符串和字符串包装对象是相等的呢？</p>
<p>那我们利用隐式类型转换呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Curly'</span> + <span class="string">''</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>) + <span class="string">''</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>看来我们已经有了思路：如果 a 和 b 的 Object.prototype.toString的结果一致，并且都是”[object String]”，那我们就使用 ‘’ + a === ‘’ + b 进行判断。</p>
<p>可是不止有 String 对象呐，Boolean、Number、RegExp、Date呢？</p>
<h2 id="更多对象"><a href="#更多对象" class="headerlink" title="更多对象"></a>更多对象</h2><p>跟 String 同样的思路，利用隐式类型转换。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="regexp">/a/i</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/i</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">''</span> + a === <span class="string">''</span> + b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>嗯哼？你确定 Number 能这么简单的判断？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>可是 a 和 b 应该被判断成 true 的呐~</p>
<p>那么我们就改成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断 Number(NaN) Object(NaN) 等情况</span></div><div class="line">    <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">    <span class="comment">// 其他判断 ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="deepEq-函数"><a href="#deepEq-函数" class="headerlink" title="deepEq 函数"></a>deepEq 函数</h2><p>现在我们可以写一点 deepEq 函数了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> className = toString.call(a);</div><div class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (className) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object String]'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</div><div class="line">            <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">            <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</div><div class="line">      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</div><div class="line">      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</div><div class="line">            <span class="keyword">return</span> +a === +b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其他判断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="构造函数实例"><a href="#构造函数实例" class="headerlink" title="构造函数实例"></a>构造函数实例</h2><p>我们看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Kevin'</span>);</div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Kevin'</span>);</div><div class="line"></div><div class="line">eq(person, animal) <span class="comment">// ???</span></div></pre></td></tr></table></figure></p>
<p>虽然 <strong>person</strong> 和 <strong>animal</strong> 都是 <strong>{name: ‘Kevin’}</strong>，但是 <strong>person</strong> 和 <strong>animal</strong> 属于不同构造函数的实例，为了做出区分，我们认为是不同的对象。</p>
<p>如果两个对象所属的构造函数对象不同，两个对象就一定不相等吗？</p>
<p>并不一定，我们再举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attrs = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">attrs.name = <span class="string">"Bob"</span>;</div><div class="line">eq(attrs, &#123;<span class="attr">name</span>: <span class="string">"Bob"</span>&#125;); <span class="comment">// ???</span></div></pre></td></tr></table></figure></p>
<p>尽管 <strong>attrs</strong> 没有原型，<strong>{name: “Bob”}</strong> 的构造函数是 <strong>Object</strong>，但是在实际应用中，只要他们有着相同的键值对，我们依然认为是相等。</p>
<p>从函数设计的角度来看，我们不应该让他们相等，但是从实践的角度，我们让他们相等，所以相等就是一件如此随意的事情吗？！对啊，我也在想：<strong>undersocre</strong>，你怎么能如此随意呢！！！</p>
<p>哎，吐槽完了，我们还是要接着写这个相等函数，我们可以先做个判断，对于不同构造函数下的实例直接返回 <strong>false</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Function]'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 接着上面的内容</span></div><div class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</div><div class="line">    <span class="comment">// 不是数组</span></div><div class="line">    <span class="keyword">if</span> (!areArrays) &#123;</div><div class="line">        <span class="comment">// 过滤掉两个函数的情况</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</div><div class="line">        <span class="comment">// aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦</span></div><div class="line">        <span class="keyword">if</span> (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下面还有好多判断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组相等"><a href="#数组相等" class="headerlink" title="数组相等"></a>数组相等</h2><p>现在终于可以进入我们期待已久的数组和对象的判断，不过其实这个很简单，就是递归遍历一遍……<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 再接着上面的内容</span></div><div class="line">    <span class="keyword">if</span> (areArrays) &#123;</div><div class="line"></div><div class="line">        length = a.length;</div><div class="line">        <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            <span class="keyword">if</span> (!eq(a[length], b[length])) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">         &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a), key;</div><div class="line">        length = keys.length;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            key = keys[length];</div><div class="line">            <span class="keyword">if</span> (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key]))) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>如果觉得这就结束了，简直是太天真，因为最难的部分才终于要开始，这个问题就是循环引用！</p>
<p>举个简单的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="attr">abc</span>: <span class="literal">null</span>&#125;;</div><div class="line">b = &#123;<span class="attr">abc</span>: <span class="literal">null</span>&#125;;</div><div class="line">a.abc = a;</div><div class="line">b.abc = b;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>再复杂一点的，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="attr">foo</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">foo</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">foo</span>: <span class="literal">null</span>&#125;&#125;&#125;&#125;&#125;;</div><div class="line">b = &#123;<span class="attr">foo</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">foo</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">foo</span>: <span class="literal">null</span>&#125;&#125;&#125;&#125;&#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>为了给大家演示下循环引用，大家可以把下面这段已经精简过的代码复制到浏览器中尝试：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// demo</span></div><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a === b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> deepEq(a, b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a);</div><div class="line">    <span class="keyword">var</span> length = keys.length;</div><div class="line">    <span class="keyword">var</span> key;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        key = keys[length]</div><div class="line"></div><div class="line">        <span class="comment">// 这是为了让你看到代码其实一直在执行</span></div><div class="line">        <span class="built_in">console</span>.log(a[key], b[key])</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!eq(a[key], b[key])) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>嗯，以上的代码是死循环。</p>
<p>那么，我们又该如何解决这个问题呢？underscore 的思路是 eq 的时候，多传递两个参数为 aStack 和 bStack，用来储存 a 和 b 递归比较过程中的 a 和 b 的值，咋说的这么绕口呢？<br>我们直接看个精简的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a === b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    aStack = aStack || [];</div><div class="line">    bStack = bStack || [];</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = aStack.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        <span class="keyword">if</span> (aStack[length] === a) &#123;</div><div class="line">              <span class="keyword">return</span> bStack[length] === b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.push(a);</div><div class="line">    bStack.push(b);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a);</div><div class="line">    <span class="keyword">var</span> length = keys.length;</div><div class="line">    <span class="keyword">var</span> key;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        key = keys[length]</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(a[key], b[key], aStack, bStack)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!eq(a[key], b[key], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// aStack.pop();</span></div><div class="line">    <span class="comment">// bStack.pop();</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b))</div></pre></td></tr></table></figure></p>
<p>之所以注释掉 <strong>aStack.pop()</strong>和<strong>bStack.pop()</strong>这两句，是为了方便大家查看 <strong>aStack</strong>  <strong>bStack</strong>的值。</p>
<h2 id="最终的-eq-函数"><a href="#最终的-eq-函数" class="headerlink" title="最终的 eq 函数"></a>最终的 eq 函数</h2><p>最终的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Function]'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// === 结果为 true 的区别出 +0 和 -0</span></div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line"></div><div class="line">    <span class="comment">// typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断 NaN</span></div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line"></div><div class="line">    <span class="comment">// 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false</span></div><div class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</div><div class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更复杂的对象使用 deepEq 函数进行深度比较</span></div><div class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// a 和 b 的内部属性 [[class]] 相同时 返回 true</span></div><div class="line">    <span class="keyword">var</span> className = toString.call(a);</div><div class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (className) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object String]'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</div><div class="line">            <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">            <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</div><div class="line">            <span class="keyword">return</span> +a === +b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</div><div class="line">    <span class="comment">// 不是数组</span></div><div class="line">    <span class="keyword">if</span> (!areArrays) &#123;</div><div class="line">        <span class="comment">// 过滤掉两个函数的情况</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> aCtor = a.constructor,</div><div class="line">            bCtor = b.constructor;</div><div class="line">        <span class="comment">// aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦</span></div><div class="line">        <span class="keyword">if</span> (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    aStack = aStack || [];</div><div class="line">    bStack = bStack || [];</div><div class="line">    <span class="keyword">var</span> length = aStack.length;</div><div class="line"></div><div class="line">    <span class="comment">// 检查是否有循环引用的部分</span></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        <span class="keyword">if</span> (aStack[length] === a) &#123;</div><div class="line">            <span class="keyword">return</span> bStack[length] === b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.push(a);</div><div class="line">    bStack.push(b);</div><div class="line"></div><div class="line">    <span class="comment">// 数组判断</span></div><div class="line">    <span class="keyword">if</span> (areArrays) &#123;</div><div class="line"></div><div class="line">        length = a.length;</div><div class="line">        <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            <span class="keyword">if</span> (!eq(a[length], b[length], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对象判断</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a),</div><div class="line">            key;</div><div class="line">        length = keys.length;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line"></div><div class="line">            key = keys[length];</div><div class="line">            <span class="keyword">if</span> (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.pop();</div><div class="line">    bStack.pop();</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="built_in">Number</span>(<span class="literal">NaN</span>), <span class="built_in">Number</span>(<span class="literal">NaN</span>))); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="string">'Curly'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>))); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq([<span class="number">1</span>], [<span class="number">1</span>])); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;)); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>真让人感叹一句：eq 不愧是 underscore 中实现代码行数最多的函数了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/08/HTTP Header 详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/08/HTTP Header 详解/" itemprop="url">
                  HTTP Header 详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T00:00:00+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTP（HyperTextTransferProtocol）即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message- header，即http header消息 。http header 消息通常被分为4个部分：general  header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。</p>
<h2 id="Requests部分"><a href="#Requests部分" class="headerlink" title="Requests部分"></a>Requests部分</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: user@email.com</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: www.zcmhi.com</td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="external">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2 id="Responses-部分"><a href="#Responses-部分" class="headerlink" title="Responses 部分"></a>Responses 部分</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/03/JavaScript的原型及原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/03/JavaScript的原型及原型链/" itemprop="url">
                  JavaScript的原型及原型链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 javascript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ 一文中我们提到了在没有类概念的 JavaScript 语言中是通过原型来实现面向对象的继承特性。只要运用得好，这种基于原型的 JavaScript 继承模型比传统的类继承还要强大。所以我们还需详细学习一下原型的知识</p>
<h2 id="JavaScript-的对象"><a href="#JavaScript-的对象" class="headerlink" title="JavaScript 的对象"></a>JavaScript 的对象</h2><p>JavaScript 是基于对象的面向对象语言。因此在这里的“对象”既可以是普通对象（Object），也可以是函数对象（Function）。JS 抛弃了 Java 的类概念，而 Java 的继承恰恰是通过类来实现的。那么 JS 没有类的概念，就使用了“原型”的概念来实现继承。</p>
<h3 id="字面量原型及原型链"><a href="#字面量原型及原型链" class="headerlink" title="字面量原型及原型链"></a>字面量原型及原型链</h3><p>JS 可通过字面量构造对象。为了实现继承，对象里面有个<em>proto</em>属性可以指向该对象的父对象。这个父对象就是所谓的“原型”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animal = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'动物'</span>,</div><div class="line">  <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" is eating"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">animal.eat();     <span class="comment">// animal is eating</span></div><div class="line"><span class="keyword">var</span> dog = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'狗'</span>,</div><div class="line">  <span class="attr">_proto_</span>: animal</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> cat = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'猫'</span>,</div><div class="line">  <span class="attr">_proto_</span>: animal</div><div class="line">&#125;;</div><div class="line">dog.eat();        <span class="comment">// 狗 is eating</span></div><div class="line">cat.eat();        <span class="comment">// 猫 is eating</span></div></pre></td></tr></table></figure>
<p>由上面代码我们可以看出：dog 和 cat 对象的原型都是 animal。但是 dog 和 cat 对象都没有定义 eat()方法，那怎么可以调用呢？其实当eat方法被调用的时候，先在自己的方法列表中寻找， 如果找不到，就去找原型中的方法， 如果原型中找不到， 就去原型的原型中去寻找…… 最后找到Object那里， 如果还找不到， 那就是未定义了。这几个对象通过<em>proto</em>属性建立一个原型链！<br><img src="http://ww1.sinaimg.cn/large/7b6c9535gy1fhwi3i5lirj20gt0f8dif.jpg" alt="image"></p>
<h2 id="构造函数原型及原型链"><a href="#构造函数原型及原型链" class="headerlink" title="构造函数原型及原型链"></a>构造函数原型及原型链</h2><p>但是为了迁就 C++、Java、C# 程序员，让 JavaScript 可以像 Java 那样 new （构造）出一个对象出来，于是这里做了一个变通，也提供了构造函数。例子如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Student(name,grade)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.grade = grade;</div><div class="line">  this.sayHello = function()&#123;</div><div class="line">    console.log('Hi,I'm ' + this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">andy = new Student('Andy',5);</div><div class="line">lisa = new Student('Lisa',5);</div><div class="line">andy.sayHello();    //Hi,I'm Andy</div><div class="line">lisa.sayHello();    //Hi,I'm Lisa</div><div class="line">    </div><div class="line">//假设 andy 和 lisa 是同班同学，同时即将升入六年级</div><div class="line">andy.grade = 6;</div><div class="line">console.log(andy.grade);   // 6</div><div class="line">console.log(lisa.grade);   // 5</div></pre></td></tr></table></figure></p>
<p>由上面的代码所示，我们可以看出这个所谓的构造函数已经很有 Java 类的感觉了。但是这里面存在两个问题：在对象里面定义方法，这样每创建一个对象都会一个sayHello()函数，这样来说显得对象臃肿，浪费资源；同时每个对象各自保有自己的属性和函数的副本，无法做到属性和方法共享。因此，这里有一个更加高效的办法就是把对象共享的属性和方法可以放到 Student.prototype 这个对象当中。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Student.prototype = &#123;</div><div class="line">  <span class="attr">grade</span>: <span class="number">5</span>,</div><div class="line">  <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I'm "</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/*也可以写成</span></div><div class="line">Student.prototype.grade = 5;</div><div class="line">Student.prototype.sayHello = function()&#123;</div><div class="line">  console.log("Hi, I'm "+this.name);</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> Student(<span class="string">"Andy"</span>);</div><div class="line"><span class="keyword">var</span> lisa = <span class="keyword">new</span> Student(<span class="string">"Lisa"</span>);</div><div class="line">andy.sayHello();      <span class="comment">//Hi, I'm Andy</span></div><div class="line">lisa.sayHello();      <span class="comment">//Hi, I'm Lisa</span></div><div class="line">Student.prototype.grade = <span class="number">6</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Andy's grade: "</span>+ andy.grade);    <span class="comment">// 6</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Lisa's grade: "</span>+ Lisa.grade);    <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/7b6c9535gy1fi6yabvn3vj20rn0ogdhf.jpg" alt="image"><br>由上面的代码和示意图可看出这个所谓的构造函数 Student 其实就是一个幌子啊， 每次去new Student的时候，确实会创建一个对象出来（ andy 或者 lisa ) ， 并且把这个对象的原型指针(<em>proto</em>)指向 Student.prototype 这个对象，这样一来就能找到sayHello()方法了。我们应该还知道上面的构造函数Student()对象（JS 中函数也是对象）会创建一个 prototype 对象（Student.prototype），而 new 出来的实例对象例如 andy 和 lisa 是没有这个 prototype 对象，但是他会有个 proto 属性（<em>proto</em>）指向这个构造函数对象的 prototype 对象，从而构成原型链。实例对象其实是通过原型对象与构造函数取得联系的。为了让 Java、C#、C++ 程序员降低学习成本，JavaScript 提供了语法糖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">  sayHello()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I'm "</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> Student(<span class="string">"andy"</span>);   </div><div class="line">andy.sayHello();                     <span class="comment">//Hi, I'm andy</span></div></pre></td></tr></table></figure></p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="built_in">console</span>.log(a);                 <span class="comment">//&#123;&#125;</span></div><div class="line">a.name = <span class="string">'Zhiyu'</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="built_in">console</span>.log(b);                 <span class="comment">//&#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b.name);            <span class="comment">//Zhiyu</span></div></pre></td></tr></table></figure>
<p>上面我们可以看出该方法是创建一个空对象，空对象的原型是create()参数。此时创建的空对象会有个(<em>proto</em>)属性指向方法参数，这样也可以构成一个原型链。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _ _proto__ 的内置属性，用于指向创建它的函数对象的原型对象 prototype</li>
<li>原型和原型链是 JS 实现继承的一种模型</li>
<li>原型链是靠 proto 形成的，而不是 prototype</li>
<li>所有的原型对象都有 constructor 属性，该属性对应创建所有指向该原型的实例构造函数</li>
<li>函数对象和原型对象通过 prototype 和 constructor 属性进行相互关联</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/03/如何监听页面 DOM 变动并高效响应/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/03/如何监听页面 DOM 变动并高效响应/" itemprop="url">
                  如何监听页面 DOM 变动并高效响应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="从-DOM-变动事件监听说起"><a href="#从-DOM-变动事件监听说起" class="headerlink" title="从 DOM 变动事件监听说起"></a>从 DOM 变动事件监听说起</h3><p>首先假设大家已经知道 JavaScript 中事件的发生阶段（捕获-命中-冒泡），附上一张图带过这个内容，我们直接进入寻找解决方法的过程。</p>
<p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt=""></p>
<p><em><a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" target="_blank" rel="external">Graphical representation of an event dispatched in a DOM tree using the DOM event flow</a></em></p>
<p>开始的时候我一直在 window 状态改变涉及到的事件中寻找，一圈搜寻下来发现也就 <code>onload</code> 事件最接近了，所以我们看看 MDN 对该事件的定义：</p>
<blockquote>
<p>The load event is fired when a resource and its dependent resources have finished loading.</p>
</blockquote>
<p>怎么理解资源及其依赖资源已加载完毕呢？简单来说，如果一个页面涉及到图片资源，那么 onload 事件会在页面完全载入（包括图片、css文件等等）后触发。一个简单的监听事件用 JavaScript 应该这样书写（注意不同环境下 load 和 onload 的差异）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"All resources finished loading!"</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="comment">// or</span></div><div class="line">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"All resources finished loading!"</span>);</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="comment">// HTML</span></div><div class="line">  &lt;body onload=<span class="string">"SomeJavaScriptCode"</span>&gt;</div><div class="line">  </div><div class="line">  <span class="comment">// jQuery</span></div><div class="line">  $( <span class="built_in">window</span> ).on( <span class="string">"load"</span>, handler )</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>当然，说到 <code>onload</code> 事件，有一个 jQuery 中相似的事件一定会被提及—— <code>ready</code> 事件。jQuery 中这样定义这个事件：</p>
<blockquote>
<p>Specify a function to execute when the DOM is fully loaded.</p>
</blockquote>
<p>需要知道的是 jQuery 定义的 <code>ready</code> 事件实质上是为 <code>DOMContentLoaded</code> 事件设计的，所以当我们谈论加载时应该区分的事件其实是 <code>onload</code>（接口 UIEvent） 以及 <code>DOMContentLoaded</code>（接口 Event），MDN 这样描述 <code>DOMContentLoaded</code>：</p>
<blockquote>
<p>当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。</p>
</blockquote>
<p>所以可以知道，当一个页面加载时应先触发 <code>DOMContentLoaded</code> 然后才是 <code>onload</code>. 类似的事件及区别包括以下几类：</p>
<ul>
<li><strong>DOMContentLoaded</strong>: 当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载；</li>
<li><strong>readystatechange</strong>: 一个document 的 Document.readyState 属性描述了文档的加载状态，当这个状态发生了变化，就会触发该事件；</li>
<li><strong>load</strong>: 当一个资源及其依赖资源已完成加载时，将触发load事件；</li>
<li><strong>beforeunload</strong>: 当浏览器窗口，文档或其资源将要卸载时，会触发beforeunload事件。</li>
<li><strong>unload</strong>: 当文档或一个子资源正在被卸载时, 触发 unload事件。</li>
</ul>
<p>细心点会发现上面在介绍事件时提到了 UIEvent 以及 Event，这是什么呢？这些都是事件——可以被 JavaScript 侦测到的行为。其他的事件接口还包括 KeyboardEvent ／ VRDisplayEvent （是的，没错，这就是你感兴趣且熟知的那个 VR）等等；如果在搜索引擎中稍加搜索，你会发现有些资料里写到事件可以分为以下几类：</p>
<ul>
<li>UI事件</li>
<li>焦点事件</li>
<li>鼠标与滚轮事件</li>
<li>键盘与文本事件</li>
<li>复合事件</li>
<li>变动事件</li>
<li>HTML5 事件</li>
<li>设备事件</li>
<li>触摸与手势事件</li>
</ul>
<p>但这样写实在有些凌乱，其中一些是 DOM3 定义的事件，有一些是单独列出的事件，如果你觉得熟悉那么你会发现这是 JavaScript 高级程序设计里的叙述模式，在我看来，理解这些事件可以按照 DOM3 事件以及其他事件来做区分：其中，DOM3 级事件规定了以下几类事件 - UI 事件, 焦点事件, 鼠标事件, 滚轮事件, 文本事件, 键盘事件, 合成事件, 变动事件, 变动名称事件; 而剩下的例如 HTML5 事件可以单独做了解。而刚开始提到的 Event 作为一个主要接口，是很多事件的实现父类。有关 Web API 接口可以在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="external">这里</a>查到，里面可以看到有很多 Event 字眼。</p>
<p>好吧，事件说了这么多，我们还是没有解决刚开始提出的问题，如果监听页面中动态生成的元素呢？想到动态生成的元素都是需要通过网络请求获取资源的，那么是否可以监听所有 HTTP 请求呢？查看 jQuery 文档可以知道每当一个Ajax请求完成，jQuery 就会触发 ajaxComplete 事件，在这个时间点所有处理函数会使用 .ajaxComplete() 方法注册并执行。但是谁能保证所有 ajax 都从 jQuery 走呢？所以应该在<strong>变动事件</strong>中做出选择，我们来看看 DOM2 定义的如下变动事件：</p>
<ul>
<li><strong>DOMSubtreeModified</strong>: 在DOM结构发生任何变化的时候。这个事件在其他事件触发后都会触发；</li>
<li><strong>DOMNodeInserted</strong>: 当一个节点作为子节点被插入到另一个节点中时触发；</li>
<li><strong>DOMNodeRemoved</strong>: 在节点从其父节点中移除时触发；</li>
<li><strong>DOMNodeInsertedIntoDocument</strong>: 在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在 DOMNodeInserted 之后触发；</li>
<li><strong>DOMNodeRemovedFromDocument</strong>: 在一个节点被直接从文档移除或通过子树间接从文档移除之前触发。这个事件在 DOMNodeRemoved 之后触发；</li>
<li><strong>DOMAttrModified</strong>: 在特性被修改之后触发；</li>
<li><strong>DOMCharacterDataModified</strong>: 在文本节点的值发生变化时触发；</li>
</ul>
<p>所以，用 DOMSubtreeModified 好像没错。师兄旁边提醒，用 <strong>MutationObserver</strong>, 于是又搜到了一个新大陆。MDN 这样描述 MutationObserver：</p>
<blockquote>
<p>MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</p>
</blockquote>
<p>DOM3 事件规范中的 Mutation 事件可以被简单看成是 DOM2 事件规范中定义的 Mutation 事件的一个扩展，但是这些都不重要了，因为他们都要被 MutationObserver 替代了。好了，那么来详细介绍一下 MutationObserver 吧。文章《<a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="external">Mutation Observer API</a>》对 MutationObserver 的用法介绍的比较详细，所以我挑几点能直接解决我们需求的说一说。</p>
<p>既然要监听 DOM 的变化，我们来看看 Observer 的作用都有哪些：</p>
<blockquote>
<p>它等待所有脚本任务完成后，才会运行，即采用异步方式。</p>
<p>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条地个别处理 DOM 变动。</p>
<p>它既可以观察发生在 DOM 的所有类型变动，也可以观察某一类变动。</p>
</blockquote>
<p>MutationObserver 的构造函数比较简单，传入一个回调函数即可（回调函数接受两个参数，第一个是变动数组，第二个是观察器实例）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</div></pre></td></tr></table></figure>
<p>观察器实例使用 <code>observe</code> 方法来监听， <code>disconnect</code> 方法停止监听，<code>takeRecords</code> 方法来清除变动记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> article = <span class="built_in">document</span>.body;</div><div class="line"></div><div class="line"><span class="keyword">let</span>  options = &#123;</div><div class="line">  <span class="string">'childList'</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">'attributes'</span>:<span class="literal">true</span></div><div class="line">&#125; ;</div><div class="line"></div><div class="line">observer.observe(article, options);</div></pre></td></tr></table></figure>
<p><code>observe</code> 方法中第一个参数是所要观察的变动 DOM 元素，第二个参数则接收所要观察的变动类型（子节点变动和属性变动）。变动类型包括以下几种：</p>
<ul>
<li>childList：子节点的变动。</li>
<li>attributes：属性的变动。</li>
<li>characterData：节点内容或节点文本的变动。</li>
<li>subtree：所有后代节点的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在 option 对象中指定它的值为 true。需要注意的是，如果设置观察 subtree 的变动，必须同时指定  childList、attributes 和 characterData 中的一种或多种。<code>disconnect</code> 方法和 <code>takeRecords</code> 方法则直接调用即可，无传入参数。</p>
<p>好的，我们已经搞定了 DOM 变动的监听，将代码刷新一下看下效果吧，因为页面由很多动态生成的商品组成，那么我应该在 body 上添加变动监听，所以 options 应该这样设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">	&apos;attributes&apos;: true,</div><div class="line">	&apos;subtree&apos;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咦？页面往下拉一小点就触发了 observer 几十次？这样 DOM 哪吃得消啊，查看了页面的变动记录发现每次新进的资源底层都调用了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore" target="_blank" rel="external">Node.insertBefore()</a> 方法…</p>
<h3 id="再聊聊-JavaScript-中的截流／节流函数"><a href="#再聊聊-JavaScript-中的截流／节流函数" class="headerlink" title="再聊聊 JavaScript 中的截流／节流函数"></a>再聊聊 JavaScript 中的截流／节流函数</h3><p>现在遇到的一个麻烦是， DOM 变动太频繁了，如果每次变动都监听那真是太耗费资源了。一个简单的解决办法是我就放弃监听了，而采用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" target="_blank" rel="external">setInterval</a> 方法定时执行更新逻辑。是的，虽然方法原始了一点，但是性能上比 Observer “改进”了不少。</p>
<p>这个时候，又来了师兄的助攻：“用用截流函数”。记起之前看《<a href="https://book.douban.com/subject/3590768/" target="_blank" rel="external">JavaScript 语言精粹</a>》的时候看到是用 <code>setTimeout</code> 方法自调用来解决 <code>setInteval</code> 的频繁执行吃资源的现象，不知道两者是不是有关联。网上一查发现有两个“jie流函数”。需求来自于这里：</p>
<blockquote>
<p>在前端开发中，页面有时会绑定scroll或resize事件等频繁触发的事件，也就意味着在正常的操作之内，会多次调用绑定的程序，然而有些时候javascript需要处理的事情特别多，频繁出发就会导致性能下降、成页面卡顿甚至是浏览器奔溃。</p>
</blockquote>
<p>如果重复利用 setTimeout 和 clearTimeout 方法，我们好像可以解决这个频繁触发的执行。每次事件触发的时候我首先判断一下当前有没有一个 setTimeout 定时器，如果有的话我们先将它清除，然后再新建一个 setTimeout 定时器来延迟我的响应行为。这样听上去还不错，因为我们每次都不立即执行我们的响应，而频繁触发过程我们又能保持响应函数一直存在（且只存在一个），除了会有些延迟响应外，没什么不好的。是的这就是<strong>截流函数（debounce）</strong>，有一篇<a href="http://www.cnblogs.com/ambar/archive/2011/10/08/throttle-and-debounce.html" target="_blank" rel="external">博客</a>用这个小故事介绍它：</p>
<blockquote>
<p>形像的比喻是橡皮球。如果手指按住橡皮球不放，它就一直受力，不能反弹起来，直到松手。debounce 的关注点是空闲的间隔时间。</p>
</blockquote>
<p>在我的业务中，在 observer 实例中调用下面写的这个截流函数就可以啦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* fn 执行函数</div><div class="line">* context 绑定上下文</div><div class="line">* timeout 延时数值</div><div class="line">**/</div><div class="line"><span class="keyword">let</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context, timeout</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> timer;</div><div class="line">    </div><div class="line">    <span class="comment">// 利用闭包将内容传递出去</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (timer) &#123;</div><div class="line">		    <span class="comment">// 清除定时器</span></div><div class="line">			clearTimeout(timer); </div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// 设置一个新的定时器</span></div><div class="line">		timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			fn.apply(context, <span class="built_in">arguments</span>)</div><div class="line">		&#125;, timeout);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，解决了自己的问题，但还有一个概念没有说到——“节流函数”。同一篇博文里也使用了一个例子来说明它：</p>
<blockquote>
<p>形像的比喻是水龙头或机枪，你可以控制它的流量或频率。throttle 的关注点是连续的执行间隔时间。</p>
</blockquote>
<p>函数节流的原理也挺简单，一样还是定时器。当我触发一个时间时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就清除原来的定时器，再setTimeout一个新的定时器延迟一会执行。函数节流的出发点，就是让一个函数不要执行得太频繁，减少一些过快的调用来节流。这里引用 <a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="external">AlloyTeam</a> 的节流代码实现来解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数同上</span></div><div class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay, mustRunDelay</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line"> <span class="keyword">var</span> t_start;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> 	<span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>, t_curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 清除定时器</span></div><div class="line"> 	clearTimeout(timer);</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 函数初始化判断</span></div><div class="line"> 	<span class="keyword">if</span>(!t_start)&#123;</div><div class="line"> 		t_start = t_curr;</div><div class="line"> 	&#125;</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 超时（指定的时间间隔）判断</span></div><div class="line"> 	<span class="keyword">if</span>(t_curr - t_start &gt;= mustRunDelay)&#123;</div><div class="line"> 		fn.apply(context, args);</div><div class="line"> 		t_start = t_curr;</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="keyword">else</span> &#123;</div><div class="line"> 		timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> 			fn.apply(context, args);</div><div class="line"> 		&#125;, delay);</div><div class="line"> 	&#125;</div><div class="line"> &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当然，AlloyTeam 那篇文章将这里所说的截流函数作为节流函数的 V1.0 版本，你也可以这样认为。毕竟，设置了必然触发执行的时间间隔（即 mustRunDelay 函数），可以使得截流函数不会在“疯狂事件”情况下无止境的循环下去。</p>
<p>Observer 和截流函数一结合，问题解决啦嘿嘿。当然还有很多坑，下次再开一篇说说吧。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/load" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Events/load</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></li>
<li><a href="http://www.cnblogs.com/fsjohnhuang/p/4147810.html" target="_blank" rel="external">http://www.cnblogs.com/fsjohnhuang/p/4147810.html</a></li>
<li><a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="external">http://www.alloyteam.com/2012/11/javascript-throttle/</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/02/一个故事讲完 Https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/02/一个故事讲完 Https/" itemprop="url">
                  一个故事讲完 Https
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T00:00:00+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想起上个月面试官问我了不了解 Https，当时对 HTTP 都不太熟的我只能说”No”。当我看完计算机网络教材的时候，又恰巧看见了微信公众号码农翻身的此篇推送，让我受益良多。</p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>今天来聊一聊https 安全传输的原理。</p>
<p>在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。</p>
<p>这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。</p>
<p>此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心……</p>
<p>张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 The Divided State of America ……</p>
<p>Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样…..</p>
<p>两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。</p>
<h2 id="总是有一种被偷看的感觉"><a href="#总是有一种被偷看的感觉" class="headerlink" title="总是有一种被偷看的感觉"></a>总是有一种被偷看的感觉</h2><p>有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。</p>
<p>张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了? 估计已经被人截取了吧！”</p>
<p>Bill 提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ”<br><img src="http://i1.buimg.com/1949/ade6db4481ac227a.png" alt="image"><br>张大胖冰雪聪明，一看就明白了， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！”</p>
<p>（码农翻身注：这叫对称加密算法， 因为加密和解密用的是同一个密钥）</p>
<p>一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！”</p>
<p>Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？”</p>
<p>张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？　</p>
<p>“奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？”　</p>
<p>“哈哈， 这倒是终极解决之道 ” Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ”</p>
<p>张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！</p>
<p>可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！</p>
<h2 id="RSA：非对称加密"><a href="#RSA：非对称加密" class="headerlink" title="RSA：非对称加密"></a>RSA：非对称加密</h2><p>Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的非对称加密算法，一下子来了灵感。</p>
<p>这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。</p>
<p>更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。<br><img src="http://i1.buimg.com/1949/5e8c39e7ca86956d.png" alt="image"><br>有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ）<br><img src="http://i1.buimg.com/1949/43e126b0647a1475.png" alt="image"><br>反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。</p>
<p>这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。</p>
<h2 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密+对称加密"></a>非对称加密+对称加密</h2><p>两人实验了几次， 张大胖说： “Bill , 你有没有感觉这个RSA的加密和解密有点慢啊？”</p>
<p>Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了”</p>
<p>“回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走　(1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信, 如何？ ”</p>
<p>Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。”　</p>
<p>于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！</p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>张大胖把和Bill 聊天的情况给老婆汇报了一次。</p>
<p>老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?”</p>
<p>张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。”</p>
<p>老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密，　那中间人不就可以解密看到消息了？＂</p>
<p>张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill , Bill和我根本都意识不到， 还以为我们在安全传输呢！</p>
<p><img src="http://i1.buimg.com/1949/a58bf0d069be1226.png" alt="image"></p>
<p>看来问题出现在公钥的分发上！ 虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！</p>
<h2 id="你到底是谁"><a href="#你到底是谁" class="headerlink" title="你到底是谁"></a>你到底是谁</h2><p>但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？</p>
<p>可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。</p>
<p>怎么声明呢？</p>
<p>张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。</p>
<p>这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！</p>
<p>这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！</p>
<p>可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？</p>
<p>张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。</p>
<p>天无绝人之路， 张大胖很快就找到了突破口： 数字签名。</p>
<p>简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。<br><img src="http://i1.buimg.com/1949/b1bb655d23b8c5cc.png" alt="image"><br>可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？”</p>
<p>张大胖说你别得意的太早 ， 我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名：<br><img src="http://i1.buimg.com/1949/38d3543e8ee28c6e.png" alt="image"><br>这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书”<br><img src="http://i1.buimg.com/1949/e7a1c438c1108a01.png" alt="image"><br>张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！</p>
<p>如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。</p>
<p>虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。<br><img src="http://i1.buimg.com/1949/495b3241682bbe98.png" alt="image"><br>中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？　难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？　如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。”</p>
<p>张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！</p>
<p>不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。</p>
<p>（公众号码农翻身注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。）</p>
<h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><p>终于可以介绍https了，前面已经介绍了https的原理， 你把张大胖替换成浏览器， 把Bill 替换成某个网站就行了。</p>
<p>一个简化的（例如下图没有包含Pre-Master Secret）https流程图是这样的， 如果你理解了前面的原理，这张图就变得非常简单：<br><img src="http://i1.buimg.com/1949/ecbc530393f88118.png" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/30/MasterPromise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/30/MasterPromise/" itemprop="url">
                  Master Promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T00:00:00+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"create a promise"</span></div><div class="line"><span class="string">"after new Promise"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>
<h2 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    resolve(<span class="number">2</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    reject(<span class="number">3</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1);</div><div class="line"><span class="built_in">console</span>.log(p2);</div><div class="line"><span class="built_in">console</span>.log(p3);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p2);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p3);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">2</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"rejected"</span>, [[PromiseValue]]: <span class="number">3</span>&#125;</div></pre></td></tr></table></figure></p>
<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h2 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success1"</span>);</div><div class="line">  resolve(<span class="string">"success2"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">  reject(<span class="string">"reject"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"success1"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(“success2”)并不能将p1的值更改为success2，p2中reject(“reject”)也不能将p2的状态由resolved改变为rejected.</p>
<h2 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="string">"resolve"</span></div><div class="line"><span class="string">"reject: reject"</span></div></pre></td></tr></table></figure></p>
<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li><strong>return</strong>  一个同步的值 ，或者 <strong>undefined</strong>（当没有返回一个有效值时，默认返回undefined），<strong>then</strong>方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li><strong>return</strong> 另一个 Promise，<strong>then</strong>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
</ul>
<p>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p>
<h2 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"which one is called first ?"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h2 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  foo.bar();</div><div class="line">  resolve( <span class="number">1</span> );      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve( <span class="number">2</span> );    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</div><div class="line">    foo.bar();</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p1 then err: <span class="built_in">ReferenceError</span>: foo is not defined</div><div class="line">p2 then value: <span class="number">2</span></div><div class="line">p1 then then value: <span class="literal">undefined</span></div><div class="line">p2 then then err: <span class="built_in">ReferenceError</span>: foo is not defined</div><div class="line">p2 then then then value: <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>Promise中的异常由<strong>then</strong>参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，<strong>then</strong>返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级<strong>then</strong>的回调函数是交替执行的 ，这正是由Promise <strong>then</strong>回调的异步性决定的。</p>
<h2 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</div><div class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(p1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1 === p2); </div><div class="line"><span class="built_in">console</span>.log(p1 === p3);</div><div class="line"><span class="built_in">console</span>.log(p1 === p4);</div><div class="line"><span class="built_in">console</span>.log(p3 === p4);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">false</span></div><div class="line">p2=<span class="number">1</span></div><div class="line">p1=<span class="number">1</span></div><div class="line">p4=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p><strong>Promise.resolve(…)</strong>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的<strong>then</strong>最先调用，但在控制台上是最后输出结果的呢？因为p4的<strong>resolve</strong>中接收的参数是一个Promise对象p1，<strong>resolve</strong>会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h2 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p3.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p3 rejected: [object <span class="built_in">Promise</span>]</div><div class="line">p1 fulfilled: resolve</div><div class="line">p2 rejected: reject</div></pre></td></tr></table></figure></p>
<p>Promise回调函数中的第一个参数<strong>resolve</strong>，会对Promise执行”拆箱”动作。即当<strong>resolve</strong>的参数是一个Promise对象时，<strong>resolve</strong>会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是<strong>resolved</strong>，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是<strong>rejected</strong>，因此<strong>rejected</strong>回调被执行。但Promise回调函数中的第二个参数<strong>reject</strong>不具备”拆箱“的能力，<strong>reject</strong>的参数会直接传递给<strong>then</strong>方法中的<strong>rejected</strong>回调。因此，即使p3 <strong>reject</strong>接收了一个<strong>resolved</strong>状态的Promise，<strong>then</strong>方法中被调用的依然是<strong>rejected</strong>，并且参数就是<strong>reject</strong>接收到的Promise对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/20/在浏览器地址栏输入url，按下回车后究竟发生了什么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/20/在浏览器地址栏输入url，按下回车后究竟发生了什么？/" itemprop="url">
                  在浏览器地址栏输入url,按下回车后究竟发生了什么?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T00:00:00+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h2><p>当你在浏览器地址栏输入一个URL后回车，将会发生的事情？这是一道经典的面试题，同时也是一道复杂的题目，涉及到很多东西，不同的软件开发者对于此道问题有不同的答案，对于其中的某一点也能无限深究，今天我们就来侧重于web前端来看一下究竟发生了什么。</p>
<h2 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h2><h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>①查询ip地址</p>
<p>②建立tcp连接，接入服务器</p>
<p>③浏览器发起http请求</p>
<p>④服务器后台操作并做出响应</p>
<p>⑤网页的解析与渲染</p>
<h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h2><h3 id="查询ip地址"><a href="#查询ip地址" class="headerlink" title="查询ip地址"></a>查询ip地址</h3><p>①浏览器解析出url中的域名。</p>
<p>②查询浏览器的DNS缓存。</p>
<p>③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。</p>
<p>④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。</p>
<p>⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。</p>
<p>⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。</p>
<h3 id="tcp连接与http连接"><a href="#tcp连接与http连接" class="headerlink" title="tcp连接与http连接"></a>tcp连接与http连接</h3><p>①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服。</p>
<p>②务器的稳定的通道。俗称TCP的三次握手。</p>
<p>③tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。</p>
<p>④http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</p>
<p>⑤服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</p>
<p>⑥文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</p>
<p>⑦经过网络传输，文件被下载到本地客户端，客户端开始加载。</p>
<h3 id="html渲染"><a href="#html渲染" class="headerlink" title="html渲染"></a>html渲染</h3><p>①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。</p>
<p>②遇到css文件，css中的url发起http请求。</p>
<p>③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。</p>
<p>④http连接是无状态连接，客户端与服务器端需要重新发起请求–响应。</p>
<p>在请求css的过程中，解析器继续解析html，然后到了script标签。</p>
<p>⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。</p>
<p>⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。</p>
<p>⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。</p>
<p>⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</p>
<p>⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</p>
<p>⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</p>
<p>⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</p>
<p>⑫DOM树遇到html结束标签，停止解析，进而渲染结束。</p>
<h2 id="4-扩展思考"><a href="#4-扩展思考" class="headerlink" title="4.扩展思考"></a>4.扩展思考</h2><h3 id="有那些网站优化的方法？"><a href="#有那些网站优化的方法？" class="headerlink" title="有那些网站优化的方法？"></a>有那些网站优化的方法？</h3><p>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p>
<p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p>
<p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p>
<p>④提前渲染开始时间：将css链接放在html头部。</p>
<p>⑤减轻解析器的阻塞：将js链接放在body尾部。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/15/2分钟学会数据mock，独立于后端开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/15/2分钟学会数据mock，独立于后端开发/" itemprop="url">
                  2分钟学会数据mock，独立于后端开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-15T12:47:44+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么说两分钟就能学会？ 因为你看完这篇文章只需要两分钟。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>相对于其他同类的框架的实现，mock.js超出了大家的意料。</li>
</ul>
<ol>
<li>基于 数据模板 生成模拟数据。</li>
<li>基于 HTML模板 生成模拟数据。</li>
<li>拦截并模拟 ajax 请求。</li>
</ol>
<ul>
<li>是的，mock.js只做上述的几件事，但做的足够出色。</li>
</ul>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>开发时，后端还没完成数据输出，前端只好写静态模拟数据。</p>
<ul>
<li>数据太长了，将数据写在js文件里，完成后挨个改url。</li>
<li>某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。</li>
<li>想要尽可能还原真实的数据，要么编写更多代码，要么手动修改模拟数据。</li>
<li>特殊的格式，例如IP,随机数，图片，地址，需要去收集。</li>
<li>超烂的破网速…</li>
<li>…</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装太简单，跳过</p>
<h2 id="mockjs基本语法"><a href="#mockjs基本语法" class="headerlink" title="mockjs基本语法"></a>mockjs基本语法</h2><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 属性名   name</span></div><div class="line"><span class="comment">// 生成规则 rule</span></div><div class="line"><span class="comment">// 属性值   value</span></div><div class="line"><span class="string">'name|rule'</span>: value</div><div class="line">注意：</div><div class="line"></div><div class="line">属性名 和 生成规则 之间用竖线 | 分隔。</div><div class="line">生成规则 是可选的。</div><div class="line">生成规则 有 <span class="number">7</span> 种格式：</div><div class="line"><span class="string">'name|min-max'</span>: value</div><div class="line"><span class="string">'name|count'</span>: value</div><div class="line"><span class="string">'name|min-max.dmin-dmax'</span>: value</div><div class="line"><span class="string">'name|min-max.dcount'</span>: value</div><div class="line"><span class="string">'name|count.dmin-dmax'</span>: value</div><div class="line"><span class="string">'name|count.dcount'</span>: value</div><div class="line"><span class="string">'name|+step'</span>: value</div><div class="line">生成规则 的 含义 需要依赖 属性值的类型 才能确定。</div><div class="line">属性值 中可以含有 @占位符。</div><div class="line">属性值 还指定了最终值的初始值和类型。</div></pre></td></tr></table></figure></p>
<h2 id="mockjs-官网"><a href="#mockjs-官网" class="headerlink" title="mockjs 官网"></a>mockjs 官网</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://mockjs.com/</div></pre></td></tr></table></figure>
<h2 id="配置模拟数据"><a href="#配置模拟数据" class="headerlink" title="配置模拟数据"></a>配置模拟数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mock.mock(<span class="string">'http://g.cn'</span>, &#123;</div><div class="line">    <span class="string">'name'</span>     : <span class="string">'@cname'</span>,</div><div class="line">    <span class="string">'age|1-100'</span>: <span class="number">100</span>,</div><div class="line">    <span class="string">'color'</span>    : <span class="string">'@color'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="发送ajax请求-jquery版"><a href="#发送ajax请求-jquery版" class="headerlink" title="发送ajax请求(jquery版)"></a>发送ajax请求(jquery版)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">'http://g.cn'</span>,</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(</div><div class="line">        <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">4</span>)</div><div class="line">    )    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="查看响应的结果"><a href="#查看响应的结果" class="headerlink" title="查看响应的结果"></a>查看响应的结果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 结果1</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"Elizabeth Hall"</span>,</div><div class="line">    <span class="string">"age"</span>: <span class="number">91</span>,</div><div class="line">    <span class="string">"color"</span>: <span class="string">"#0e64ea"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果2</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"Michael Taylor"</span>,</div><div class="line">    <span class="string">"age"</span>: <span class="number">61</span>,</div><div class="line">    <span class="string">"color"</span>: <span class="string">"#081086"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果N ..</span></div></pre></td></tr></table></figure>
<h3 id="数据模板用法"><a href="#数据模板用法" class="headerlink" title="数据模板用法"></a>数据模板用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin/a1'</span>: &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">msg</span>: <span class="string">'成功'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;&#125;,</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'/admin/a2'</span>: &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">msg</span>: <span class="string">'成功'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'@cname'</span>,</div><div class="line">            <span class="attr">address</span>: <span class="string">'@province'</span>,</div><div class="line">            <span class="attr">email</span>: <span class="string">'@email'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin/a2'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'%s'</span>, <span class="string">'这是a2'</span>, data)</div><div class="line">    &#125;);</div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin/a1'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'%s'</span>, <span class="string">'这是a1'</span>, data)</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h2 id="高级用法（根据请求方法来返回数据）"><a href="#高级用法（根据请求方法来返回数据）" class="headerlink" title="高级用法（根据请求方法来返回数据）"></a>高级用法（根据请求方法来返回数据）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (req.type === <span class="string">'GET'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"接到get请求"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.type === <span class="string">'POST'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">'接到post请求'</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'post'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h3 id="高级用法（根据请求参数来返回数据）"><a href="#高级用法（根据请求参数来返回数据）" class="headerlink" title="高级用法（根据请求参数来返回数据）"></a>高级用法（根据请求参数来返回数据）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> param = str2obj(req.body);</div><div class="line">        <span class="keyword">if</span> (param.type === <span class="string">'1'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是1"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.type === <span class="string">'2'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是2"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2obj</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/ig</span>;</div><div class="line">    str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">        obj[b] = c;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'post'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">type</span>: <span class="number">2</span>,</div><div class="line">            <span class="attr">status</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h2 id="高级用法（特殊处理get请求）"><a href="#高级用法（特殊处理get请求）" class="headerlink" title="高级用法（特殊处理get请求）"></a>高级用法（特殊处理get请求）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(req)</div><div class="line">        <span class="keyword">var</span> param = str2obj(req.url);</div><div class="line">        <span class="keyword">if</span> (param.type === <span class="string">'1'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是1"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.type === <span class="string">'2'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是2"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2obj</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/ig</span>;</div><div class="line">    str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">        obj[b] = c;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        <span class="keyword">var</span> url = <span class="keyword">new</span> <span class="built_in">RegExp</span>(key);</div><div class="line">        Mock.mock(url, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'get'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">type</span>: <span class="number">2</span>,</div><div class="line">            <span class="attr">status</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/09/react为什么需要key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/09/react为什么需要key/" itemprop="url">
                  react为什么需要key
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T00:00:00+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多个react组件性能优化"><a href="#多个react组件性能优化" class="headerlink" title="多个react组件性能优化"></a>多个react组件性能优化</h2><h3 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h3><ol>
<li><p>当一个react组件被装载、更新和卸载时，组件的一系列生命周期函数会被调用。不过这些生命周期函数是针对某一个特定的react组件的函数，在一个应用中，从上到下有很多react组件组合起来，它们之间的渲染过程更加复杂。</p>
</li>
<li><p>其中，装载阶段基本上没有什么选择，当一个react组件第一次出现在DOM树中时，无论如何都是要彻底渲染一次的，从这个react组件往下的所有子组件，都要经历一遍react组件的装载生命周期，因为这部分的的工作没有什么可以省略的，所以没有多少性能优化的事情可以做。</p>
</li>
<li><p>至于卸载阶段，只有一个生命周期函数 <strong>componentWillUnmount</strong>，这个函数做的事情知识清理 <strong>componentDidMount</strong> 添加的事件处理监听等收尾工作，做的事情比装载过程要少很多，所以也没什么可以优化的空间。</p>
</li>
<li><p>所以值得关注的过程，就只剩下了更新过程。</p>
</li>
</ol>
<h3 id="1-2-react的调和-reconciliation-过程"><a href="#1-2-react的调和-reconciliation-过程" class="headerlink" title="1.2 react的调和(reconciliation)过程"></a>1.2 react的调和(reconciliation)过程</h3><p>react在更新阶段很巧妙地对比原有的 <strong>Virtual DOM</strong> 和新生成的 <strong>Virtual DOM</strong> ,找出两者的不同之处，根据不同来修改DOM树，这样只需要做做小的必要改动。react在更新这个“找不同”的过程，就叫做(reconciliation)过程。</p>
<h3 id="1-3-react的算法时间复杂度"><a href="#1-3-react的算法时间复杂度" class="headerlink" title="1.3 react的算法时间复杂度"></a>1.3 react的算法时间复杂度</h3><ol>
<li>Facebook推出的react之初打出的旗号之一就是“高性能”，所以react的(reconciliation)过程必须快速。但是，找出两个树形结构的区别，从计算机科学的角度来说，真的不是一件快速的事。</li>
<li>按照计算机科学目前的算法研究结果，对比两个N个节点的树形结构的算法，时间复杂度是 <strong>O(N^3)</strong>,打个比方，假如两个树形结构上各有100节点，那么找出这两个树形结构差别的操作，需要100*100*100次操作，也就是一百万次当量的操作，假如有一千个节点，那么需要相当于1000*1000*1000次操作，这是一亿次的操作当量，这么巨大数量的操作在强调快速反应的网页中是不可想象的，所以react不可能采用这样的算法。</li>
<li>react实际采用的算法需要的时间复杂度是 <strong>O(N)</strong> ，因为对比两个树形怎么着都要对比两个树形上的节点，似乎也不可能有比 <strong>O(N)</strong> 时间复杂度更低的算法。react采用的算法肯定不是最精准的，但是对于react英语的场景来说，绝对是性能和复杂度的最好折衷，让这个算法发挥作用，还需要开发者一点配合。</li>
<li>其实，react的reconciliation算法并不是很复杂，当react要对比两个 <strong>Virtual DOM</strong> 的树形结构的时候，从根节点开始递归往下比对，在树形结构上，每个阶段都可以看做一个这个阶段以下部分子树的根节点。所以其实这个对比算法可以从 <strong>Virtual DOM</strong> 上任何一个节点开始执行。</li>
</ol>
<h3 id="1-4-react检查两个树形结构的根节点的不同处理方式"><a href="#1-4-react检查两个树形结构的根节点的不同处理方式" class="headerlink" title="1.4 react检查两个树形结构的根节点的不同处理方式"></a>1.4 react检查两个树形结构的根节点的不同处理方式</h3><ol>
<li>节点类型不同的情况</li>
</ol>
<p>如果树形结构的根节点类型不相同，那就意味着改动太大了，也不需要去费心考虑是不是原来那个树形的根节点被移动到其他地方去了，直接认为原来那个树形结构会已经没用，可以扔掉，需要重新构建新的DOM树，原有的树形结构上的react组件都会经历“卸载”的生命周期。也就是，对于 <strong>Virtual DOM</strong> 树这是一个“更新”的过程，但是却可能引发这个树形结构上某些组件的“装载”和“卸载”过程。例如，在更新之前，组件的结构是这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todos</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们想要更新成这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todos</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么react会认为要废掉之前的div节点，包括下面的所有的子节点，一切推到重新来，重新构建一个span节点以及其子节点。看似浪费，但是为了避免 <strong>O(N^3)</strong> 的时间复杂度，react必须要选一个更简单更快的算法，也就只能用这种方式。</p>
<p>作为开发者，很显然要避免作为包裹功能的节点类型被随意改变。</p>
<ol>
<li>节点类型相同的情况</li>
</ol>
<p>如果两个树形结构的根节点类型相同，react就会认为原来的根节点只需要更新过程，不会将其卸载，也不会引发根节点的重新装载。这时候要区分一下节点类型。节点可以分为两类：一类是DOM元素类型对应的就是HTML直接支持的元素类型，比如div,span,p。另一类是react组件，也就是利用react库订制的类型。</p>
<p>对于DOM类型，react会保留节点对应的DOM元素，支队树形结构根节点上的树形和内容做一下对比，然后只更新修改的部分。<br>比如原来的jsx表示是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&#123;&#123;color:&quot;red&quot;,fontSize:16&#125;&#125; className=&quot;welcome&quot;&gt;</div><div class="line">    hello</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>改变后jsx表示是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&#123;&#123;color:&quot;green&quot;,fontSize:16&#125;&#125; className=&quot;farewell&quot;&gt;</div><div class="line">    good bye</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这两个的差别就是颜色和className发生了改变，在操作DOM树节点的时候，只修改这些发生变化的部分，让DOM操作尽可能少。</p>
<p>如果树形结构的根节点不是DOM元素类型，react所做的工作类似，只是react不知道如何去更新DOM树，因为这些逻辑还在react组件之中，react能做的只是根据新节点的props去更新原来根节点的组件实例，引发这个组件的实例的更新过程。也就会触发react更新阶段的生命周期函数，这个过程中，如果 <strong>shouldComponentUpdate</strong> 返回false。更新就会停止。</p>
<ol>
<li>多个子组件的情况</li>
</ol>
<p>当一个组件包含多个子组件的情况，react的处理方式也非常简单的直接。例如最初组件形态用jsx表示是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>更新之后，jsx表示是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;third&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>这种情况react的更新过程，只要 <strong>shouldComponentUpdate</strong> 使用恰当，可以避免实质性的更新操作。</p>
<p>但是，在序列前面增加一个 TodoItem实例的时候。需要更新后的形态jsx表示为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;zero&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>这种情况下，react会首先认为把text为first的组件实例的text改为zero，text为second的组件实例的text改为first，最后增加一个一个实例，text为second。这种情况下，<strong>shouldComponentUpdate</strong> 也无法判断是否返回false。想要增加一个组件实例，却引发了另外两个组件的更新。</p>
<p>这种情况，react的key就凸显出作用了。react通过这个key就能判断每一个组件在组件序列中的位置了。</p>
<p>上面的情况变为，最初形态为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem key=&#123;1&#125; text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;2&#125; text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>新增组件的时候,形态为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem key=&#123;0&#125; text=&quot;zero&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;1&#125; text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;2&#125; text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>react就知道把组件插在组件序列的第一位了。对原有的两个组件，只用props来启用更新过程，_shouldComponentUpdate__ 就能根据key来判断是否返回false来中断更新了，避免无用的更新操作了。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>所以，碰到数组-&gt;列表的映射，或是同级元素需要移位的情况，一定要给元素加上key属性！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="赖宝" />
          <p class="site-author-name" itemprop="name">赖宝</p>
           
              <p class="site-description motion-element" itemprop="description">努力学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖宝</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
