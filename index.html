<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="努力学习">
<meta property="og:type" content="website">
<meta property="og:title" content="赖宝的宝">
<meta property="og:url" content="http://blog.webtoatl.cn/index.html">
<meta property="og:site_name" content="赖宝的宝">
<meta property="og:description" content="努力学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赖宝的宝">
<meta name="twitter:description" content="努力学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.webtoatl.cn/"/>





  <title> 赖宝的宝 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖宝的宝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端技能分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/08/JavaScript 专题之如何判断两个对象相等/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/08/JavaScript 专题之如何判断两个对象相等/" itemprop="url">
                  JavaScript 专题之如何判断两个对象相等
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T00:00:00+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然标题写的是如何判断两个对象相等，但本篇我们不仅仅判断两个对象相等，实际上，我们要做到的是如何判断两个参数相等，而这必然会涉及到多种类型的判断。</p>
<h2 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h2><p>什么是相等？，我们认为只要 === 的结果为 true，两者就相等，然而今天我们重新定义相等：</p>
<p>我们认为：</p>
<p>NaN 和 NaN 是相等<br>[1] 和 [1] 是相等<br>{value: 1} 和 {value: 1} 是相等<br>不仅仅是这些长得一样的，还有</p>
<p>1 和 new Number(1) 是相等<br>‘Curly’ 和 new String(‘Curly’) 是相等<br>true 和 new Boolean(true) 是相等<br>更复杂的我们会在接下来的内容中看到。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们的目标是写一个 eq 函数用来判断两个参数是否相等，使用效果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>];</div><div class="line"><span class="built_in">console</span>.log(eq(a, b)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>在写这个看似很简单的函数之前，我们首先了解在一些简单的情况下是如何判断的？</p>
<h2 id="0-与-0"><a href="#0-与-0" class="headerlink" title="+0 与 -0"></a>+0 与 -0</h2><p>如果 a === b 的结果为 true， 那么 a 和 b 就是相等的吗？一般情况下，当然是这样的，但是有一个特殊的例子，就是 +0 和 -0。</p>
<p>JavaScript “处心积虑”的想抹平两者的差异：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 表现1</span></div><div class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 表现2</span></div><div class="line">(<span class="number">-0</span>).toString() <span class="comment">// '0'</span></div><div class="line">(+<span class="number">0</span>).toString() <span class="comment">// '0'</span></div><div class="line"></div><div class="line"><span class="comment">// 表现3</span></div><div class="line"><span class="number">-0</span> &lt; +<span class="number">0</span> <span class="comment">// false</span></div><div class="line">+<span class="number">0</span> &lt; <span class="number">-0</span> <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>即便如此，两者依然是不同的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> / +<span class="number">0</span> <span class="comment">// Infinity</span></div><div class="line"><span class="number">1</span> / <span class="number">-0</span> <span class="comment">// -Infinity</span></div><div class="line"></div><div class="line"><span class="number">1</span> / +<span class="number">0</span> === <span class="number">1</span> / <span class="number">-0</span> <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>也许你会好奇为什么要有 +0 和 -0 呢？</p>
<p>这是因为 JavaScript 采用了IEEE_754 浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，按照这个标准，最高位是符号位(0 代表正，1 代表负)，剩下的用于表示大小。而对于零这个边界值 ，1000(-0) 和 0000(0)都是表示 0 ，这才有了正负零的区别。</p>
<p>也许你会好奇什么时候会产生 -0 呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.round(-0.1) // -0</div></pre></td></tr></table></figure></p>
<p>那么我们又该如何在 === 结果为 true 的时候，区别 0 和 -0 得出正确的结果呢？我们可以这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>在本篇，我们认为 NaN 和 NaN 是相等的，那又该如何判断出 NaN 呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>利用 NaN 不等于自身的特性，我们可以区别出 NaN，那么这个 eq 函数又该怎么写呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="eq-函数"><a href="#eq-函数" class="headerlink" title="eq 函数"></a>eq 函数</h2><p>现在，我们已经可以去写 eq 函数的第一版了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// eq 第一版</span></div><div class="line"><span class="comment">// 用来过滤掉简单的类型比较，复杂的对象使用 deepEq 函数进行处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// === 结果为 true 的区别出 +0 和 -0</span></div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line"></div><div class="line">    <span class="comment">// typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断 NaN</span></div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line"></div><div class="line">    <span class="comment">// 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false</span></div><div class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</div><div class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更复杂的对象使用 deepEq 函数进行深度比较</span></div><div class="line">    <span class="keyword">return</span> deepEq(a, b);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>也许你会好奇是不是少了一个 <strong>typeof b !== function</strong>?<br>试想如果我们添加上了这句，当 a 是基本类型，而 b 是函数的时候，就会进入 deepEq 函数，而去掉这一句，就会进入直接进入 false，实际上 基本类型和函数肯定是不会相等的，所以这样做代码又少，又可以让一种情况更早退出。</p>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><p>现在我们开始写 deepEq 函数，一个要处理的重大难题就是 ‘Curly’ 和 new String(‘Curly’) 如何判断成相等？</p>
<p>两者的类型都不一样呐！不信我们看 typeof 的操作结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'Curly'</span>); <span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>)); <span class="comment">// object</span></div></pre></td></tr></table></figure></p>
<p>可是我们还有更多的方法判断类型，比如 Object.prototype.toString：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line">toString.call(<span class="string">'Curly'</span>); <span class="comment">// "[object String]"</span></div><div class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>)); <span class="comment">// "[object String]"</span></div></pre></td></tr></table></figure></p>
<p>神奇的是使用 toString 方法两者判断的结果却是一致的，可是就算知道了这一点，还是不知道如何判断字符串和字符串包装对象是相等的呢？</p>
<p>那我们利用隐式类型转换呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Curly'</span> + <span class="string">''</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>) + <span class="string">''</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>看来我们已经有了思路：如果 a 和 b 的 Object.prototype.toString的结果一致，并且都是”[object String]”，那我们就使用 ‘’ + a === ‘’ + b 进行判断。</p>
<p>可是不止有 String 对象呐，Boolean、Number、RegExp、Date呢？</p>
<h2 id="更多对象"><a href="#更多对象" class="headerlink" title="更多对象"></a>更多对象</h2><p>跟 String 同样的思路，利用隐式类型转换。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="regexp">/a/i</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/i</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">''</span> + a === <span class="string">''</span> + b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>嗯哼？你确定 Number 能这么简单的判断？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>可是 a 和 b 应该被判断成 true 的呐~</p>
<p>那么我们就改成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断 Number(NaN) Object(NaN) 等情况</span></div><div class="line">    <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">    <span class="comment">// 其他判断 ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="deepEq-函数"><a href="#deepEq-函数" class="headerlink" title="deepEq 函数"></a>deepEq 函数</h2><p>现在我们可以写一点 deepEq 函数了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> className = toString.call(a);</div><div class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (className) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object String]'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</div><div class="line">            <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">            <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</div><div class="line">      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</div><div class="line">      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</div><div class="line">            <span class="keyword">return</span> +a === +b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其他判断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="构造函数实例"><a href="#构造函数实例" class="headerlink" title="构造函数实例"></a>构造函数实例</h2><p>我们看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Kevin'</span>);</div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Kevin'</span>);</div><div class="line"></div><div class="line">eq(person, animal) <span class="comment">// ???</span></div></pre></td></tr></table></figure></p>
<p>虽然 <strong>person</strong> 和 <strong>animal</strong> 都是 <strong>{name: ‘Kevin’}</strong>，但是 <strong>person</strong> 和 <strong>animal</strong> 属于不同构造函数的实例，为了做出区分，我们认为是不同的对象。</p>
<p>如果两个对象所属的构造函数对象不同，两个对象就一定不相等吗？</p>
<p>并不一定，我们再举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attrs = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">attrs.name = <span class="string">"Bob"</span>;</div><div class="line">eq(attrs, &#123;<span class="attr">name</span>: <span class="string">"Bob"</span>&#125;); <span class="comment">// ???</span></div></pre></td></tr></table></figure></p>
<p>尽管 <strong>attrs</strong> 没有原型，<strong>{name: “Bob”}</strong> 的构造函数是 <strong>Object</strong>，但是在实际应用中，只要他们有着相同的键值对，我们依然认为是相等。</p>
<p>从函数设计的角度来看，我们不应该让他们相等，但是从实践的角度，我们让他们相等，所以相等就是一件如此随意的事情吗？！对啊，我也在想：<strong>undersocre</strong>，你怎么能如此随意呢！！！</p>
<p>哎，吐槽完了，我们还是要接着写这个相等函数，我们可以先做个判断，对于不同构造函数下的实例直接返回 <strong>false</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Function]'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 接着上面的内容</span></div><div class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</div><div class="line">    <span class="comment">// 不是数组</span></div><div class="line">    <span class="keyword">if</span> (!areArrays) &#123;</div><div class="line">        <span class="comment">// 过滤掉两个函数的情况</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</div><div class="line">        <span class="comment">// aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦</span></div><div class="line">        <span class="keyword">if</span> (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下面还有好多判断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组相等"><a href="#数组相等" class="headerlink" title="数组相等"></a>数组相等</h2><p>现在终于可以进入我们期待已久的数组和对象的判断，不过其实这个很简单，就是递归遍历一遍……<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 再接着上面的内容</span></div><div class="line">    <span class="keyword">if</span> (areArrays) &#123;</div><div class="line"></div><div class="line">        length = a.length;</div><div class="line">        <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            <span class="keyword">if</span> (!eq(a[length], b[length])) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">         &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a), key;</div><div class="line">        length = keys.length;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            key = keys[length];</div><div class="line">            <span class="keyword">if</span> (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key]))) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>如果觉得这就结束了，简直是太天真，因为最难的部分才终于要开始，这个问题就是循环引用！</p>
<p>举个简单的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="attr">abc</span>: <span class="literal">null</span>&#125;;</div><div class="line">b = &#123;<span class="attr">abc</span>: <span class="literal">null</span>&#125;;</div><div class="line">a.abc = a;</div><div class="line">b.abc = b;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>再复杂一点的，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="attr">foo</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">foo</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">foo</span>: <span class="literal">null</span>&#125;&#125;&#125;&#125;&#125;;</div><div class="line">b = &#123;<span class="attr">foo</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">foo</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">foo</span>: <span class="literal">null</span>&#125;&#125;&#125;&#125;&#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>为了给大家演示下循环引用，大家可以把下面这段已经精简过的代码复制到浏览器中尝试：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// demo</span></div><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a === b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> deepEq(a, b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a);</div><div class="line">    <span class="keyword">var</span> length = keys.length;</div><div class="line">    <span class="keyword">var</span> key;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        key = keys[length]</div><div class="line"></div><div class="line">        <span class="comment">// 这是为了让你看到代码其实一直在执行</span></div><div class="line">        <span class="built_in">console</span>.log(a[key], b[key])</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!eq(a[key], b[key])) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>嗯，以上的代码是死循环。</p>
<p>那么，我们又该如何解决这个问题呢？underscore 的思路是 eq 的时候，多传递两个参数为 aStack 和 bStack，用来储存 a 和 b 递归比较过程中的 a 和 b 的值，咋说的这么绕口呢？<br>我们直接看个精简的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a === b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    aStack = aStack || [];</div><div class="line">    bStack = bStack || [];</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = aStack.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        <span class="keyword">if</span> (aStack[length] === a) &#123;</div><div class="line">              <span class="keyword">return</span> bStack[length] === b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.push(a);</div><div class="line">    bStack.push(b);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a);</div><div class="line">    <span class="keyword">var</span> length = keys.length;</div><div class="line">    <span class="keyword">var</span> key;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        key = keys[length]</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(a[key], b[key], aStack, bStack)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!eq(a[key], b[key], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// aStack.pop();</span></div><div class="line">    <span class="comment">// bStack.pop();</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b))</div></pre></td></tr></table></figure></p>
<p>之所以注释掉 <strong>aStack.pop()</strong>和<strong>bStack.pop()</strong>这两句，是为了方便大家查看 <strong>aStack</strong>  <strong>bStack</strong>的值。</p>
<h2 id="最终的-eq-函数"><a href="#最终的-eq-函数" class="headerlink" title="最终的 eq 函数"></a>最终的 eq 函数</h2><p>最终的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Function]'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// === 结果为 true 的区别出 +0 和 -0</span></div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line"></div><div class="line">    <span class="comment">// typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断 NaN</span></div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line"></div><div class="line">    <span class="comment">// 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false</span></div><div class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</div><div class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更复杂的对象使用 deepEq 函数进行深度比较</span></div><div class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// a 和 b 的内部属性 [[class]] 相同时 返回 true</span></div><div class="line">    <span class="keyword">var</span> className = toString.call(a);</div><div class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (className) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object String]'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</div><div class="line">            <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">            <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</div><div class="line">            <span class="keyword">return</span> +a === +b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</div><div class="line">    <span class="comment">// 不是数组</span></div><div class="line">    <span class="keyword">if</span> (!areArrays) &#123;</div><div class="line">        <span class="comment">// 过滤掉两个函数的情况</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> aCtor = a.constructor,</div><div class="line">            bCtor = b.constructor;</div><div class="line">        <span class="comment">// aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦</span></div><div class="line">        <span class="keyword">if</span> (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    aStack = aStack || [];</div><div class="line">    bStack = bStack || [];</div><div class="line">    <span class="keyword">var</span> length = aStack.length;</div><div class="line"></div><div class="line">    <span class="comment">// 检查是否有循环引用的部分</span></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        <span class="keyword">if</span> (aStack[length] === a) &#123;</div><div class="line">            <span class="keyword">return</span> bStack[length] === b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.push(a);</div><div class="line">    bStack.push(b);</div><div class="line"></div><div class="line">    <span class="comment">// 数组判断</span></div><div class="line">    <span class="keyword">if</span> (areArrays) &#123;</div><div class="line"></div><div class="line">        length = a.length;</div><div class="line">        <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            <span class="keyword">if</span> (!eq(a[length], b[length], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对象判断</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a),</div><div class="line">            key;</div><div class="line">        length = keys.length;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line"></div><div class="line">            key = keys[length];</div><div class="line">            <span class="keyword">if</span> (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.pop();</div><div class="line">    bStack.pop();</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="built_in">Number</span>(<span class="literal">NaN</span>), <span class="built_in">Number</span>(<span class="literal">NaN</span>))); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="string">'Curly'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>))); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq([<span class="number">1</span>], [<span class="number">1</span>])); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;)); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>真让人感叹一句：eq 不愧是 underscore 中实现代码行数最多的函数了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/08/HTTP Header 详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/08/HTTP Header 详解/" itemprop="url">
                  HTTP Header 详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T00:00:00+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTP（HyperTextTransferProtocol）即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message- header，即http header消息 。http header 消息通常被分为4个部分：general  header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。</p>
<h2 id="Requests部分"><a href="#Requests部分" class="headerlink" title="Requests部分"></a>Requests部分</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: user@email.com</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: www.zcmhi.com</td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="external">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2 id="Responses-部分"><a href="#Responses-部分" class="headerlink" title="Responses 部分"></a>Responses 部分</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/03/JavaScript的原型及原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/03/JavaScript的原型及原型链/" itemprop="url">
                  JavaScript的原型及原型链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 javascript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ 一文中我们提到了在没有类概念的 JavaScript 语言中是通过原型来实现面向对象的继承特性。只要运用得好，这种基于原型的 JavaScript 继承模型比传统的类继承还要强大。所以我们还需详细学习一下原型的知识</p>
<h2 id="JavaScript-的对象"><a href="#JavaScript-的对象" class="headerlink" title="JavaScript 的对象"></a>JavaScript 的对象</h2><p>JavaScript 是基于对象的面向对象语言。因此在这里的“对象”既可以是普通对象（Object），也可以是函数对象（Function）。JS 抛弃了 Java 的类概念，而 Java 的继承恰恰是通过类来实现的。那么 JS 没有类的概念，就使用了“原型”的概念来实现继承。</p>
<h3 id="字面量原型及原型链"><a href="#字面量原型及原型链" class="headerlink" title="字面量原型及原型链"></a>字面量原型及原型链</h3><p>JS 可通过字面量构造对象。为了实现继承，对象里面有个<em>proto</em>属性可以指向该对象的父对象。这个父对象就是所谓的“原型”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animal = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'动物'</span>,</div><div class="line">  <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" is eating"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">animal.eat();     <span class="comment">// animal is eating</span></div><div class="line"><span class="keyword">var</span> dog = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'狗'</span>,</div><div class="line">  <span class="attr">_proto_</span>: animal</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> cat = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'猫'</span>,</div><div class="line">  <span class="attr">_proto_</span>: animal</div><div class="line">&#125;;</div><div class="line">dog.eat();        <span class="comment">// 狗 is eating</span></div><div class="line">cat.eat();        <span class="comment">// 猫 is eating</span></div></pre></td></tr></table></figure>
<p>由上面代码我们可以看出：dog 和 cat 对象的原型都是 animal。但是 dog 和 cat 对象都没有定义 eat()方法，那怎么可以调用呢？其实当eat方法被调用的时候，先在自己的方法列表中寻找， 如果找不到，就去找原型中的方法， 如果原型中找不到， 就去原型的原型中去寻找…… 最后找到Object那里， 如果还找不到， 那就是未定义了。这几个对象通过<em>proto</em>属性建立一个原型链！<br><img src="http://ww1.sinaimg.cn/large/7b6c9535gy1fhwi3i5lirj20gt0f8dif.jpg" alt="image"></p>
<h2 id="构造函数原型及原型链"><a href="#构造函数原型及原型链" class="headerlink" title="构造函数原型及原型链"></a>构造函数原型及原型链</h2><p>但是为了迁就 C++、Java、C# 程序员，让 JavaScript 可以像 Java 那样 new （构造）出一个对象出来，于是这里做了一个变通，也提供了构造函数。例子如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Student(name,grade)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.grade = grade;</div><div class="line">  this.sayHello = function()&#123;</div><div class="line">    console.log('Hi,I'm ' + this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">andy = new Student('Andy',5);</div><div class="line">lisa = new Student('Lisa',5);</div><div class="line">andy.sayHello();    //Hi,I'm Andy</div><div class="line">lisa.sayHello();    //Hi,I'm Lisa</div><div class="line">    </div><div class="line">//假设 andy 和 lisa 是同班同学，同时即将升入六年级</div><div class="line">andy.grade = 6;</div><div class="line">console.log(andy.grade);   // 6</div><div class="line">console.log(lisa.grade);   // 5</div></pre></td></tr></table></figure></p>
<p>由上面的代码所示，我们可以看出这个所谓的构造函数已经很有 Java 类的感觉了。但是这里面存在两个问题：在对象里面定义方法，这样每创建一个对象都会一个sayHello()函数，这样来说显得对象臃肿，浪费资源；同时每个对象各自保有自己的属性和函数的副本，无法做到属性和方法共享。因此，这里有一个更加高效的办法就是把对象共享的属性和方法可以放到 Student.prototype 这个对象当中。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Student.prototype = &#123;</div><div class="line">  <span class="attr">grade</span>: <span class="number">5</span>,</div><div class="line">  <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I'm "</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/*也可以写成</span></div><div class="line">Student.prototype.grade = 5;</div><div class="line">Student.prototype.sayHello = function()&#123;</div><div class="line">  console.log("Hi, I'm "+this.name);</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> Student(<span class="string">"Andy"</span>);</div><div class="line"><span class="keyword">var</span> lisa = <span class="keyword">new</span> Student(<span class="string">"Lisa"</span>);</div><div class="line">andy.sayHello();      <span class="comment">//Hi, I'm Andy</span></div><div class="line">lisa.sayHello();      <span class="comment">//Hi, I'm Lisa</span></div><div class="line">Student.prototype.grade = <span class="number">6</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Andy's grade: "</span>+ andy.grade);    <span class="comment">// 6</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Lisa's grade: "</span>+ Lisa.grade);    <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/7b6c9535gy1fi6yabvn3vj20rn0ogdhf.jpg" alt="image"><br>由上面的代码和示意图可看出这个所谓的构造函数 Student 其实就是一个幌子啊， 每次去new Student的时候，确实会创建一个对象出来（ andy 或者 lisa ) ， 并且把这个对象的原型指针(<em>proto</em>)指向 Student.prototype 这个对象，这样一来就能找到sayHello()方法了。我们应该还知道上面的构造函数Student()对象（JS 中函数也是对象）会创建一个 prototype 对象（Student.prototype），而 new 出来的实例对象例如 andy 和 lisa 是没有这个 prototype 对象，但是他会有个 proto 属性（<em>proto</em>）指向这个构造函数对象的 prototype 对象，从而构成原型链。实例对象其实是通过原型对象与构造函数取得联系的。为了让 Java、C#、C++ 程序员降低学习成本，JavaScript 提供了语法糖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">  sayHello()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I'm "</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> Student(<span class="string">"andy"</span>);   </div><div class="line">andy.sayHello();                     <span class="comment">//Hi, I'm andy</span></div></pre></td></tr></table></figure></p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="built_in">console</span>.log(a);                 <span class="comment">//&#123;&#125;</span></div><div class="line">a.name = <span class="string">'Zhiyu'</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="built_in">console</span>.log(b);                 <span class="comment">//&#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b.name);            <span class="comment">//Zhiyu</span></div></pre></td></tr></table></figure>
<p>上面我们可以看出该方法是创建一个空对象，空对象的原型是create()参数。此时创建的空对象会有个(<em>proto</em>)属性指向方法参数，这样也可以构成一个原型链。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _ _proto__ 的内置属性，用于指向创建它的函数对象的原型对象 prototype</li>
<li>原型和原型链是 JS 实现继承的一种模型</li>
<li>原型链是靠 proto 形成的，而不是 prototype</li>
<li>所有的原型对象都有 constructor 属性，该属性对应创建所有指向该原型的实例构造函数</li>
<li>函数对象和原型对象通过 prototype 和 constructor 属性进行相互关联</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/03/如何监听页面 DOM 变动并高效响应/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/03/如何监听页面 DOM 变动并高效响应/" itemprop="url">
                  如何监听页面 DOM 变动并高效响应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="从-DOM-变动事件监听说起"><a href="#从-DOM-变动事件监听说起" class="headerlink" title="从 DOM 变动事件监听说起"></a>从 DOM 变动事件监听说起</h3><p>首先假设大家已经知道 JavaScript 中事件的发生阶段（捕获-命中-冒泡），附上一张图带过这个内容，我们直接进入寻找解决方法的过程。</p>
<p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt=""></p>
<p><em><a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" target="_blank" rel="external">Graphical representation of an event dispatched in a DOM tree using the DOM event flow</a></em></p>
<p>开始的时候我一直在 window 状态改变涉及到的事件中寻找，一圈搜寻下来发现也就 <code>onload</code> 事件最接近了，所以我们看看 MDN 对该事件的定义：</p>
<blockquote>
<p>The load event is fired when a resource and its dependent resources have finished loading.</p>
</blockquote>
<p>怎么理解资源及其依赖资源已加载完毕呢？简单来说，如果一个页面涉及到图片资源，那么 onload 事件会在页面完全载入（包括图片、css文件等等）后触发。一个简单的监听事件用 JavaScript 应该这样书写（注意不同环境下 load 和 onload 的差异）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"All resources finished loading!"</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="comment">// or</span></div><div class="line">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"All resources finished loading!"</span>);</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="comment">// HTML</span></div><div class="line">  &lt;body onload=<span class="string">"SomeJavaScriptCode"</span>&gt;</div><div class="line">  </div><div class="line">  <span class="comment">// jQuery</span></div><div class="line">  $( <span class="built_in">window</span> ).on( <span class="string">"load"</span>, handler )</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>当然，说到 <code>onload</code> 事件，有一个 jQuery 中相似的事件一定会被提及—— <code>ready</code> 事件。jQuery 中这样定义这个事件：</p>
<blockquote>
<p>Specify a function to execute when the DOM is fully loaded.</p>
</blockquote>
<p>需要知道的是 jQuery 定义的 <code>ready</code> 事件实质上是为 <code>DOMContentLoaded</code> 事件设计的，所以当我们谈论加载时应该区分的事件其实是 <code>onload</code>（接口 UIEvent） 以及 <code>DOMContentLoaded</code>（接口 Event），MDN 这样描述 <code>DOMContentLoaded</code>：</p>
<blockquote>
<p>当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。</p>
</blockquote>
<p>所以可以知道，当一个页面加载时应先触发 <code>DOMContentLoaded</code> 然后才是 <code>onload</code>. 类似的事件及区别包括以下几类：</p>
<ul>
<li><strong>DOMContentLoaded</strong>: 当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载；</li>
<li><strong>readystatechange</strong>: 一个document 的 Document.readyState 属性描述了文档的加载状态，当这个状态发生了变化，就会触发该事件；</li>
<li><strong>load</strong>: 当一个资源及其依赖资源已完成加载时，将触发load事件；</li>
<li><strong>beforeunload</strong>: 当浏览器窗口，文档或其资源将要卸载时，会触发beforeunload事件。</li>
<li><strong>unload</strong>: 当文档或一个子资源正在被卸载时, 触发 unload事件。</li>
</ul>
<p>细心点会发现上面在介绍事件时提到了 UIEvent 以及 Event，这是什么呢？这些都是事件——可以被 JavaScript 侦测到的行为。其他的事件接口还包括 KeyboardEvent ／ VRDisplayEvent （是的，没错，这就是你感兴趣且熟知的那个 VR）等等；如果在搜索引擎中稍加搜索，你会发现有些资料里写到事件可以分为以下几类：</p>
<ul>
<li>UI事件</li>
<li>焦点事件</li>
<li>鼠标与滚轮事件</li>
<li>键盘与文本事件</li>
<li>复合事件</li>
<li>变动事件</li>
<li>HTML5 事件</li>
<li>设备事件</li>
<li>触摸与手势事件</li>
</ul>
<p>但这样写实在有些凌乱，其中一些是 DOM3 定义的事件，有一些是单独列出的事件，如果你觉得熟悉那么你会发现这是 JavaScript 高级程序设计里的叙述模式，在我看来，理解这些事件可以按照 DOM3 事件以及其他事件来做区分：其中，DOM3 级事件规定了以下几类事件 - UI 事件, 焦点事件, 鼠标事件, 滚轮事件, 文本事件, 键盘事件, 合成事件, 变动事件, 变动名称事件; 而剩下的例如 HTML5 事件可以单独做了解。而刚开始提到的 Event 作为一个主要接口，是很多事件的实现父类。有关 Web API 接口可以在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="external">这里</a>查到，里面可以看到有很多 Event 字眼。</p>
<p>好吧，事件说了这么多，我们还是没有解决刚开始提出的问题，如果监听页面中动态生成的元素呢？想到动态生成的元素都是需要通过网络请求获取资源的，那么是否可以监听所有 HTTP 请求呢？查看 jQuery 文档可以知道每当一个Ajax请求完成，jQuery 就会触发 ajaxComplete 事件，在这个时间点所有处理函数会使用 .ajaxComplete() 方法注册并执行。但是谁能保证所有 ajax 都从 jQuery 走呢？所以应该在<strong>变动事件</strong>中做出选择，我们来看看 DOM2 定义的如下变动事件：</p>
<ul>
<li><strong>DOMSubtreeModified</strong>: 在DOM结构发生任何变化的时候。这个事件在其他事件触发后都会触发；</li>
<li><strong>DOMNodeInserted</strong>: 当一个节点作为子节点被插入到另一个节点中时触发；</li>
<li><strong>DOMNodeRemoved</strong>: 在节点从其父节点中移除时触发；</li>
<li><strong>DOMNodeInsertedIntoDocument</strong>: 在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在 DOMNodeInserted 之后触发；</li>
<li><strong>DOMNodeRemovedFromDocument</strong>: 在一个节点被直接从文档移除或通过子树间接从文档移除之前触发。这个事件在 DOMNodeRemoved 之后触发；</li>
<li><strong>DOMAttrModified</strong>: 在特性被修改之后触发；</li>
<li><strong>DOMCharacterDataModified</strong>: 在文本节点的值发生变化时触发；</li>
</ul>
<p>所以，用 DOMSubtreeModified 好像没错。师兄旁边提醒，用 <strong>MutationObserver</strong>, 于是又搜到了一个新大陆。MDN 这样描述 MutationObserver：</p>
<blockquote>
<p>MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</p>
</blockquote>
<p>DOM3 事件规范中的 Mutation 事件可以被简单看成是 DOM2 事件规范中定义的 Mutation 事件的一个扩展，但是这些都不重要了，因为他们都要被 MutationObserver 替代了。好了，那么来详细介绍一下 MutationObserver 吧。文章《<a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="external">Mutation Observer API</a>》对 MutationObserver 的用法介绍的比较详细，所以我挑几点能直接解决我们需求的说一说。</p>
<p>既然要监听 DOM 的变化，我们来看看 Observer 的作用都有哪些：</p>
<blockquote>
<p>它等待所有脚本任务完成后，才会运行，即采用异步方式。</p>
<p>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条地个别处理 DOM 变动。</p>
<p>它既可以观察发生在 DOM 的所有类型变动，也可以观察某一类变动。</p>
</blockquote>
<p>MutationObserver 的构造函数比较简单，传入一个回调函数即可（回调函数接受两个参数，第一个是变动数组，第二个是观察器实例）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</div></pre></td></tr></table></figure>
<p>观察器实例使用 <code>observe</code> 方法来监听， <code>disconnect</code> 方法停止监听，<code>takeRecords</code> 方法来清除变动记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> article = <span class="built_in">document</span>.body;</div><div class="line"></div><div class="line"><span class="keyword">let</span>  options = &#123;</div><div class="line">  <span class="string">'childList'</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">'attributes'</span>:<span class="literal">true</span></div><div class="line">&#125; ;</div><div class="line"></div><div class="line">observer.observe(article, options);</div></pre></td></tr></table></figure>
<p><code>observe</code> 方法中第一个参数是所要观察的变动 DOM 元素，第二个参数则接收所要观察的变动类型（子节点变动和属性变动）。变动类型包括以下几种：</p>
<ul>
<li>childList：子节点的变动。</li>
<li>attributes：属性的变动。</li>
<li>characterData：节点内容或节点文本的变动。</li>
<li>subtree：所有后代节点的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在 option 对象中指定它的值为 true。需要注意的是，如果设置观察 subtree 的变动，必须同时指定  childList、attributes 和 characterData 中的一种或多种。<code>disconnect</code> 方法和 <code>takeRecords</code> 方法则直接调用即可，无传入参数。</p>
<p>好的，我们已经搞定了 DOM 变动的监听，将代码刷新一下看下效果吧，因为页面由很多动态生成的商品组成，那么我应该在 body 上添加变动监听，所以 options 应该这样设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">	&apos;attributes&apos;: true,</div><div class="line">	&apos;subtree&apos;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咦？页面往下拉一小点就触发了 observer 几十次？这样 DOM 哪吃得消啊，查看了页面的变动记录发现每次新进的资源底层都调用了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore" target="_blank" rel="external">Node.insertBefore()</a> 方法…</p>
<h3 id="再聊聊-JavaScript-中的截流／节流函数"><a href="#再聊聊-JavaScript-中的截流／节流函数" class="headerlink" title="再聊聊 JavaScript 中的截流／节流函数"></a>再聊聊 JavaScript 中的截流／节流函数</h3><p>现在遇到的一个麻烦是， DOM 变动太频繁了，如果每次变动都监听那真是太耗费资源了。一个简单的解决办法是我就放弃监听了，而采用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" target="_blank" rel="external">setInterval</a> 方法定时执行更新逻辑。是的，虽然方法原始了一点，但是性能上比 Observer “改进”了不少。</p>
<p>这个时候，又来了师兄的助攻：“用用截流函数”。记起之前看《<a href="https://book.douban.com/subject/3590768/" target="_blank" rel="external">JavaScript 语言精粹</a>》的时候看到是用 <code>setTimeout</code> 方法自调用来解决 <code>setInteval</code> 的频繁执行吃资源的现象，不知道两者是不是有关联。网上一查发现有两个“jie流函数”。需求来自于这里：</p>
<blockquote>
<p>在前端开发中，页面有时会绑定scroll或resize事件等频繁触发的事件，也就意味着在正常的操作之内，会多次调用绑定的程序，然而有些时候javascript需要处理的事情特别多，频繁出发就会导致性能下降、成页面卡顿甚至是浏览器奔溃。</p>
</blockquote>
<p>如果重复利用 setTimeout 和 clearTimeout 方法，我们好像可以解决这个频繁触发的执行。每次事件触发的时候我首先判断一下当前有没有一个 setTimeout 定时器，如果有的话我们先将它清除，然后再新建一个 setTimeout 定时器来延迟我的响应行为。这样听上去还不错，因为我们每次都不立即执行我们的响应，而频繁触发过程我们又能保持响应函数一直存在（且只存在一个），除了会有些延迟响应外，没什么不好的。是的这就是<strong>截流函数（debounce）</strong>，有一篇<a href="http://www.cnblogs.com/ambar/archive/2011/10/08/throttle-and-debounce.html" target="_blank" rel="external">博客</a>用这个小故事介绍它：</p>
<blockquote>
<p>形像的比喻是橡皮球。如果手指按住橡皮球不放，它就一直受力，不能反弹起来，直到松手。debounce 的关注点是空闲的间隔时间。</p>
</blockquote>
<p>在我的业务中，在 observer 实例中调用下面写的这个截流函数就可以啦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* fn 执行函数</div><div class="line">* context 绑定上下文</div><div class="line">* timeout 延时数值</div><div class="line">**/</div><div class="line"><span class="keyword">let</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context, timeout</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> timer;</div><div class="line">    </div><div class="line">    <span class="comment">// 利用闭包将内容传递出去</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (timer) &#123;</div><div class="line">		    <span class="comment">// 清除定时器</span></div><div class="line">			clearTimeout(timer); </div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// 设置一个新的定时器</span></div><div class="line">		timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			fn.apply(context, <span class="built_in">arguments</span>)</div><div class="line">		&#125;, timeout);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，解决了自己的问题，但还有一个概念没有说到——“节流函数”。同一篇博文里也使用了一个例子来说明它：</p>
<blockquote>
<p>形像的比喻是水龙头或机枪，你可以控制它的流量或频率。throttle 的关注点是连续的执行间隔时间。</p>
</blockquote>
<p>函数节流的原理也挺简单，一样还是定时器。当我触发一个时间时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就清除原来的定时器，再setTimeout一个新的定时器延迟一会执行。函数节流的出发点，就是让一个函数不要执行得太频繁，减少一些过快的调用来节流。这里引用 <a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="external">AlloyTeam</a> 的节流代码实现来解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数同上</span></div><div class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay, mustRunDelay</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line"> <span class="keyword">var</span> t_start;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> 	<span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>, t_curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 清除定时器</span></div><div class="line"> 	clearTimeout(timer);</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 函数初始化判断</span></div><div class="line"> 	<span class="keyword">if</span>(!t_start)&#123;</div><div class="line"> 		t_start = t_curr;</div><div class="line"> 	&#125;</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 超时（指定的时间间隔）判断</span></div><div class="line"> 	<span class="keyword">if</span>(t_curr - t_start &gt;= mustRunDelay)&#123;</div><div class="line"> 		fn.apply(context, args);</div><div class="line"> 		t_start = t_curr;</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="keyword">else</span> &#123;</div><div class="line"> 		timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> 			fn.apply(context, args);</div><div class="line"> 		&#125;, delay);</div><div class="line"> 	&#125;</div><div class="line"> &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当然，AlloyTeam 那篇文章将这里所说的截流函数作为节流函数的 V1.0 版本，你也可以这样认为。毕竟，设置了必然触发执行的时间间隔（即 mustRunDelay 函数），可以使得截流函数不会在“疯狂事件”情况下无止境的循环下去。</p>
<p>Observer 和截流函数一结合，问题解决啦嘿嘿。当然还有很多坑，下次再开一篇说说吧。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/load" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Events/load</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></li>
<li><a href="http://www.cnblogs.com/fsjohnhuang/p/4147810.html" target="_blank" rel="external">http://www.cnblogs.com/fsjohnhuang/p/4147810.html</a></li>
<li><a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="external">http://www.alloyteam.com/2012/11/javascript-throttle/</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/02/一个故事讲完 Https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/02/一个故事讲完 Https/" itemprop="url">
                  一个故事讲完 Https
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T00:00:00+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想起上个月面试官问我了不了解 Https，当时对 HTTP 都不太熟的我只能说”No”。当我看完计算机网络教材的时候，又恰巧看见了微信公众号码农翻身的此篇推送，让我受益良多。</p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>今天来聊一聊https 安全传输的原理。</p>
<p>在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。</p>
<p>这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。</p>
<p>此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心……</p>
<p>张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 The Divided State of America ……</p>
<p>Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样…..</p>
<p>两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。</p>
<h2 id="总是有一种被偷看的感觉"><a href="#总是有一种被偷看的感觉" class="headerlink" title="总是有一种被偷看的感觉"></a>总是有一种被偷看的感觉</h2><p>有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。</p>
<p>张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了? 估计已经被人截取了吧！”</p>
<p>Bill 提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ”<br><img src="http://i1.buimg.com/1949/ade6db4481ac227a.png" alt="image"><br>张大胖冰雪聪明，一看就明白了， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！”</p>
<p>（码农翻身注：这叫对称加密算法， 因为加密和解密用的是同一个密钥）</p>
<p>一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！”</p>
<p>Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？”</p>
<p>张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？　</p>
<p>“奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？”　</p>
<p>“哈哈， 这倒是终极解决之道 ” Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ”</p>
<p>张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！</p>
<p>可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！</p>
<h2 id="RSA：非对称加密"><a href="#RSA：非对称加密" class="headerlink" title="RSA：非对称加密"></a>RSA：非对称加密</h2><p>Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的非对称加密算法，一下子来了灵感。</p>
<p>这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。</p>
<p>更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。<br><img src="http://i1.buimg.com/1949/5e8c39e7ca86956d.png" alt="image"><br>有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ）<br><img src="http://i1.buimg.com/1949/43e126b0647a1475.png" alt="image"><br>反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。</p>
<p>这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。</p>
<h2 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密+对称加密"></a>非对称加密+对称加密</h2><p>两人实验了几次， 张大胖说： “Bill , 你有没有感觉这个RSA的加密和解密有点慢啊？”</p>
<p>Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了”</p>
<p>“回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走　(1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信, 如何？ ”</p>
<p>Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。”　</p>
<p>于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！</p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>张大胖把和Bill 聊天的情况给老婆汇报了一次。</p>
<p>老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?”</p>
<p>张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。”</p>
<p>老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密，　那中间人不就可以解密看到消息了？＂</p>
<p>张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill , Bill和我根本都意识不到， 还以为我们在安全传输呢！</p>
<p><img src="http://i1.buimg.com/1949/a58bf0d069be1226.png" alt="image"></p>
<p>看来问题出现在公钥的分发上！ 虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！</p>
<h2 id="你到底是谁"><a href="#你到底是谁" class="headerlink" title="你到底是谁"></a>你到底是谁</h2><p>但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？</p>
<p>可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。</p>
<p>怎么声明呢？</p>
<p>张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。</p>
<p>这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！</p>
<p>这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！</p>
<p>可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？</p>
<p>张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。</p>
<p>天无绝人之路， 张大胖很快就找到了突破口： 数字签名。</p>
<p>简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。<br><img src="http://i1.buimg.com/1949/b1bb655d23b8c5cc.png" alt="image"><br>可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？”</p>
<p>张大胖说你别得意的太早 ， 我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名：<br><img src="http://i1.buimg.com/1949/38d3543e8ee28c6e.png" alt="image"><br>这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书”<br><img src="http://i1.buimg.com/1949/e7a1c438c1108a01.png" alt="image"><br>张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！</p>
<p>如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。</p>
<p>虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。<br><img src="http://i1.buimg.com/1949/495b3241682bbe98.png" alt="image"><br>中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？　难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？　如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。”</p>
<p>张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！</p>
<p>不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。</p>
<p>（公众号码农翻身注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。）</p>
<h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><p>终于可以介绍https了，前面已经介绍了https的原理， 你把张大胖替换成浏览器， 把Bill 替换成某个网站就行了。</p>
<p>一个简化的（例如下图没有包含Pre-Master Secret）https流程图是这样的， 如果你理解了前面的原理，这张图就变得非常简单：<br><img src="http://i1.buimg.com/1949/ecbc530393f88118.png" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/30/MasterPromise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/30/MasterPromise/" itemprop="url">
                  Master Promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T00:00:00+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"create a promise"</span></div><div class="line"><span class="string">"after new Promise"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>
<h2 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    resolve(<span class="number">2</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    reject(<span class="number">3</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1);</div><div class="line"><span class="built_in">console</span>.log(p2);</div><div class="line"><span class="built_in">console</span>.log(p3);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p2);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p3);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">2</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"rejected"</span>, [[PromiseValue]]: <span class="number">3</span>&#125;</div></pre></td></tr></table></figure></p>
<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h2 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success1"</span>);</div><div class="line">  resolve(<span class="string">"success2"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">  reject(<span class="string">"reject"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"success1"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(“success2”)并不能将p1的值更改为success2，p2中reject(“reject”)也不能将p2的状态由resolved改变为rejected.</p>
<h2 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="string">"resolve"</span></div><div class="line"><span class="string">"reject: reject"</span></div></pre></td></tr></table></figure></p>
<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li><strong>return</strong>  一个同步的值 ，或者 <strong>undefined</strong>（当没有返回一个有效值时，默认返回undefined），<strong>then</strong>方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li><strong>return</strong> 另一个 Promise，<strong>then</strong>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
</ul>
<p>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p>
<h2 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"which one is called first ?"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h2 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  foo.bar();</div><div class="line">  resolve( <span class="number">1</span> );      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve( <span class="number">2</span> );    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</div><div class="line">    foo.bar();</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p1 then err: <span class="built_in">ReferenceError</span>: foo is not defined</div><div class="line">p2 then value: <span class="number">2</span></div><div class="line">p1 then then value: <span class="literal">undefined</span></div><div class="line">p2 then then err: <span class="built_in">ReferenceError</span>: foo is not defined</div><div class="line">p2 then then then value: <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>Promise中的异常由<strong>then</strong>参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，<strong>then</strong>返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级<strong>then</strong>的回调函数是交替执行的 ，这正是由Promise <strong>then</strong>回调的异步性决定的。</p>
<h2 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</div><div class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(p1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1 === p2); </div><div class="line"><span class="built_in">console</span>.log(p1 === p3);</div><div class="line"><span class="built_in">console</span>.log(p1 === p4);</div><div class="line"><span class="built_in">console</span>.log(p3 === p4);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">false</span></div><div class="line">p2=<span class="number">1</span></div><div class="line">p1=<span class="number">1</span></div><div class="line">p4=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p><strong>Promise.resolve(…)</strong>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的<strong>then</strong>最先调用，但在控制台上是最后输出结果的呢？因为p4的<strong>resolve</strong>中接收的参数是一个Promise对象p1，<strong>resolve</strong>会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h2 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p3.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p3 rejected: [object <span class="built_in">Promise</span>]</div><div class="line">p1 fulfilled: resolve</div><div class="line">p2 rejected: reject</div></pre></td></tr></table></figure></p>
<p>Promise回调函数中的第一个参数<strong>resolve</strong>，会对Promise执行”拆箱”动作。即当<strong>resolve</strong>的参数是一个Promise对象时，<strong>resolve</strong>会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是<strong>resolved</strong>，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是<strong>rejected</strong>，因此<strong>rejected</strong>回调被执行。但Promise回调函数中的第二个参数<strong>reject</strong>不具备”拆箱“的能力，<strong>reject</strong>的参数会直接传递给<strong>then</strong>方法中的<strong>rejected</strong>回调。因此，即使p3 <strong>reject</strong>接收了一个<strong>resolved</strong>状态的Promise，<strong>then</strong>方法中被调用的依然是<strong>rejected</strong>，并且参数就是<strong>reject</strong>接收到的Promise对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/20/在浏览器地址栏输入url，按下回车后究竟发生了什么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/20/在浏览器地址栏输入url，按下回车后究竟发生了什么？/" itemprop="url">
                  在浏览器地址栏输入url,按下回车后究竟发生了什么?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T00:00:00+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h2><p>当你在浏览器地址栏输入一个URL后回车，将会发生的事情？这是一道经典的面试题，同时也是一道复杂的题目，涉及到很多东西，不同的软件开发者对于此道问题有不同的答案，对于其中的某一点也能无限深究，今天我们就来侧重于web前端来看一下究竟发生了什么。</p>
<h2 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h2><h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>①查询ip地址</p>
<p>②建立tcp连接，接入服务器</p>
<p>③浏览器发起http请求</p>
<p>④服务器后台操作并做出响应</p>
<p>⑤网页的解析与渲染</p>
<h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h2><h3 id="查询ip地址"><a href="#查询ip地址" class="headerlink" title="查询ip地址"></a>查询ip地址</h3><p>①浏览器解析出url中的域名。</p>
<p>②查询浏览器的DNS缓存。</p>
<p>③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。</p>
<p>④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。</p>
<p>⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。</p>
<p>⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。</p>
<h3 id="tcp连接与http连接"><a href="#tcp连接与http连接" class="headerlink" title="tcp连接与http连接"></a>tcp连接与http连接</h3><p>①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服。</p>
<p>②务器的稳定的通道。俗称TCP的三次握手。</p>
<p>③tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。</p>
<p>④http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</p>
<p>⑤服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</p>
<p>⑥文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</p>
<p>⑦经过网络传输，文件被下载到本地客户端，客户端开始加载。</p>
<h3 id="html渲染"><a href="#html渲染" class="headerlink" title="html渲染"></a>html渲染</h3><p>①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。</p>
<p>②遇到css文件，css中的url发起http请求。</p>
<p>③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。</p>
<p>④http连接是无状态连接，客户端与服务器端需要重新发起请求–响应。</p>
<p>在请求css的过程中，解析器继续解析html，然后到了script标签。</p>
<p>⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。</p>
<p>⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。</p>
<p>⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。</p>
<p>⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</p>
<p>⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</p>
<p>⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</p>
<p>⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</p>
<p>⑫DOM树遇到html结束标签，停止解析，进而渲染结束。</p>
<h2 id="4-扩展思考"><a href="#4-扩展思考" class="headerlink" title="4.扩展思考"></a>4.扩展思考</h2><h3 id="有那些网站优化的方法？"><a href="#有那些网站优化的方法？" class="headerlink" title="有那些网站优化的方法？"></a>有那些网站优化的方法？</h3><p>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p>
<p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p>
<p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p>
<p>④提前渲染开始时间：将css链接放在html头部。</p>
<p>⑤减轻解析器的阻塞：将js链接放在body尾部。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/15/2分钟学会数据mock，独立于后端开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/15/2分钟学会数据mock，独立于后端开发/" itemprop="url">
                  2分钟学会数据mock，独立于后端开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-15T12:47:44+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么说两分钟就能学会？ 因为你看完这篇文章只需要两分钟。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>相对于其他同类的框架的实现，mock.js超出了大家的意料。</li>
</ul>
<ol>
<li>基于 数据模板 生成模拟数据。</li>
<li>基于 HTML模板 生成模拟数据。</li>
<li>拦截并模拟 ajax 请求。</li>
</ol>
<ul>
<li>是的，mock.js只做上述的几件事，但做的足够出色。</li>
</ul>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>开发时，后端还没完成数据输出，前端只好写静态模拟数据。</p>
<ul>
<li>数据太长了，将数据写在js文件里，完成后挨个改url。</li>
<li>某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。</li>
<li>想要尽可能还原真实的数据，要么编写更多代码，要么手动修改模拟数据。</li>
<li>特殊的格式，例如IP,随机数，图片，地址，需要去收集。</li>
<li>超烂的破网速…</li>
<li>…</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装太简单，跳过</p>
<h2 id="mockjs基本语法"><a href="#mockjs基本语法" class="headerlink" title="mockjs基本语法"></a>mockjs基本语法</h2><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 属性名   name</span></div><div class="line"><span class="comment">// 生成规则 rule</span></div><div class="line"><span class="comment">// 属性值   value</span></div><div class="line"><span class="string">'name|rule'</span>: value</div><div class="line">注意：</div><div class="line"></div><div class="line">属性名 和 生成规则 之间用竖线 | 分隔。</div><div class="line">生成规则 是可选的。</div><div class="line">生成规则 有 <span class="number">7</span> 种格式：</div><div class="line"><span class="string">'name|min-max'</span>: value</div><div class="line"><span class="string">'name|count'</span>: value</div><div class="line"><span class="string">'name|min-max.dmin-dmax'</span>: value</div><div class="line"><span class="string">'name|min-max.dcount'</span>: value</div><div class="line"><span class="string">'name|count.dmin-dmax'</span>: value</div><div class="line"><span class="string">'name|count.dcount'</span>: value</div><div class="line"><span class="string">'name|+step'</span>: value</div><div class="line">生成规则 的 含义 需要依赖 属性值的类型 才能确定。</div><div class="line">属性值 中可以含有 @占位符。</div><div class="line">属性值 还指定了最终值的初始值和类型。</div></pre></td></tr></table></figure></p>
<h2 id="mockjs-官网"><a href="#mockjs-官网" class="headerlink" title="mockjs 官网"></a>mockjs 官网</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://mockjs.com/</div></pre></td></tr></table></figure>
<h2 id="配置模拟数据"><a href="#配置模拟数据" class="headerlink" title="配置模拟数据"></a>配置模拟数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mock.mock(<span class="string">'http://g.cn'</span>, &#123;</div><div class="line">    <span class="string">'name'</span>     : <span class="string">'@cname'</span>,</div><div class="line">    <span class="string">'age|1-100'</span>: <span class="number">100</span>,</div><div class="line">    <span class="string">'color'</span>    : <span class="string">'@color'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="发送ajax请求-jquery版"><a href="#发送ajax请求-jquery版" class="headerlink" title="发送ajax请求(jquery版)"></a>发送ajax请求(jquery版)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">'http://g.cn'</span>,</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(</div><div class="line">        <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">4</span>)</div><div class="line">    )    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="查看响应的结果"><a href="#查看响应的结果" class="headerlink" title="查看响应的结果"></a>查看响应的结果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 结果1</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"Elizabeth Hall"</span>,</div><div class="line">    <span class="string">"age"</span>: <span class="number">91</span>,</div><div class="line">    <span class="string">"color"</span>: <span class="string">"#0e64ea"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果2</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"Michael Taylor"</span>,</div><div class="line">    <span class="string">"age"</span>: <span class="number">61</span>,</div><div class="line">    <span class="string">"color"</span>: <span class="string">"#081086"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果N ..</span></div></pre></td></tr></table></figure>
<h3 id="数据模板用法"><a href="#数据模板用法" class="headerlink" title="数据模板用法"></a>数据模板用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin/a1'</span>: &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">msg</span>: <span class="string">'成功'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;&#125;,</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'/admin/a2'</span>: &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">msg</span>: <span class="string">'成功'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'@cname'</span>,</div><div class="line">            <span class="attr">address</span>: <span class="string">'@province'</span>,</div><div class="line">            <span class="attr">email</span>: <span class="string">'@email'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin/a2'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'%s'</span>, <span class="string">'这是a2'</span>, data)</div><div class="line">    &#125;);</div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin/a1'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'%s'</span>, <span class="string">'这是a1'</span>, data)</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h2 id="高级用法（根据请求方法来返回数据）"><a href="#高级用法（根据请求方法来返回数据）" class="headerlink" title="高级用法（根据请求方法来返回数据）"></a>高级用法（根据请求方法来返回数据）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (req.type === <span class="string">'GET'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"接到get请求"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.type === <span class="string">'POST'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">'接到post请求'</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'post'</span></div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h3 id="高级用法（根据请求参数来返回数据）"><a href="#高级用法（根据请求参数来返回数据）" class="headerlink" title="高级用法（根据请求参数来返回数据）"></a>高级用法（根据请求参数来返回数据）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> param = str2obj(req.body);</div><div class="line">        <span class="keyword">if</span> (param.type === <span class="string">'1'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是1"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.type === <span class="string">'2'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是2"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2obj</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/ig</span>;</div><div class="line">    str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">        obj[b] = c;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        Mock.mock(key, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'post'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">type</span>: <span class="number">2</span>,</div><div class="line">            <span class="attr">status</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h2 id="高级用法（特殊处理get请求）"><a href="#高级用法（特殊处理get请求）" class="headerlink" title="高级用法（特殊处理get请求）"></a>高级用法（特殊处理get请求）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = &#123;</div><div class="line">    <span class="string">'/admin'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(req)</div><div class="line">        <span class="keyword">var</span> param = str2obj(req.url);</div><div class="line">        <span class="keyword">if</span> (param.type === <span class="string">'1'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是1"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.type === <span class="string">'2'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">msg</span>: <span class="string">"type是2"</span>,</div><div class="line">                <span class="attr">data</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2obj</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/ig</span>;</div><div class="line">    str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">        obj[b] = c;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> template) &#123;</div><div class="line">    <span class="keyword">if</span> (template.hasOwnProperty(key)) &#123;</div><div class="line">        <span class="keyword">var</span> url = <span class="keyword">new</span> <span class="built_in">RegExp</span>(key);</div><div class="line">        Mock.mock(url, template[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/admin'</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'get'</span>,</div><div class="line">        <span class="attr">data</span>: &#123;</div><div class="line">            <span class="attr">type</span>: <span class="number">2</span>,</div><div class="line">            <span class="attr">status</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, xhr</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/09/知识点整理 - 前端涉及的各种像素概念以及 viewport 汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/09/知识点整理 - 前端涉及的各种像素概念以及 viewport 汇总/" itemprop="url">
                  知识点整理 - 前端涉及的各种像素概念以及 viewport 汇总
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T00:00:00+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><strong>设备像素(device pixel, dp)</strong>: 又称为物理像素。指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位 pt。pt 在 css 单位中属于真正的绝对单位，1pt = 1/72(inch), inch及英寸，而1英寸等于2.54厘米。所以设备像素的特点就是大小固定，不可变。比如 iPhone 5 的分辨率为 640 x 1136px.</li>
<li><strong>CSS像素(css pixel, px)</strong>: 又称为虚拟像素，也可以理解为直觉像素。CSS 像素是 Web 编程的概念，指的是 CSS 样式代码中使用的逻辑像素。在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是前面所说的设备像素(device pixel)。比如 iPhone 5 的 CSS 像素数为 320 x 568px.</li>
</ul>
<h2 id="关于像素的那些事"><a href="#关于像素的那些事" class="headerlink" title="关于像素的那些事"></a>关于像素的那些事</h2><p>前面说到的 px 相对单位指的是图像显示的基本单元，<strong>它既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。</strong> 刚刚提到了图像显示的基本单元，这个东西在不同设备上又是不一样的，例如显示器上的物理像素指的是显示器的点距，而打印机的物理像素则指的是打印机的墨点。</p>
<p>作为一个抽象概念，CSS 像素又具有两个方面的相对性，即：</p>
<ul>
<li>在同一个设备上，每1个 CSS 像素所代表的设备像素是可以变化的（即CSS像素的第一方面的相对性）；</li>
<li>在不同的设备之间，每1个 CSS 像素所代表的设备像素是可以变化的（即CSS像素的第二方面的相对性）；</li>
</ul>
<p>所以，<strong>CSS中的1px（CSS像素 可变）!== 设备的1px（设备像素 不可变）</strong>。</p>
<h3 id="CSS-像素的真正含义"><a href="#CSS-像素的真正含义" class="headerlink" title="CSS 像素的真正含义"></a>CSS 像素的真正含义</h3><p>按照 CSS 规范的定义，CSS 中的 px 是一个相对长度，它相对的，是 viewing device 的分辨率。这个 viewing device，通常就是电脑显示器。典型的电脑显示器的分辨率是96DPI，也就是1像素为1/96英寸（实际上，假设我们的显示器分辨率都与物理分辨率一致，而液晶点距其实是0.25mm到0.29mm之间，所以不太可能是正好1/96英寸，而只是接近）。</p>
<p>一般来说，px 就是对应设备的物理像素，然而如果输出设备的解析度与电脑显示器大不相同，输出效果就会有问题。例如打印机输出到纸张上，其解析度比电脑屏幕要高许多，如果不缩放，直接使用设备的物理像素，那电脑上的照片由 600DPI 的打印机打出来就比用显示器看小了约6倍。</p>
<p>由于不同的物理设备的物理像素的大小是不一样的，所以 CSS 认为浏览器应该对 CSS 中的像素进行调节，使得浏览器中 1个 CSS 像素的大小在不同物理设备上看上去大小总是差不多，目的是为了保证阅读体验的一致。为了达到这一点，浏览器可以直接按照设备的物理像素大小进行换算，而 CSS 规范中使用<strong>参考像素</strong>来进行换算。</p>
<p>一个参考像素即为从一臂之遥看解析度为 96DPI 的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。它并不是1/96英寸长度，而是从一臂之遥的距离处看解析度为 96DPI 的设备输出一单位（即1/96英寸）时视线与水平线的夹角。通常认为常人臂长为28英寸，所以它的视角是:<br>(1/96)in / (28in <em> 2 </em> PI / 360deg) = 0.0213度。如下图是一个示意图：</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-2.png" alt=""></p>
<p>对于人来说，眼睛看到的大小取决于可视角度。而可视角度取决于物体的实际大小以及物体与眼睛的距离。10米远处一个1米见方的东西，与1米远处的10厘米见方的东西，看上去的大小差不多是一样的，所谓一叶障目不见泰山，讲的就是这个常识。</p>
<p>左边的屏幕（可以认为是电脑屏幕）的典型视觉距离是71厘米即28英寸，其1px对应了0.28mm；而右边的屏幕（可以认为是你的42寸高清电视）的典型视觉距离是3.5米即120英寸，其1px对应1.3mm。42寸的1080p电视，分辨率是1920*1080，则其物理像素只有0.5mm左右。</p>
<p>综上，px 是一个相对单位，而且在特定设备上总是一个近似值（原则是尽量接近参考像素）。</p>
<h3 id="影响像素的那些因素"><a href="#影响像素的那些因素" class="headerlink" title="影响像素的那些因素"></a>影响像素的那些因素</h3><p>然而，如果你把绝对单位理解为对输出效果的绝对掌控，事情却大相径庭。就网页输出的最主要对象——电脑屏幕来说，px 可被视为一个基准单位——与桌面分辨率一致，如果是液晶屏，则几乎总是与液晶屏物理分辨率一致——也就是说网页设计者设定的1px，就是“最终打开这个网页的用户在显示器上看到的1个点距”！反倒是那些绝对单位，其实一点也不绝对。</p>
<p>那么 <strong>px 都会受哪些因素的影响而变化</strong>？</p>
<ul>
<li><strong>每英寸像素(pixel per inch, ppi/PPI)</strong>: 它表示的是每英寸所拥有的像素(pixel)数目，更确切的说法应该是<strong>像素密度</strong>，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。数值越高，代表显示屏能够以越高的密度显示图像。</li>
<li><strong>设备像素比(device pixel ratio, dpr/DPR)</strong>: 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。如何理解这个概念呢？通俗来说，它是指在开发中1个 CSS 像素占用多少设备像素，如 <code>dpr=2</code> 代表1个 CSS 像素用2x2个设备像素来绘制，所以，可以理解为 <strong>1px由多少个设备像素组成</strong></li>
<li><strong>DPI</strong>: 每英寸多少点。</li>
</ul>
<p>当用于描述显示器时，我们可以吧 ppi 和 dpi 认为是同一个概念。那么 ppi 和 dpr 到底是什么关系呢？ ppi 用作显示设备的工业标准，业界人士用 ppi 的值来衡量一个屏幕是否为高清屏，然后根据得到的密度分界来获得此时对应的 dpr 值，也即默认缩放比例。 dpr 和 ppi 相关，一般 dpr 为 ppi/160 的整数倍，如下所示：</p>
<table>
<thead>
<tr>
<th>项名</th>
<th>ldpi</th>
<th>mdpi</th>
<th>hdpi</th>
<th>xhdpi</th>
</tr>
</thead>
<tbody>
<tr>
<td>密度分界（密度值）</td>
<td>120</td>
<td>160</td>
<td>240</td>
<td>320</td>
</tr>
<tr>
<td>屏幕尺寸（分辨率）</td>
<td>240×320</td>
<td>320×480</td>
<td>480×800</td>
<td>640×960</td>
</tr>
<tr>
<td>默认缩放比例</td>
<td>0.75</td>
<td>1.0</td>
<td>1.5</td>
<td>2.0</td>
</tr>
</tbody>
</table>
<p>了解了这两个概念后，我们可以来说说导致 CSS 中 px 变化的因素了。</p>
<ul>
<li><strong>像素密度</strong>：从 iPhone4 开始，苹果推出了 Retina 屏，分辨率提高了一倍（640<em>960），而屏幕尺寸却没变。这时一个css像素=2个设备像素（换算公式为 `1px = (dpr)^2 </em> 1dp`, 必须让css中的1px代表更多的设备像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，否则会因太小而看不清），即 DPR=2，示意图如下：</li>
</ul>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-1.png" alt=""></p>
<ul>
<li><strong>缩放操作</strong>：缩放也会引起 css 中 px 的变化。放大页面到200%，字体大小与元素宽度的像素值不变，只是css的1px代表设备像素中的4px，宽高都是200%，DPR增加了。此时，获取 <code>screen.width</code> 值不变，而 <code>window.innerWidth/Height</code> 值（visual viewport）变成原来的一半。缩放值越大，当前 viewport 宽度会越小。</li>
</ul>
<p>如何理解上面说到的缩放呢？放大1倍，原来 1px 的东西变成 2px，但 1px 变为 2px 并不是把原来的 320px 变为 640px，而是在实际宽度不变的情况下，1px 变得跟原来的 2px 的长度（长宽）一样了（元素会占据更多的设备像素），所以放大1倍后原来需要 320px 才能填满的宽度现在只需要 160px，也即原来 320px 的面积里现在只能填入 160px 的东西了。</p>
<p>举个例子说明 CSS 像素的相对性，如下示意图：</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-3.png" alt=""></p>
<p>作为Web开发者，我们接触的更多的是用于控制元素样式的样式单位像素。这里的像素我们称之为CSS像素。假设我们用PC浏览器打开一个页面，浏览器此时的效果如左图所示，但如果我们把页面放大（通过“Ctrl键”加上“+号键”），此时块状容器则横向扩张，如右图所示（黑色为实际效果，灰色为原来效果）。吊诡的是此时我们既没有调整浏览器窗口大小，也没有改变块状元素的css宽度，但是它看上去却变大了一倍——这是因为我们把CSS像素放大为了原来的两倍。</p>
<p>也就是说默认情况下一个CSS像素应该是等于一个物理像素的宽度的，但是浏览器的放大操作让一个CSS像素等于了多个设备像素宽度。</p>
<ul>
<li><strong>设备独立像素(Device independent Pixel, DIP)</strong>: 也称为逻辑像素，简称 DIP.</li>
</ul>
<h2 id="像素换算与倍率"><a href="#像素换算与倍率" class="headerlink" title="像素换算与倍率"></a>像素换算与倍率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DPR = 设备像素 / CSS像素 = 屏幕横向设备像素 / 理想视口的宽</div><div class="line">CSS像素 = 设备独立像素 = 逻辑像素</div></pre></td></tr></table></figure>
<p>有关倍率，我们用 iPhone 3gs 和 4s 来举例。假设有个邮件列表界面，我们不妨按照PC端网页设计的思维来想象。3gs上大概只能显示4-5行，4s就能显示9-10行，而且每行会变得特别宽。但两款手机其实是一样大的。如果照这种方式显示，3gs上刚刚好的效果，在4s上就会小到根本看不清字。</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-4.png" alt=""></p>
<p>在现实中，这两者效果却是一样的。这是因为Retina屏幕把2x2个像素当1个像素使用。比如原本44像素高的顶部导航栏，在Retina屏上用了88个像素的高度来显示。导致界面元素都变成2倍大小，反而和3gs效果一样了。画质却更清晰。</p>
<p>在以前，iOS应用的资源图片中，同一张图通常有两个尺寸。你会看到文件名有的带@2x字样，有的不带。其中不带@2x的用在普通屏上，带@2x的用在Retina屏上。只要图片准备好，iOS会自己判断用哪张，Android道理也一样。</p>
<p>由此可以看出，苹果以普通屏为基准，给Retina屏定义了一个2倍的倍率（iPhone 6plus除外，它达到了3倍）。实际像素除以倍率，就得到逻辑像素尺寸。只要两个屏幕逻辑像素相同，它们的显示效果就是相同的。</p>
<h2 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h2><h3 id="都有哪些-viewport"><a href="#都有哪些-viewport" class="headerlink" title="都有哪些 viewport?"></a>都有哪些 viewport?</h3><p><strong>什么是 viewport？</strong> 通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。</p>
<p>首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，DPR 的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视 DPR 的值而定），就是满屏的宽度了。为了防止某些网站因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。<a href="http://www.quirksmode.org/" target="_blank" rel="external">ppk大神</a> 把这个浏览器默认的viewport叫做 <strong>layout viewport</strong>。这个 layout viewport 的宽度可以通过 document.documentElement.clientWidth 来获取。</p>
<p>然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，我们叫他 <strong>visual viewport</strong>。visual viewport 的宽度可以通过 window.innerWidth 来获取，但在 Android 2, Oprea mini 和 UC 8 中无法正确获取。下图为两个 viewport 的示意图：</p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-6.png" alt=""></p>
<p>现在我们已经有两个viewport了 - layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的 viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理，这就是第三个 viewport ——移动设备的理想 viewport (ideal viewport)。</p>
<p>ideal viewport 并没有一个固定的尺寸，不同的设备拥有有不同的 ideal viewport。所有 iPhone 的 ideal viewport 宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在 iPhone 中，css 中的 320px 就代表 iPhone 屏幕的宽度。</p>
<p>但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到 <a href="http://viewportsizes.com" target="_blank" rel="external">http://viewportsizes.com</a> 去查看一下，里面收集了众多设备的理想宽度。</p>
<p>总结一下，ppk把移动设备上的viewport分为layout viewport, visual viewport 和 ideal viewport 三类：</p>
<ul>
<li>ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户；</li>
<li>layout viewport 表示的是浏览器默认的viewport，一般情况下这个宽度要大于浏览器可视区域宽度；</li>
<li>visual viewport 表示浏览器可视区域的大小。</li>
</ul>
<h3 id="利用-meta-标签对-viewport-进行控制"><a href="#利用-meta-标签对-viewport-进行控制" class="headerlink" title="利用 meta 标签对 viewport 进行控制"></a>利用 meta 标签对 viewport 进行控制</h3><p>viewport是专为手机浏览器设计的一个meta标签，一个简单的示例如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，<code>width=device-width</code> 表示此宽度不依赖于原始象素(px)，而依赖于屏幕的宽度。移动设备<strong>默认的viewport是layout viewport</strong>，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。我们在开发移动设备的网站时，最常见的的一个动作就是把上面这个东西复制到我们的head标签中，它的作用是让当前的 viewport 宽度等于设备宽度，同事不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</p>
<p>这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。在苹果的规范中，meta viewport 有6个可以设置的内容：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>设置layout viewport  的宽度，为一个正整数，或字符串”device-width”</td>
</tr>
<tr>
<td>initial-scale</td>
<td>设置页面的初始缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>允许用户的最小缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>允许用户的最大缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>height</td>
<td>设置layout viewport  的高度，这个属性对我们并不重要，很少使用</td>
</tr>
<tr>
<td>user-scalable</td>
<td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td>
</tr>
</tbody>
</table>
<p>这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。此外，在安卓中还支持 <code>target-densitydpi</code> 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素，但作为将要废弃的属性，所以使用中需要避免该用法。我们接下来看看具体的几个用法：</p>
<ul>
<li><strong>width=device-width</strong>: 所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iPhone和iPad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。</li>
<li><strong>initial-scale=1</strong>: 这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。</li>
</ul>
<p>要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的。</p>
<p>但如果width 和 initial-scale=1同时出现，并且还出现了冲突呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=400, initial-scale=1"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>width=400表示把当前viewport的宽度设为400px，initial-scale=1则表示把当前viewport的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度）</p>
<p>最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病。关于缩放，我们可以得出以下一个式子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当前缩放值 = ideal viewport宽度  / visual viewport宽度</div></pre></td></tr></table></figure>
<p>大多数浏览器都符合这个理论，但是安卓上的原生浏览器以及IE有些问题。安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。</p>
<p>好了，现在再来说下initial-scale的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的layout viewport宽度会被设为 ideal viewport的宽度，但前面说了，各浏览器默认的 layout viewport宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport的宽度的，所以 initial-scale的默认值肯定不是1。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的initial-scale默认值。</p>
<p>根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewpor设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的viewport meta标签，此时layout viewport的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了，此时值应为 0.33 左右。</p>
<p>所以总结一下：<strong>在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</strong></p>
<p><img src="/assets/in-post/2017-07-09-Device-Viewport-and-Pixel-Introduction-7.png" alt=""></p>
<h3 id="JavaScript-动态更改-meta-viewport-标签"><a href="#JavaScript-动态更改-meta-viewport-标签" class="headerlink" title="JavaScript 动态更改 meta viewport 标签"></a>JavaScript 动态更改 meta viewport 标签</h3><ul>
<li><strong>方法一</strong>：可以使用document.write来动态输出meta viewport标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&apos;);</div></pre></td></tr></table></figure>
<ul>
<li><strong>方法二</strong>：通过 <code>setAttribute</code> 方法改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;meta id=&quot;testViewport&quot; name=&quot;viewport&quot; content=&quot;width = 380&quot;&gt;</div><div class="line">&lt;script&gt;</div><div class="line">let mvp = document.getElementById(&apos;testViewport&apos;);</div><div class="line">mvp.setAttribute(&apos;content&apos;,&apos;width=480&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>但是要注意，在安卓2.3(或许是所有2.x版本中)的自带浏览器中，对meta viewport标签进行覆盖或更改，会出现让人非常迷糊的结果。</p>
<p>总结一下，每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。</p>
<p>为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。</p>
<p>当然，以上内容对于了解像素概念及 viewport 原理有很大的帮助，但是实际开发中为了提高效率还是需要我们去复用已经实现的代码 snippet, 千万不要像我刚开始还总是想着“重复制造轮子”，幸好在师兄的指导下改正了过来。感激。</p>
<h2 id="参考整理自如下来源"><a href="#参考整理自如下来源" class="headerlink" title="参考整理自如下来源"></a>参考整理自如下来源</h2><ul>
<li><a href="http://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="external">http://www.cnblogs.com/2050/p/3877280.html</a></li>
<li><a href="http://blog.csdn.net/aiolos1111/article/details/51967744" target="_blank" rel="external">http://blog.csdn.net/aiolos1111/article/details/51967744</a></li>
<li><a href="http://ourjs.com/detail/54c73ba2232227083e00001a" target="_blank" rel="external">http://ourjs.com/detail/54c73ba2232227083e00001a</a></li>
<li><a href="https://github.com/jawil/blog/issues/21" target="_blank" rel="external">https://github.com/jawil/blog/issues/21</a></li>
<li><a href="http://ued.ourfuture.cn/fed/4200.html" target="_blank" rel="external">http://ued.ourfuture.cn/fed/4200.html</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/" target="_blank" rel="external">http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/</a></li>
<li><a href="http://www.jianshu.com/p/76130f4d7cf9" target="_blank" rel="external">http://www.jianshu.com/p/76130f4d7cf9</a></li>
<li><a href="https://yukun.im/css/469" target="_blank" rel="external">https://yukun.im/css/469</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/09/react为什么需要key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/09/react为什么需要key/" itemprop="url">
                  react为什么需要key
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T00:00:00+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多个react组件性能优化"><a href="#多个react组件性能优化" class="headerlink" title="多个react组件性能优化"></a>多个react组件性能优化</h2><h3 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h3><ol>
<li><p>当一个react组件被装载、更新和卸载时，组件的一系列生命周期函数会被调用。不过这些生命周期函数是针对某一个特定的react组件的函数，在一个应用中，从上到下有很多react组件组合起来，它们之间的渲染过程更加复杂。</p>
</li>
<li><p>其中，装载阶段基本上没有什么选择，当一个react组件第一次出现在DOM树中时，无论如何都是要彻底渲染一次的，从这个react组件往下的所有子组件，都要经历一遍react组件的装载生命周期，因为这部分的的工作没有什么可以省略的，所以没有多少性能优化的事情可以做。</p>
</li>
<li><p>至于卸载阶段，只有一个生命周期函数 <strong>componentWillUnmount</strong>，这个函数做的事情知识清理 <strong>componentDidMount</strong> 添加的事件处理监听等收尾工作，做的事情比装载过程要少很多，所以也没什么可以优化的空间。</p>
</li>
<li><p>所以值得关注的过程，就只剩下了更新过程。</p>
</li>
</ol>
<h3 id="1-2-react的调和-reconciliation-过程"><a href="#1-2-react的调和-reconciliation-过程" class="headerlink" title="1.2 react的调和(reconciliation)过程"></a>1.2 react的调和(reconciliation)过程</h3><p>react在更新阶段很巧妙地对比原有的 <strong>Virtual DOM</strong> 和新生成的 <strong>Virtual DOM</strong> ,找出两者的不同之处，根据不同来修改DOM树，这样只需要做做小的必要改动。react在更新这个“找不同”的过程，就叫做(reconciliation)过程。</p>
<h3 id="1-3-react的算法时间复杂度"><a href="#1-3-react的算法时间复杂度" class="headerlink" title="1.3 react的算法时间复杂度"></a>1.3 react的算法时间复杂度</h3><ol>
<li>Facebook推出的react之初打出的旗号之一就是“高性能”，所以react的(reconciliation)过程必须快速。但是，找出两个树形结构的区别，从计算机科学的角度来说，真的不是一件快速的事。</li>
<li>按照计算机科学目前的算法研究结果，对比两个N个节点的树形结构的算法，时间复杂度是 <strong>O(N^3)</strong>,打个比方，假如两个树形结构上各有100节点，那么找出这两个树形结构差别的操作，需要100*100*100次操作，也就是一百万次当量的操作，假如有一千个节点，那么需要相当于1000*1000*1000次操作，这是一亿次的操作当量，这么巨大数量的操作在强调快速反应的网页中是不可想象的，所以react不可能采用这样的算法。</li>
<li>react实际采用的算法需要的时间复杂度是 <strong>O(N)</strong> ，因为对比两个树形怎么着都要对比两个树形上的节点，似乎也不可能有比 <strong>O(N)</strong> 时间复杂度更低的算法。react采用的算法肯定不是最精准的，但是对于react英语的场景来说，绝对是性能和复杂度的最好折衷，让这个算法发挥作用，还需要开发者一点配合。</li>
<li>其实，react的reconciliation算法并不是很复杂，当react要对比两个 <strong>Virtual DOM</strong> 的树形结构的时候，从根节点开始递归往下比对，在树形结构上，每个阶段都可以看做一个这个阶段以下部分子树的根节点。所以其实这个对比算法可以从 <strong>Virtual DOM</strong> 上任何一个节点开始执行。</li>
</ol>
<h3 id="1-4-react检查两个树形结构的根节点的不同处理方式"><a href="#1-4-react检查两个树形结构的根节点的不同处理方式" class="headerlink" title="1.4 react检查两个树形结构的根节点的不同处理方式"></a>1.4 react检查两个树形结构的根节点的不同处理方式</h3><ol>
<li>节点类型不同的情况</li>
</ol>
<p>如果树形结构的根节点类型不相同，那就意味着改动太大了，也不需要去费心考虑是不是原来那个树形的根节点被移动到其他地方去了，直接认为原来那个树形结构会已经没用，可以扔掉，需要重新构建新的DOM树，原有的树形结构上的react组件都会经历“卸载”的生命周期。也就是，对于 <strong>Virtual DOM</strong> 树这是一个“更新”的过程，但是却可能引发这个树形结构上某些组件的“装载”和“卸载”过程。例如，在更新之前，组件的结构是这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todos</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们想要更新成这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todos</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么react会认为要废掉之前的div节点，包括下面的所有的子节点，一切推到重新来，重新构建一个span节点以及其子节点。看似浪费，但是为了避免 <strong>O(N^3)</strong> 的时间复杂度，react必须要选一个更简单更快的算法，也就只能用这种方式。</p>
<p>作为开发者，很显然要避免作为包裹功能的节点类型被随意改变。</p>
<ol>
<li>节点类型相同的情况</li>
</ol>
<p>如果两个树形结构的根节点类型相同，react就会认为原来的根节点只需要更新过程，不会将其卸载，也不会引发根节点的重新装载。这时候要区分一下节点类型。节点可以分为两类：一类是DOM元素类型对应的就是HTML直接支持的元素类型，比如div,span,p。另一类是react组件，也就是利用react库订制的类型。</p>
<p>对于DOM类型，react会保留节点对应的DOM元素，支队树形结构根节点上的树形和内容做一下对比，然后只更新修改的部分。<br>比如原来的jsx表示是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&#123;&#123;color:&quot;red&quot;,fontSize:16&#125;&#125; className=&quot;welcome&quot;&gt;</div><div class="line">    hello</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>改变后jsx表示是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&#123;&#123;color:&quot;green&quot;,fontSize:16&#125;&#125; className=&quot;farewell&quot;&gt;</div><div class="line">    good bye</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这两个的差别就是颜色和className发生了改变，在操作DOM树节点的时候，只修改这些发生变化的部分，让DOM操作尽可能少。</p>
<p>如果树形结构的根节点不是DOM元素类型，react所做的工作类似，只是react不知道如何去更新DOM树，因为这些逻辑还在react组件之中，react能做的只是根据新节点的props去更新原来根节点的组件实例，引发这个组件的实例的更新过程。也就会触发react更新阶段的生命周期函数，这个过程中，如果 <strong>shouldComponentUpdate</strong> 返回false。更新就会停止。</p>
<ol>
<li>多个子组件的情况</li>
</ol>
<p>当一个组件包含多个子组件的情况，react的处理方式也非常简单的直接。例如最初组件形态用jsx表示是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>更新之后，jsx表示是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;third&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>这种情况react的更新过程，只要 <strong>shouldComponentUpdate</strong> 使用恰当，可以避免实质性的更新操作。</p>
<p>但是，在序列前面增加一个 TodoItem实例的时候。需要更新后的形态jsx表示为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem text=&quot;zero&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>这种情况下，react会首先认为把text为first的组件实例的text改为zero，text为second的组件实例的text改为first，最后增加一个一个实例，text为second。这种情况下，<strong>shouldComponentUpdate</strong> 也无法判断是否返回false。想要增加一个组件实例，却引发了另外两个组件的更新。</p>
<p>这种情况，react的key就凸显出作用了。react通过这个key就能判断每一个组件在组件序列中的位置了。</p>
<p>上面的情况变为，最初形态为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem key=&#123;1&#125; text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;2&#125; text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>新增组件的时候,形态为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;TodoItem key=&#123;0&#125; text=&quot;zero&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;1&#125; text=&quot;first&quot; completed=&#123;false&#125; /&gt;</div><div class="line">    &lt;TodoItem key=&#123;2&#125; text=&quot;second&quot; completed=&#123;false&#125; /&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>react就知道把组件插在组件序列的第一位了。对原有的两个组件，只用props来启用更新过程，_shouldComponentUpdate__ 就能根据key来判断是否返回false来中断更新了，避免无用的更新操作了。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>所以，碰到数组-&gt;列表的映射，或是同级元素需要移位的情况，一定要给元素加上key属性！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="赖宝" />
          <p class="site-author-name" itemprop="name">赖宝</p>
           
              <p class="site-description motion-element" itemprop="description">努力学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖宝</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
