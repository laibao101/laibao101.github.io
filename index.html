<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="努力学习">
<meta property="og:type" content="website">
<meta property="og:title" content="赖宝的宝">
<meta property="og:url" content="http://blog.webtoatl.cn/index.html">
<meta property="og:site_name" content="赖宝的宝">
<meta property="og:description" content="努力学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赖宝的宝">
<meta name="twitter:description" content="努力学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.webtoatl.cn/"/>





  <title> 赖宝的宝 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖宝的宝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端技能分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/09/05/详解export default与require和exports,export区别与联系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/05/详解export default与require和exports,export区别与联系/" itemprop="url">
                  详解export default与require和exports,export区别与联系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-05T00:00:00+08:00">
                2017-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、首先搞清楚一个基本问题："><a href="#一、首先搞清楚一个基本问题：" class="headerlink" title="一、首先搞清楚一个基本问题："></a>一、首先搞清楚一个基本问题：</h2><p>module.exports和exports是属于CommonJS模块规范！（<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="external">不清楚commonjs?大神请这边逛一逛commonjs规范</a>）</p>
<p>export和export default是属于ES6语法（不清楚ES6?大神请这边逛一逛ES6模块）！</p>
<p>同样import和require分别属于ES6和CommonJS！</p>
<h2 id="二、知道属于哪一块的语法了还有一个明确点："><a href="#二、知道属于哪一块的语法了还有一个明确点：" class="headerlink" title="二、知道属于哪一块的语法了还有一个明确点："></a>二、知道属于哪一块的语法了还有一个明确点：</h2><p>module.exports和exports、export和export default都是导出模块；</p>
<p>import和require则是导入模块。</p>
<p>所以现在就不要弄混了，module.exports导出对应require导入，export导出对应import导入。</p>
<p>喂！等等，怎么才说到module.exports导出对应require导入，export导出对应import导入，那还有exports和export default呢！？那我们继续。</p>
<h2 id="三、module-exports和exports的区别与联系"><a href="#三、module-exports和exports的区别与联系" class="headerlink" title="三、module.exports和exports的区别与联系"></a>三、module.exports和exports的区别与联系</h2><p>讲到这里就不得不稍微提一下模块化：</p>
<p>Node应用由模块组成，采用CommonJS模块规范。</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value + x; &#125;;</div><div class="line"><span class="built_in">module</span>.exports.x = x;</div><div class="line"><span class="built_in">module</span>.exports.addX = addX;</div></pre></td></tr></table></figure>
<p>上面代码通过module.exports输出变量x和函数addX。</p>
<p>require方法用于加载模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5console.log(example.addX(1)); // 6</span></div></pre></td></tr></table></figure></p>
<p>看了刚刚这段commonjs规范上面的介绍可以知道以下区别与联系：</p>
<p>其实exports变量是指向module.exports，加载模块实际是加载该模块的module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</div></pre></td></tr></table></figure>
<p>于是我们可以直接在 <code>exports</code> 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<h2 id="三、export和export-default的区别与联系"><a href="#三、export和export-default的区别与联系" class="headerlink" title="三、export和export default的区别与联系"></a>三、export和export default的区别与联系</h2><p>模块功能主要由：export和import构成。export导出模块的对外接口，import命令导入其他模块暴露的接口。</p>
<p>export其实和export default就是写法上面有点差别，一个是导出一个个单独接口，一个是默认导出一个整体接口。使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。这里就有一个简单写法不用去知道有哪些具体的暴露接口名，就用export default命令，为模块指定默认输出。</p>
<p>export可以这样写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// testA.js</span></div><div class="line"><span class="keyword">var</span> f = <span class="string">'Miel'</span>;</div><div class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span>;</div><div class="line"><span class="keyword">var</span> data= <span class="number">1988</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;f, name, data&#125;;</div></pre></td></tr></table></figure></p>
<p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123;f, name, data&#125; <span class="keyword">from</span> <span class="string">'./testA'</span>;</div></pre></td></tr></table></figure>
<p>export default可以这样写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</div><div class="line"><span class="comment">// import-default.js</span></div><div class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</div><div class="line">customName(); <span class="comment">// 'foo'</span></div></pre></td></tr></table></figure></p>
<p>下面比较一下export default和export 输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一组</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">car</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> car <span class="keyword">from</span> <span class="string">'car'</span>; <span class="comment">// 输入</span></div><div class="line"></div><div class="line"><span class="comment">// 第二组</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">car2</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;car2&#125; <span class="keyword">from</span> <span class="string">'car2'</span>; <span class="comment">// 输入</span></div></pre></td></tr></table></figure></p>
<p>可以看到第一组是使用export default，import语句不需要使用大括号；第二组使用export，对应的import语句需要使用大括号，一个模块只能有一个默认输出，所以export default只能使用一次。</p>
<h2 id="四、import和require的区别与联系"><a href="#四、import和require的区别与联系" class="headerlink" title="四、import和require的区别与联系"></a>四、import和require的区别与联系</h2><p>看了上面其实已经清楚了，import和require是分别属于ES6和CommonJS的两种导入模块的语法而已。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/09/05/正向代理和反向代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/05/正向代理和反向代理/" itemprop="url">
                  正向代理和反向代理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-05T00:00:00+08:00">
                2017-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h1><p>最开始使用nginx相当懵，不清楚他的工作原理，最近在网上看了些相关资料，整理一下，方便理解和学习，首先从正向代理和反向代理开始。看了不少文章讲的都很绕，看了还是很晕，下面是知乎上的一篇文章，是我看过讲的比较清楚的一篇了。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>1 正向代理</p>
<p>正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。</p>
<p>2 反向代理</p>
<p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；而反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。</p>
<p>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见。</p>
<p>从上面的描述也能看得出来正向代理和反向代理最关键的两点区别：</p>
<ul>
<li>是否指定目标服务器</li>
<li>客户端是否要做设置</li>
</ul>
<p>下面用一张图来表示两者的差异：</p>
<p><img src="http://eden.dz11.com/xupload/xupload_1501912275000.jpeg" alt="剪贴板图片"></p>
<p>正向代理中，proxy和client同属一个LAN，对server透明； 反向代理中，proxy和server同属一个LAN，对client透明。 实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。</p>
<p>从用途上来区分：</p>
<ul>
<li>正向代理：正向代理用途是为了在防火墙内的局域网提供访问internet的途径。另外还可以使用缓冲特性减少网络使用率</li>
<li>反向代理：反向代理的用途是将防火墙后面的服务器提供给internet用户访问。同时还可以完成诸如负载均衡等功能</li>
</ul>
<p>从安全性来讲：</p>
<ul>
<li>正向代理：正向代理允许客户端通过它访问任意网站并且隐蔽客户端自身，因此你必须采取安全措施来确保仅为经过授权的客户端提供服务</li>
<li>反向代理：对外是透明的，访问者并不知道自己访问的是代理。对访问者而言，他以为访问的就是原始服务器</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</p>
<p>1 从上面的介绍也就可以猜出来正向代理的至少一个功能（俗称翻墙），也即：用户A无法访问facebook，但是能访问服务器B，而服务器B可以访问facebook。于是用户A访问服务器B，通过服务器B去访问facebook，，服务器B收到请求后，去访问facebook，facebook把响应信息返回给服务器B，服务器B再把响应信息返回给A。这样，通过代理服务器B，就实现了翻墙。</p>
<p>2 从上面的介绍也可以猜出来反向代理的至少一个功能（比如负载均衡），也即：假设用户A访问 www.somesite.com/something.html，但www.somesite.com’上并不存在something.html页面，于是接收用户请求的该服务器就偷偷从另外一台服务器上取回来，然后返回给用户，而用户并不知道something.html页面究竟位于哪台机器上。</p>
<p>3 反向代理的作用就比较多了，这里简单列举一下：</p>
<ul>
<li>保护和隐藏原始资源服务器</li>
<li>加密和SSL加速</li>
<li>负载均衡</li>
<li>缓存静态内容</li>
<li>压缩</li>
<li>减速上传</li>
<li>安全</li>
<li>外网发布</li>
</ul>
<p>下面做两个简单介绍</p>
<p>1 保护和隐藏原始资源服务器</p>
<p><img src="http://eden.dz11.com/xupload/xupload_1501912826000.jpeg" alt="剪贴板图片"></p>
<p>用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。</p>
<p>2 负载均衡</p>
<p><img src="http://eden.dz11.com/xupload/xupload_1501912892000.jpeg" alt="剪贴板图片"></p>
<p>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。</p>
<h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>透明代理比较类似正向代理的功能，差别在于客户端根本不知道代理的存在，它改编你的request，并会传送真实IP（使用场景就是公司限制网络的访问）。</p>
<p>比如为了工作效率或者安全，A公司屏蔽了QQ软件的使用。A公司的员工接上了网络，但发现无法使用qq。这就是透明代理捣的鬼。公司在内网和外网的中间插入一个透明代理，这个代理会根据规则抓取请求内容，遇到qq的请求我就把这个请求给屏蔽掉，这样就完成了透明屏蔽。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/09/05/blob对象介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/05/blob对象介绍/" itemprop="url">
                  blob对象介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-05T00:00:00+08:00">
                2017-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="blob对象介绍"><a href="#blob对象介绍" class="headerlink" title="blob对象介绍"></a>blob对象介绍</h1><p>一个 Blob对象表示一个不可变的, 原始数据的类似文件对象。Blob表示的数据不一定是一个JavaScript原生格式<br>blob对象本质上是js中的一个对象，里面可以储存大量的二进制编码格式的数据。</p>
<hr>
<h2 id="创建blob对象"><a href="#创建blob对象" class="headerlink" title="创建blob对象"></a>创建blob对象</h2><p>创建blob对象本质上和创建一个其他对象的方式是一样的，都是使用Blob() 的构造函数来进行创建。<br>构造函数接受两个参数：</p>
<p>第一个参数为一个数据序列，可以是任意格式的值。</p>
<p>第二个参数是一个包含两个属性的对象{<br>type: MIME的类型,<br>endings: 决定第一个参数的数据格式，可以取值为 “transparent” 或者 “native”（transparent的话不变，是默认值，native 的话按操作系统转换） 。<br>}</p>
<p>Blob()构造函数允许使用其他对象创建一个Blob对象，比如用字符串构建一个blob</p>
<pre><code>var debug = {hello: &quot;world&quot;};
var blob = new Blob([JSON.stringify(debug, null, 2)],
  {type : &apos;application/json&apos;});
</code></pre><p>既然是对象，那么blob也拥有自己的属性以及方法</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>Blob.isClosed (只读)</p>
<p>  布尔值，指示 Blob.close() 是否在该对象上调用过。 关闭的 blob 对象不可读。</p>
</li>
<li><p>Blob.size (只读)</p>
<p>  Blob 对象中所包含数据的大小（字节）。</p>
</li>
<li><p>Blob.type (只读)</p>
<p>  一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串。</p>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>Blob.close() </p>
<p>  关闭 Blob 对象，以便能释放底层资源。</p>
</li>
<li><p>Blob.slice([start[, end[, contentType]]])</p>
<p>  返回一个新的 Blob 对象，包含了源 Blob<br>对象中指定范围内的数据。其实就是对这个blob中的数据进行切割，我们在对文件进行分片上传的时候需要使用到这个方法。</p>
</li>
</ul>
<p>看到上面这些方法和属性，使用过HTML5提供的File接口的应该都很熟悉，这些属性和方法在File接口中也都有。<br>其实File接口就是基于Blob，继承blob功能并将其扩展为支持用户系统上的文件，也就是说：</p>
<p>==File接口中的Flie对象就是继承与Blob对象==。</p>
<h1 id="blob对象的使用"><a href="#blob对象的使用" class="headerlink" title="blob对象的使用"></a>blob对象的使用</h1><p>上面说了很多关于Blob对象的一些概念性的东西，下面我们来看看实际用途。</p>
<hr>
<h2 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h2><blockquote>
<p>首先说说分片上传，我们在进行文件上传的时候，因为服务器的限制，会限制每一次上传到服务器的文件大小不会很大，这个时候我们就需要把一个需要上传的文件进行切割，然后分别进行上传到服务器。</p>
</blockquote>
<p>假如需要做到这一步，我们需要解决两个问题:</p>
<ul>
<li>怎么切割?</li>
<li>怎么得知当前传输的进度?</li>
</ul>
<p>首先怎么切割的问题上面已经有过说明，因为File文件对象是继承与Blob对象的，因此File文件对象也拥有slice这个方法，我们可以使用这个方法将任何一个File文件进行切割。</p>
<p>代码如下：</p>
<pre><code>var BYTES_PER_CHUNK = 1024 * 1024; // 每个文件切片大小定为1MB .
var blob = document.getElementById(&quot;file&quot;).files[0];
var slices = Math.ceil(blob.size / BYTES_PER_CHUNK);
var blobs = [];
slices.forEach(function(item, index) {
    blobs.push(blob.slice(index,index + 1));
});
</code></pre><p>通过上面的方法。我们就得到了一个切割之后的File对象组成的数组blobs；</p>
<p>接下来要做的时候就是讲这些文件分别上传到服务器。</p>
<p>在HTTP1.1以上的协议中，有Transfer-Encoding这个编码协议，用以和服务器通信，来得知当前分片传递的文件进程。</p>
<p>这样解决了这两个问题，我们不仅可以对文件进行分片上传，并且能够得到文件上传的进度。</p>
<h2 id="粘贴图片"><a href="#粘贴图片" class="headerlink" title="粘贴图片"></a>粘贴图片</h2><blockquote>
<p>blob还有一个应用场景，就是获取剪切板上的数据来进行粘贴的操作。例如通过QQ截图后，需要在网页上进行粘贴操作。</p>
</blockquote>
<p>粘贴图片我们需要解决下面几个问题</p>
<ol>
<li><p>监听用户的粘贴操作</p>
</li>
<li><p>获取到剪切板上的数据</p>
</li>
<li><p>将获取到的数据渲染到网页中</p>
</li>
</ol>
<p>首先我们可以通过paste事件来监听用户的粘贴操作:</p>
<pre><code>document.addEventListener(&apos;paste&apos;, function (e) {
    console.info(e);
});
</code></pre><p>然后通过事件对象中的==clipboardData== 对象来获取图片的文件数据。</p>
<h3 id="clipboardData对象介绍"><a href="#clipboardData对象介绍" class="headerlink" title="clipboardData对象介绍"></a>clipboardData对象介绍</h3><p>介绍一下 clipboardData 对象，它实际上是一个 DataTransfer 类型的对象， DataTransfer 是拖动产生的一个对象，但实际上粘贴事件也是它。</p>
<h4 id="clipboardData-的属性介绍"><a href="#clipboardData-的属性介绍" class="headerlink" title="clipboardData 的属性介绍"></a>clipboardData 的属性介绍</h4><table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dropEffect</td>
<td style="text-align:center">String</td>
<td style="text-align:right">默认是 none</td>
</tr>
<tr>
<td>effectAllowed</td>
<td style="text-align:center">String</td>
<td style="text-align:right">默认是 uninitialized</td>
</tr>
<tr>
<td>files</td>
<td style="text-align:center">FileList</td>
<td style="text-align:right">粘贴操作为空List</td>
</tr>
<tr>
<td>items</td>
<td style="text-align:center">DataTransferItemList</td>
<td style="text-align:right">剪切板中的各项数据</td>
</tr>
<tr>
<td>types</td>
<td style="text-align:center">Array</td>
<td style="text-align:right">剪切板中的数据类型 该属性在Safari下比较混乱</td>
</tr>
</tbody>
</table>
<h3 id="items-介绍"><a href="#items-介绍" class="headerlink" title="items 介绍"></a>items 介绍</h3><p>items 是一个 DataTransferItemList 对象，自然里面都是 DataTransferItem 类型的数据了。</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>items 的 DataTransferItem 有两个属性 kind 和 type</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>kind</td>
<td style="text-align:center">一般为 string 或者 file</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">具体的数据类型，例如具体是哪种类型字符串或者哪种类型的文件，即 MIME-Type</td>
</tr>
</tbody>
</table>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">参数</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAsFile</td>
<td style="text-align:center">空</td>
<td style="text-align:right">如果 kind 是 file ，可以用该方法获取到文件</td>
</tr>
<tr>
<td>getAsString</td>
<td style="text-align:center">function(str)</td>
<td style="text-align:right">如果 kind 是 string ，可以用该方法获取到字符串str</td>
</tr>
</tbody>
</table>
<p>在原型上还有一些其他方法，不过在处理剪切板操作的时候一般用不到了。</p>
<h4 id="type-介绍"><a href="#type-介绍" class="headerlink" title="type 介绍"></a>type 介绍</h4><p>一般 types 中常见的值有 text/plain 、 text/html 、 Files 。</p>
<table>
<thead>
<tr>
<th>值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>text/plain</td>
<td style="text-align:center">普通字符串</td>
</tr>
<tr>
<td>text/html</td>
<td style="text-align:center">带有样式的html</td>
</tr>
<tr>
<td>Files</td>
<td style="text-align:center">文件(例如剪切板中的数据)</td>
</tr>
</tbody>
</table>
<p>有了上面这些方法，我们可以解决第二个问题即获取到剪切板上的数据。</p>
<pre><code>document.addEventListener(&apos;paste&apos;, function (e) {
    console.info(e);
    var cbd = e.clipboardData;
    for(var i = 0; i &lt; cbd.items.length; i++) {
        var item = cbd.items[i];
        console.info(item);
        if(item.kind == &quot;file&quot;){
            var blob = item.getAsFile();
            if (blob.size === 0) {
                return;
            }
            console.info(blob);
        }
    }
});
</code></pre><p>最后我们需要将获取到的数据渲染到网页上。</p>
<p>其实这个本质上就是一个类似于上传图片本地浏览的问题。我们可以直接通过HTML5的File接口将获取到的文件上传到服务器然后通过讲服务器返回的url地址来对图片进行渲染。也可以使用fileRender对象来进行图片本地浏览。</p>
<h3 id="fileRender对象简介"><a href="#fileRender对象简介" class="headerlink" title="fileRender对象简介"></a>fileRender对象简介</h3><p>从Blob中读取内容的唯一方法是使用 FileReader。</p>
<p>FileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align:center">参数</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>readAsBinaryString</td>
<td style="text-align:center">file</td>
<td style="text-align:right">将文件读取为二进制编码</td>
</tr>
<tr>
<td>readAsText</td>
<td style="text-align:center">file,[encoding]</td>
<td style="text-align:right">将文件读取为文本</td>
</tr>
<tr>
<td>readAsDataURL</td>
<td style="text-align:center">file</td>
<td style="text-align:right">将文件读取为DataURL</td>
</tr>
<tr>
<td>abort</td>
<td style="text-align:center">(none)</td>
<td style="text-align:right">终端读取操作</td>
</tr>
</tbody>
</table>
<p>FileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>on<x>abort</x></td>
<td style="text-align:center">中断</td>
</tr>
<tr>
<td>on<x>error</x></td>
<td style="text-align:center">出错</td>
</tr>
<tr>
<td>on<x>loadstart</x></td>
<td style="text-align:center">开始</td>
</tr>
<tr>
<td>onprogress</td>
<td style="text-align:center">正在读取</td>
</tr>
<tr>
<td>on<x>load</x></td>
<td style="text-align:center">成功读取</td>
</tr>
<tr>
<td>on<x>loadend</x></td>
<td style="text-align:center">读取完成，无论成功失败</td>
</tr>
</tbody>
</table>
<p>通过上面的方法以及事件，我们可以发现，通过readAsDataURL方法及on<x>load事件就可以拿到一个可本地浏览图片的DataURL。</x></p>
<p>最终代码如下：</p>
<pre><code>document.addEventListener(&apos;paste&apos;, function (e) {
    console.info(e);
    var cbd = e.clipboardData;
        var fr = new FileReader();
        var html = &apos;&apos;;
        for(var i = 0; i &lt; cbd.items.length; i++) {
            var item = cbd.items[i];
            console.info(item);
            if(item.kind == &quot;file&quot;){
                var blob = item.getAsFile();
                if (blob.size === 0) {
                    return;
                }
                console.info(blob);
                fr.readAsDataURL(blob);
                fr.on&lt;x&gt;load=function(e){
                    var result=document.getElementById(&quot;result&quot;);
                    //显示文件
                    result.innerHTML=&apos;&lt;img src=&quot;&apos; + this.result +&apos;&quot; alt=&quot;&quot; /&gt;&apos;;
                }
            }
        }
});
</code></pre><p>这样我们就可以监听到用户的粘贴操作，并且将用户粘贴的图片文件实时的渲染到网页之中了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是我对Blob对象的一些学习分享，希望在实际应用上能对大家有所帮助。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/09/01/js 深拷贝和浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/01/js 深拷贝和浅拷贝/" itemprop="url">
                  js 深拷贝和浅拷贝
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-01T00:00:00+08:00">
                2017-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://user-gold-cdn.xitu.io/2017/9/3/998e84124743f57f2f7e4005773baa0c?imageView2/0/w/1280/h/960" alt="image"></p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。</p>
<p>堆和栈都是内存中划分出来用来存储的区域。</p>
<blockquote>
<p>栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。</p>
</blockquote>
<h2 id="ECMAScript-的数据类型"><a href="#ECMAScript-的数据类型" class="headerlink" title="ECMAScript 的数据类型"></a>ECMAScript 的数据类型</h2><p>在将深拷贝和浅拷贝之前，我们先来重新回顾一下 ECMAScript 中的数据类型。主要分为</p>
<h3 id="基本数据类型（undefined，boolean，number，string，null）"><a href="#基本数据类型（undefined，boolean，number，string，null）" class="headerlink" title="基本数据类型（undefined，boolean，number，string，null）"></a>基本数据类型（undefined，boolean，number，string，null）</h3><p>基本数据类型主要是：undefined，boolean，number，string，null。</p>
<h3 id="基本数据类型存放在栈中"><a href="#基本数据类型存放在栈中" class="headerlink" title="基本数据类型存放在栈中"></a>基本数据类型存放在栈中</h3><p>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。</p>
<h3 id="基本数据类型值不可变"><a href="#基本数据类型值不可变" class="headerlink" title="基本数据类型值不可变"></a>基本数据类型值不可变</h3><blockquote>
<p>javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。</p>
</blockquote>
<p>基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> str = <span class="string">"abc"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str[<span class="number">1</span>]=<span class="string">"f"</span>);    <span class="comment">// f</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str);           <span class="comment">// abc</span></div></pre></td></tr></table></figure>
<p>这一点其实开始我是比较迷惑的，总是感觉 js 是一个灵活的语言，任何值应该都是可变的，真是图样图森破，我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。就如上述引用所说的那样，在 js 中没有方法是可以改变布尔值和数字的。倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。</p>
<p>所以，记住这一点：<strong>基本数据类型值不可变</strong></p>
<h3 id="基本类型的比较是值的比较"><a href="#基本类型的比较是值的比较" class="headerlink" title="基本类型的比较是值的比较"></a>基本类型的比较是值的比较</h3><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(a === b);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="基本数据类型存放在堆中"><a href="#基本数据类型存放在堆中" class="headerlink" title="基本数据类型存放在堆中"></a>基本数据类型存放在堆中</h3><p>引用类型（<strong>object</strong>）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;<span class="attr">name</span>:<span class="string">'jozo'</span>&#125;;</div><div class="line"><span class="keyword">var</span> person2 = &#123;<span class="attr">name</span>:<span class="string">'xiaom'</span>&#125;;</div><div class="line"><span class="keyword">var</span> person3 = &#123;<span class="attr">name</span>:<span class="string">'xiaoq'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/6fb2c3d13d830efc6ae07ac368df0816?imageView2/0/w/1280/h/960" alt="image"></p>
<h3 id="引用类型值可变"><a href="#引用类型值可变" class="headerlink" title="引用类型值可变"></a>引用类型值可变</h3><p>引用类型是可以直接改变其值的，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">a[<span class="number">1</span>] = <span class="number">5</span>;</div><div class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="引用类型的比较是引用的比较"><a href="#引用类型的比较是引用的比较" class="headerlink" title="引用类型的比较是引用的比较"></a>引用类型的比较是引用的比较</h3><p>所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/a32ee86b9f3e303216d19240441cedfd?imageView2/0/w/1280/h/960" alt="image"></p>
<h2 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h2><p>了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。<br>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line"></div><div class="line">a ++ ;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 11</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/8d973a9718da1806d19db0c1541ff425?imageView2/0/w/1280/h/960" alt="image"><br>所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。</p>
<p>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;; <span class="comment">// a保存了一个空对象的实例</span></div><div class="line"><span class="keyword">var</span> b = a;  <span class="comment">// a和b都指向了这个空对象</span></div><div class="line"></div><div class="line">a.name = <span class="string">'jozo'</span>;</div><div class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// 'jozo'</span></div><div class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">// 'jozo'</span></div><div class="line"></div><div class="line">b.age = <span class="number">22</span>;</div><div class="line"><span class="built_in">console</span>.log(b.age);<span class="comment">// 22</span></div><div class="line"><span class="built_in">console</span>.log(a.age);<span class="comment">// 22</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/01dad9dc00fb0efe81d9bcbe9d30a1bd?imageView2/0/w/1280/h/960" alt="image"></p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>在深入了解之前，我认为上面的赋值就是浅拷贝，哇哈哈，真的是图样图森破。上面那个应该只能算是“引用”，并不算是真正的浅拷贝。</p>
<h2 id="赋值（-）和浅拷贝的区别"><a href="#赋值（-）和浅拷贝的区别" class="headerlink" title="赋值（=）和浅拷贝的区别"></a>赋值（=）和浅拷贝的区别</h2><p>那么赋值和浅拷贝有什么区别呢，我们看下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    <span class="string">'name'</span> : <span class="string">'zhangsan'</span>,</div><div class="line">    <span class="string">'age'</span> :  <span class="string">'18'</span>,</div><div class="line">    <span class="string">'language'</span> : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]],</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dst = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</div><div class="line">        <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</div><div class="line">            dst[prop] = src[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj2.name = <span class="string">"lisi"</span>;</div><div class="line">obj3.age = <span class="string">"20"</span>;</div><div class="line"></div><div class="line">obj2.language[<span class="number">1</span>] = [<span class="string">"二"</span>,<span class="string">"三"</span>];</div><div class="line">obj3.language[<span class="number">2</span>] = [<span class="string">"四"</span>,<span class="string">"五"</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj1);  </div><div class="line"><span class="comment">//obj1 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'lisi',</span></div><div class="line"><span class="comment">//    'age' :  '18',</span></div><div class="line"><span class="comment">//    'language' : [1,["二","三"],["四","五"]],</span></div><div class="line"><span class="comment">//&#125;;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj2);</div><div class="line"><span class="comment">//obj2 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'lisi',</span></div><div class="line"><span class="comment">//    'age' :  '18',</span></div><div class="line"><span class="comment">//    'language' : [1,["二","三"],["四","五"]],</span></div><div class="line"><span class="comment">//&#125;;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj3);</div><div class="line"><span class="comment">//obj3 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'zhangsan',</span></div><div class="line"><span class="comment">//    'age' :  '20',</span></div><div class="line"><span class="comment">//    'language' : [1,["二","三"],["四","五"]],</span></div><div class="line"><span class="comment">//&#125;;</span></div></pre></td></tr></table></figure></p>
<p>先定义个一个原始的对象 <strong>obj1</strong>，然后使用赋值得到第二个对象 <strong>obj2</strong>，然后通过浅拷贝，将 <strong>obj1</strong> 里面的属性都赋值到 <strong>obj3</strong> 中。也就是说：</p>
<ul>
<li>obj1：原始数据</li>
<li>obj2：赋值操作得到</li>
<li>obj3：浅拷贝得到</li>
</ul>
<p>然后我们改变 <strong>obj2</strong> 的 <strong>name</strong> 属性和 <strong>obj3</strong> 的 <strong>name</strong> 属性，可以看到，改变赋值得到的对象 <strong>obj2</strong> 同时也会改变原始值 <strong>obj1</strong>，而改变浅拷贝得到的的 <strong>obj3</strong> 则不会改变原始对象 <strong>obj1</strong>。这就可以说明赋值得到的对象 <strong>obj2</strong> 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 <strong>obj3</strong> 则是重新创建了新对象。</p>
<p>然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 <strong>obj2</strong> 和浅拷贝得到的 <strong>obj3</strong> 中的 <strong>language</strong> 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 <strong>obj2</strong> 和浅拷贝得到的 <strong>obj3</strong> 都会改变原始数据。</p>
<p>这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 <strong>obj3</strong> 中的引用类型时，会使原始数据得到改变。</p>
<p>深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，</p>
<p>浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象</p>
<table>
<thead>
<tr>
<th>–</th>
<th>和原数据是否指向同一对象</th>
<th>第一层数据为基本数据类型</th>
<th>原数据中包含子对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>赋值</td>
<td>是</td>
<td>改变会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>浅拷贝</td>
<td>否</td>
<td>改变不会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>深拷贝</td>
<td>否</td>
<td>改变不会使原数据一同改变</td>
<td>改变不会使原数据一同改变</td>
</tr>
</tbody>
</table>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>看了这么半天，你也应该清楚什么是深拷贝了吧，如果还不清楚，我就剖腹自尽(ಥ_ಥ)</p>
<p>深拷贝是对对象以及对象的所有子对象进行拷贝。</p>
<p>那么问题来了，怎么进行深拷贝呢？</p>
<p>思路就是递归调用刚刚的浅拷贝，把所有属于对象的属性类型都遍历赋给另一个对象即可。我们直接来看一下 Zepto 中深拷贝的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内部方法：用户合并一个或多个对象到第一个对象</span></div><div class="line"><span class="comment">// 参数：</span></div><div class="line"><span class="comment">// target 目标对象  对象都合并到target里</span></div><div class="line"><span class="comment">// source 合并对象</span></div><div class="line"><span class="comment">// deep 是否执行深度合并</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> source)</div><div class="line">    <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</div><div class="line">        <span class="comment">// source[key] 是对象，而 target[key] 不是对象， 则 target[key] = &#123;&#125; 初始化一下，否则递归会出错的</span></div><div class="line">        <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</div><div class="line">            target[key] = &#123;&#125;</div><div class="line"></div><div class="line">        <span class="comment">// source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的</span></div><div class="line">        <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</div><div class="line">            target[key] = []</div><div class="line">        <span class="comment">// 执行递归</span></div><div class="line">        extend(target[key], source[key], deep)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Copy all but undefined properties from one or more</span></div><div class="line"><span class="comment">// objects to the `target` object.</span></div><div class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">//第一个参数为boolean值时，表示是否深度合并</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</div><div class="line">    deep = target;</div><div class="line">    <span class="comment">//target取第二个参数</span></div><div class="line">    target = args.shift()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 遍历后面的参数，都合并到target上</span></div><div class="line">args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123; extend(target, arg, deep) &#125;)</div><div class="line"><span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Zepto 中的 <strong>$.extend</strong> 方法判断的第一个参数传入的是一个布尔值，判断是否进行深拷贝。</p>
<p>在 <strong>$.extend</strong> 方法内部，只有一个形参 <strong>target</strong>，这个设计你真的很巧妙。<br>因为形参只有一个，所以 target 就是传入的第一个参数的值，并在函数内部设置一个变量 args 来接收去除第一个参数的其余参数，如果该值是一个布尔类型的值的话，说明要启用深拷贝，就将 deep 设置为 true，并将 target 赋值为 args 的第一个值（也就是真正的 target）。如果该值不是一个布尔类型的话，那么传入的第一个值仍为 target 不需要进行处理，只需要遍历使用 extend 方法就可以。</p>
<p>这里有点绕，但是真的设计的很精妙，建议自己打断点试一下，会有意外收获（玩转 js 的大神请忽略）。</p>
<p>而在 extend 的内部，是拷贝的过程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/08/JavaScript 专题之如何判断两个对象相等/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/08/JavaScript 专题之如何判断两个对象相等/" itemprop="url">
                  JavaScript 专题之如何判断两个对象相等
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T00:00:00+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然标题写的是如何判断两个对象相等，但本篇我们不仅仅判断两个对象相等，实际上，我们要做到的是如何判断两个参数相等，而这必然会涉及到多种类型的判断。</p>
<h2 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h2><p>什么是相等？，我们认为只要 === 的结果为 true，两者就相等，然而今天我们重新定义相等：</p>
<p>我们认为：</p>
<p>NaN 和 NaN 是相等<br>[1] 和 [1] 是相等<br>{value: 1} 和 {value: 1} 是相等<br>不仅仅是这些长得一样的，还有</p>
<p>1 和 new Number(1) 是相等<br>‘Curly’ 和 new String(‘Curly’) 是相等<br>true 和 new Boolean(true) 是相等<br>更复杂的我们会在接下来的内容中看到。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们的目标是写一个 eq 函数用来判断两个参数是否相等，使用效果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>];</div><div class="line"><span class="built_in">console</span>.log(eq(a, b)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>在写这个看似很简单的函数之前，我们首先了解在一些简单的情况下是如何判断的？</p>
<h2 id="0-与-0"><a href="#0-与-0" class="headerlink" title="+0 与 -0"></a>+0 与 -0</h2><p>如果 a === b 的结果为 true， 那么 a 和 b 就是相等的吗？一般情况下，当然是这样的，但是有一个特殊的例子，就是 +0 和 -0。</p>
<p>JavaScript “处心积虑”的想抹平两者的差异：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 表现1</span></div><div class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 表现2</span></div><div class="line">(<span class="number">-0</span>).toString() <span class="comment">// '0'</span></div><div class="line">(+<span class="number">0</span>).toString() <span class="comment">// '0'</span></div><div class="line"></div><div class="line"><span class="comment">// 表现3</span></div><div class="line"><span class="number">-0</span> &lt; +<span class="number">0</span> <span class="comment">// false</span></div><div class="line">+<span class="number">0</span> &lt; <span class="number">-0</span> <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>即便如此，两者依然是不同的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> / +<span class="number">0</span> <span class="comment">// Infinity</span></div><div class="line"><span class="number">1</span> / <span class="number">-0</span> <span class="comment">// -Infinity</span></div><div class="line"></div><div class="line"><span class="number">1</span> / +<span class="number">0</span> === <span class="number">1</span> / <span class="number">-0</span> <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>也许你会好奇为什么要有 +0 和 -0 呢？</p>
<p>这是因为 JavaScript 采用了IEEE_754 浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，按照这个标准，最高位是符号位(0 代表正，1 代表负)，剩下的用于表示大小。而对于零这个边界值 ，1000(-0) 和 0000(0)都是表示 0 ，这才有了正负零的区别。</p>
<p>也许你会好奇什么时候会产生 -0 呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.round(-0.1) // -0</div></pre></td></tr></table></figure></p>
<p>那么我们又该如何在 === 结果为 true 的时候，区别 0 和 -0 得出正确的结果呢？我们可以这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>在本篇，我们认为 NaN 和 NaN 是相等的，那又该如何判断出 NaN 呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>利用 NaN 不等于自身的特性，我们可以区别出 NaN，那么这个 eq 函数又该怎么写呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="eq-函数"><a href="#eq-函数" class="headerlink" title="eq 函数"></a>eq 函数</h2><p>现在，我们已经可以去写 eq 函数的第一版了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// eq 第一版</span></div><div class="line"><span class="comment">// 用来过滤掉简单的类型比较，复杂的对象使用 deepEq 函数进行处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// === 结果为 true 的区别出 +0 和 -0</span></div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line"></div><div class="line">    <span class="comment">// typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断 NaN</span></div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line"></div><div class="line">    <span class="comment">// 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false</span></div><div class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</div><div class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更复杂的对象使用 deepEq 函数进行深度比较</span></div><div class="line">    <span class="keyword">return</span> deepEq(a, b);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>也许你会好奇是不是少了一个 <strong>typeof b !== function</strong>?<br>试想如果我们添加上了这句，当 a 是基本类型，而 b 是函数的时候，就会进入 deepEq 函数，而去掉这一句，就会进入直接进入 false，实际上 基本类型和函数肯定是不会相等的，所以这样做代码又少，又可以让一种情况更早退出。</p>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><p>现在我们开始写 deepEq 函数，一个要处理的重大难题就是 ‘Curly’ 和 new String(‘Curly’) 如何判断成相等？</p>
<p>两者的类型都不一样呐！不信我们看 typeof 的操作结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'Curly'</span>); <span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>)); <span class="comment">// object</span></div></pre></td></tr></table></figure></p>
<p>可是我们还有更多的方法判断类型，比如 Object.prototype.toString：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line">toString.call(<span class="string">'Curly'</span>); <span class="comment">// "[object String]"</span></div><div class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>)); <span class="comment">// "[object String]"</span></div></pre></td></tr></table></figure></p>
<p>神奇的是使用 toString 方法两者判断的结果却是一致的，可是就算知道了这一点，还是不知道如何判断字符串和字符串包装对象是相等的呢？</p>
<p>那我们利用隐式类型转换呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Curly'</span> + <span class="string">''</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>) + <span class="string">''</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>看来我们已经有了思路：如果 a 和 b 的 Object.prototype.toString的结果一致，并且都是”[object String]”，那我们就使用 ‘’ + a === ‘’ + b 进行判断。</p>
<p>可是不止有 String 对象呐，Boolean、Number、RegExp、Date呢？</p>
<h2 id="更多对象"><a href="#更多对象" class="headerlink" title="更多对象"></a>更多对象</h2><p>跟 String 同样的思路，利用隐式类型转换。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="regexp">/a/i</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/i</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">''</span> + a === <span class="string">''</span> + b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>嗯哼？你确定 Number 能这么简单的判断？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(+a === +b); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>可是 a 和 b 应该被判断成 true 的呐~</p>
<p>那么我们就改成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断 Number(NaN) Object(NaN) 等情况</span></div><div class="line">    <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">    <span class="comment">// 其他判断 ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="deepEq-函数"><a href="#deepEq-函数" class="headerlink" title="deepEq 函数"></a>deepEq 函数</h2><p>现在我们可以写一点 deepEq 函数了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> className = toString.call(a);</div><div class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (className) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object String]'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</div><div class="line">            <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">            <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</div><div class="line">      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</div><div class="line">      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</div><div class="line">            <span class="keyword">return</span> +a === +b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其他判断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="构造函数实例"><a href="#构造函数实例" class="headerlink" title="构造函数实例"></a>构造函数实例</h2><p>我们看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Kevin'</span>);</div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Kevin'</span>);</div><div class="line"></div><div class="line">eq(person, animal) <span class="comment">// ???</span></div></pre></td></tr></table></figure></p>
<p>虽然 <strong>person</strong> 和 <strong>animal</strong> 都是 <strong>{name: ‘Kevin’}</strong>，但是 <strong>person</strong> 和 <strong>animal</strong> 属于不同构造函数的实例，为了做出区分，我们认为是不同的对象。</p>
<p>如果两个对象所属的构造函数对象不同，两个对象就一定不相等吗？</p>
<p>并不一定，我们再举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attrs = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">attrs.name = <span class="string">"Bob"</span>;</div><div class="line">eq(attrs, &#123;<span class="attr">name</span>: <span class="string">"Bob"</span>&#125;); <span class="comment">// ???</span></div></pre></td></tr></table></figure></p>
<p>尽管 <strong>attrs</strong> 没有原型，<strong>{name: “Bob”}</strong> 的构造函数是 <strong>Object</strong>，但是在实际应用中，只要他们有着相同的键值对，我们依然认为是相等。</p>
<p>从函数设计的角度来看，我们不应该让他们相等，但是从实践的角度，我们让他们相等，所以相等就是一件如此随意的事情吗？！对啊，我也在想：<strong>undersocre</strong>，你怎么能如此随意呢！！！</p>
<p>哎，吐槽完了，我们还是要接着写这个相等函数，我们可以先做个判断，对于不同构造函数下的实例直接返回 <strong>false</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Function]'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 接着上面的内容</span></div><div class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</div><div class="line">    <span class="comment">// 不是数组</span></div><div class="line">    <span class="keyword">if</span> (!areArrays) &#123;</div><div class="line">        <span class="comment">// 过滤掉两个函数的情况</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</div><div class="line">        <span class="comment">// aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦</span></div><div class="line">        <span class="keyword">if</span> (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下面还有好多判断</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组相等"><a href="#数组相等" class="headerlink" title="数组相等"></a>数组相等</h2><p>现在终于可以进入我们期待已久的数组和对象的判断，不过其实这个很简单，就是递归遍历一遍……<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 再接着上面的内容</span></div><div class="line">    <span class="keyword">if</span> (areArrays) &#123;</div><div class="line"></div><div class="line">        length = a.length;</div><div class="line">        <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            <span class="keyword">if</span> (!eq(a[length], b[length])) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">         &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a), key;</div><div class="line">        length = keys.length;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            key = keys[length];</div><div class="line">            <span class="keyword">if</span> (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key]))) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>如果觉得这就结束了，简直是太天真，因为最难的部分才终于要开始，这个问题就是循环引用！</p>
<p>举个简单的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="attr">abc</span>: <span class="literal">null</span>&#125;;</div><div class="line">b = &#123;<span class="attr">abc</span>: <span class="literal">null</span>&#125;;</div><div class="line">a.abc = a;</div><div class="line">b.abc = b;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>再复杂一点的，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="attr">foo</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">foo</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">foo</span>: <span class="literal">null</span>&#125;&#125;&#125;&#125;&#125;;</div><div class="line">b = &#123;<span class="attr">foo</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">foo</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">foo</span>: <span class="literal">null</span>&#125;&#125;&#125;&#125;&#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>为了给大家演示下循环引用，大家可以把下面这段已经精简过的代码复制到浏览器中尝试：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// demo</span></div><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a === b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> deepEq(a, b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a);</div><div class="line">    <span class="keyword">var</span> length = keys.length;</div><div class="line">    <span class="keyword">var</span> key;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        key = keys[length]</div><div class="line"></div><div class="line">        <span class="comment">// 这是为了让你看到代码其实一直在执行</span></div><div class="line">        <span class="built_in">console</span>.log(a[key], b[key])</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!eq(a[key], b[key])) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">eq(a, b)</div></pre></td></tr></table></figure></p>
<p>嗯，以上的代码是死循环。</p>
<p>那么，我们又该如何解决这个问题呢？underscore 的思路是 eq 的时候，多传递两个参数为 aStack 和 bStack，用来储存 a 和 b 递归比较过程中的 a 和 b 的值，咋说的这么绕口呢？<br>我们直接看个精简的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a === b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    aStack = aStack || [];</div><div class="line">    bStack = bStack || [];</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = aStack.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        <span class="keyword">if</span> (aStack[length] === a) &#123;</div><div class="line">              <span class="keyword">return</span> bStack[length] === b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.push(a);</div><div class="line">    bStack.push(b);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a);</div><div class="line">    <span class="keyword">var</span> length = keys.length;</div><div class="line">    <span class="keyword">var</span> key;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        key = keys[length]</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(a[key], b[key], aStack, bStack)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!eq(a[key], b[key], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// aStack.pop();</span></div><div class="line">    <span class="comment">// bStack.pop();</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b))</div></pre></td></tr></table></figure></p>
<p>之所以注释掉 <strong>aStack.pop()</strong>和<strong>bStack.pop()</strong>这两句，是为了方便大家查看 <strong>aStack</strong>  <strong>bStack</strong>的值。</p>
<h2 id="最终的-eq-函数"><a href="#最终的-eq-函数" class="headerlink" title="最终的 eq 函数"></a>最终的 eq 函数</h2><p>最终的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Function]'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// === 结果为 true 的区别出 +0 和 -0</span></div><div class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</div><div class="line"></div><div class="line">    <span class="comment">// typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数</span></div><div class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断 NaN</span></div><div class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</div><div class="line"></div><div class="line">    <span class="comment">// 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false</span></div><div class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</div><div class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更复杂的对象使用 deepEq 函数进行深度比较</span></div><div class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// a 和 b 的内部属性 [[class]] 相同时 返回 true</span></div><div class="line">    <span class="keyword">var</span> className = toString.call(a);</div><div class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (className) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object String]'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</div><div class="line">            <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</div><div class="line">            <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</div><div class="line">            <span class="keyword">return</span> +a === +b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</div><div class="line">    <span class="comment">// 不是数组</span></div><div class="line">    <span class="keyword">if</span> (!areArrays) &#123;</div><div class="line">        <span class="comment">// 过滤掉两个函数的情况</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> aCtor = a.constructor,</div><div class="line">            bCtor = b.constructor;</div><div class="line">        <span class="comment">// aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦</span></div><div class="line">        <span class="keyword">if</span> (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    aStack = aStack || [];</div><div class="line">    bStack = bStack || [];</div><div class="line">    <span class="keyword">var</span> length = aStack.length;</div><div class="line"></div><div class="line">    <span class="comment">// 检查是否有循环引用的部分</span></div><div class="line">    <span class="keyword">while</span> (length--) &#123;</div><div class="line">        <span class="keyword">if</span> (aStack[length] === a) &#123;</div><div class="line">            <span class="keyword">return</span> bStack[length] === b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.push(a);</div><div class="line">    bStack.push(b);</div><div class="line"></div><div class="line">    <span class="comment">// 数组判断</span></div><div class="line">    <span class="keyword">if</span> (areArrays) &#123;</div><div class="line"></div><div class="line">        length = a.length;</div><div class="line">        <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">            <span class="keyword">if</span> (!eq(a[length], b[length], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对象判断</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(a),</div><div class="line">            key;</div><div class="line">        length = keys.length;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line"></div><div class="line">            key = keys[length];</div><div class="line">            <span class="keyword">if</span> (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aStack.pop();</div><div class="line">    bStack.pop();</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="built_in">Number</span>(<span class="literal">NaN</span>), <span class="built_in">Number</span>(<span class="literal">NaN</span>))); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(<span class="string">'Curly'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>))); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq([<span class="number">1</span>], [<span class="number">1</span>])); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(eq(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;)); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a, b;</div><div class="line"></div><div class="line">a = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">b = &#123; <span class="attr">foo</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">foo</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125; &#125; &#125; &#125; &#125;;</div><div class="line">a.foo.b.foo.c.foo = a;</div><div class="line">b.foo.b.foo.c.foo = b;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(eq(a, b)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>真让人感叹一句：eq 不愧是 underscore 中实现代码行数最多的函数了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/08/HTTP Header 详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/08/HTTP Header 详解/" itemprop="url">
                  HTTP Header 详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T00:00:00+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTP（HyperTextTransferProtocol）即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message- header，即http header消息 。http header 消息通常被分为4个部分：general  header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。</p>
<h2 id="Requests部分"><a href="#Requests部分" class="headerlink" title="Requests部分"></a>Requests部分</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: user@email.com</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: www.zcmhi.com</td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="external">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2 id="Responses-部分"><a href="#Responses-部分" class="headerlink" title="Responses 部分"></a>Responses 部分</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/03/JavaScript的原型及原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/03/JavaScript的原型及原型链/" itemprop="url">
                  JavaScript的原型及原型链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 javascript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ 一文中我们提到了在没有类概念的 JavaScript 语言中是通过原型来实现面向对象的继承特性。只要运用得好，这种基于原型的 JavaScript 继承模型比传统的类继承还要强大。所以我们还需详细学习一下原型的知识</p>
<h2 id="JavaScript-的对象"><a href="#JavaScript-的对象" class="headerlink" title="JavaScript 的对象"></a>JavaScript 的对象</h2><p>JavaScript 是基于对象的面向对象语言。因此在这里的“对象”既可以是普通对象（Object），也可以是函数对象（Function）。JS 抛弃了 Java 的类概念，而 Java 的继承恰恰是通过类来实现的。那么 JS 没有类的概念，就使用了“原型”的概念来实现继承。</p>
<h3 id="字面量原型及原型链"><a href="#字面量原型及原型链" class="headerlink" title="字面量原型及原型链"></a>字面量原型及原型链</h3><p>JS 可通过字面量构造对象。为了实现继承，对象里面有个<em>proto</em>属性可以指向该对象的父对象。这个父对象就是所谓的“原型”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animal = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'动物'</span>,</div><div class="line">  <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" is eating"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">animal.eat();     <span class="comment">// animal is eating</span></div><div class="line"><span class="keyword">var</span> dog = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'狗'</span>,</div><div class="line">  <span class="attr">_proto_</span>: animal</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> cat = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'猫'</span>,</div><div class="line">  <span class="attr">_proto_</span>: animal</div><div class="line">&#125;;</div><div class="line">dog.eat();        <span class="comment">// 狗 is eating</span></div><div class="line">cat.eat();        <span class="comment">// 猫 is eating</span></div></pre></td></tr></table></figure>
<p>由上面代码我们可以看出：dog 和 cat 对象的原型都是 animal。但是 dog 和 cat 对象都没有定义 eat()方法，那怎么可以调用呢？其实当eat方法被调用的时候，先在自己的方法列表中寻找， 如果找不到，就去找原型中的方法， 如果原型中找不到， 就去原型的原型中去寻找…… 最后找到Object那里， 如果还找不到， 那就是未定义了。这几个对象通过<em>proto</em>属性建立一个原型链！<br><img src="http://ww1.sinaimg.cn/large/7b6c9535gy1fhwi3i5lirj20gt0f8dif.jpg" alt="image"></p>
<h2 id="构造函数原型及原型链"><a href="#构造函数原型及原型链" class="headerlink" title="构造函数原型及原型链"></a>构造函数原型及原型链</h2><p>但是为了迁就 C++、Java、C# 程序员，让 JavaScript 可以像 Java 那样 new （构造）出一个对象出来，于是这里做了一个变通，也提供了构造函数。例子如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Student(name,grade)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.grade = grade;</div><div class="line">  this.sayHello = function()&#123;</div><div class="line">    console.log('Hi,I'm ' + this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">andy = new Student('Andy',5);</div><div class="line">lisa = new Student('Lisa',5);</div><div class="line">andy.sayHello();    //Hi,I'm Andy</div><div class="line">lisa.sayHello();    //Hi,I'm Lisa</div><div class="line">    </div><div class="line">//假设 andy 和 lisa 是同班同学，同时即将升入六年级</div><div class="line">andy.grade = 6;</div><div class="line">console.log(andy.grade);   // 6</div><div class="line">console.log(lisa.grade);   // 5</div></pre></td></tr></table></figure></p>
<p>由上面的代码所示，我们可以看出这个所谓的构造函数已经很有 Java 类的感觉了。但是这里面存在两个问题：在对象里面定义方法，这样每创建一个对象都会一个sayHello()函数，这样来说显得对象臃肿，浪费资源；同时每个对象各自保有自己的属性和函数的副本，无法做到属性和方法共享。因此，这里有一个更加高效的办法就是把对象共享的属性和方法可以放到 Student.prototype 这个对象当中。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Student.prototype = &#123;</div><div class="line">  <span class="attr">grade</span>: <span class="number">5</span>,</div><div class="line">  <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I'm "</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/*也可以写成</span></div><div class="line">Student.prototype.grade = 5;</div><div class="line">Student.prototype.sayHello = function()&#123;</div><div class="line">  console.log("Hi, I'm "+this.name);</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> Student(<span class="string">"Andy"</span>);</div><div class="line"><span class="keyword">var</span> lisa = <span class="keyword">new</span> Student(<span class="string">"Lisa"</span>);</div><div class="line">andy.sayHello();      <span class="comment">//Hi, I'm Andy</span></div><div class="line">lisa.sayHello();      <span class="comment">//Hi, I'm Lisa</span></div><div class="line">Student.prototype.grade = <span class="number">6</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Andy's grade: "</span>+ andy.grade);    <span class="comment">// 6</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Lisa's grade: "</span>+ Lisa.grade);    <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/7b6c9535gy1fi6yabvn3vj20rn0ogdhf.jpg" alt="image"><br>由上面的代码和示意图可看出这个所谓的构造函数 Student 其实就是一个幌子啊， 每次去new Student的时候，确实会创建一个对象出来（ andy 或者 lisa ) ， 并且把这个对象的原型指针(<em>proto</em>)指向 Student.prototype 这个对象，这样一来就能找到sayHello()方法了。我们应该还知道上面的构造函数Student()对象（JS 中函数也是对象）会创建一个 prototype 对象（Student.prototype），而 new 出来的实例对象例如 andy 和 lisa 是没有这个 prototype 对象，但是他会有个 proto 属性（<em>proto</em>）指向这个构造函数对象的 prototype 对象，从而构成原型链。实例对象其实是通过原型对象与构造函数取得联系的。为了让 Java、C#、C++ 程序员降低学习成本，JavaScript 提供了语法糖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">  sayHello()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I'm "</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> Student(<span class="string">"andy"</span>);   </div><div class="line">andy.sayHello();                     <span class="comment">//Hi, I'm andy</span></div></pre></td></tr></table></figure></p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="built_in">console</span>.log(a);                 <span class="comment">//&#123;&#125;</span></div><div class="line">a.name = <span class="string">'Zhiyu'</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="built_in">console</span>.log(b);                 <span class="comment">//&#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b.name);            <span class="comment">//Zhiyu</span></div></pre></td></tr></table></figure>
<p>上面我们可以看出该方法是创建一个空对象，空对象的原型是create()参数。此时创建的空对象会有个(<em>proto</em>)属性指向方法参数，这样也可以构成一个原型链。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _ _proto__ 的内置属性，用于指向创建它的函数对象的原型对象 prototype</li>
<li>原型和原型链是 JS 实现继承的一种模型</li>
<li>原型链是靠 proto 形成的，而不是 prototype</li>
<li>所有的原型对象都有 constructor 属性，该属性对应创建所有指向该原型的实例构造函数</li>
<li>函数对象和原型对象通过 prototype 和 constructor 属性进行相互关联</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/03/如何监听页面 DOM 变动并高效响应/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/03/如何监听页面 DOM 变动并高效响应/" itemprop="url">
                  如何监听页面 DOM 变动并高效响应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="从-DOM-变动事件监听说起"><a href="#从-DOM-变动事件监听说起" class="headerlink" title="从 DOM 变动事件监听说起"></a>从 DOM 变动事件监听说起</h3><p>首先假设大家已经知道 JavaScript 中事件的发生阶段（捕获-命中-冒泡），附上一张图带过这个内容，我们直接进入寻找解决方法的过程。</p>
<p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt=""></p>
<p><em><a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" target="_blank" rel="external">Graphical representation of an event dispatched in a DOM tree using the DOM event flow</a></em></p>
<p>开始的时候我一直在 window 状态改变涉及到的事件中寻找，一圈搜寻下来发现也就 <code>onload</code> 事件最接近了，所以我们看看 MDN 对该事件的定义：</p>
<blockquote>
<p>The load event is fired when a resource and its dependent resources have finished loading.</p>
</blockquote>
<p>怎么理解资源及其依赖资源已加载完毕呢？简单来说，如果一个页面涉及到图片资源，那么 onload 事件会在页面完全载入（包括图片、css文件等等）后触发。一个简单的监听事件用 JavaScript 应该这样书写（注意不同环境下 load 和 onload 的差异）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"All resources finished loading!"</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="comment">// or</span></div><div class="line">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"All resources finished loading!"</span>);</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="comment">// HTML</span></div><div class="line">  &lt;body onload=<span class="string">"SomeJavaScriptCode"</span>&gt;</div><div class="line">  </div><div class="line">  <span class="comment">// jQuery</span></div><div class="line">  $( <span class="built_in">window</span> ).on( <span class="string">"load"</span>, handler )</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>当然，说到 <code>onload</code> 事件，有一个 jQuery 中相似的事件一定会被提及—— <code>ready</code> 事件。jQuery 中这样定义这个事件：</p>
<blockquote>
<p>Specify a function to execute when the DOM is fully loaded.</p>
</blockquote>
<p>需要知道的是 jQuery 定义的 <code>ready</code> 事件实质上是为 <code>DOMContentLoaded</code> 事件设计的，所以当我们谈论加载时应该区分的事件其实是 <code>onload</code>（接口 UIEvent） 以及 <code>DOMContentLoaded</code>（接口 Event），MDN 这样描述 <code>DOMContentLoaded</code>：</p>
<blockquote>
<p>当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。</p>
</blockquote>
<p>所以可以知道，当一个页面加载时应先触发 <code>DOMContentLoaded</code> 然后才是 <code>onload</code>. 类似的事件及区别包括以下几类：</p>
<ul>
<li><strong>DOMContentLoaded</strong>: 当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载；</li>
<li><strong>readystatechange</strong>: 一个document 的 Document.readyState 属性描述了文档的加载状态，当这个状态发生了变化，就会触发该事件；</li>
<li><strong>load</strong>: 当一个资源及其依赖资源已完成加载时，将触发load事件；</li>
<li><strong>beforeunload</strong>: 当浏览器窗口，文档或其资源将要卸载时，会触发beforeunload事件。</li>
<li><strong>unload</strong>: 当文档或一个子资源正在被卸载时, 触发 unload事件。</li>
</ul>
<p>细心点会发现上面在介绍事件时提到了 UIEvent 以及 Event，这是什么呢？这些都是事件——可以被 JavaScript 侦测到的行为。其他的事件接口还包括 KeyboardEvent ／ VRDisplayEvent （是的，没错，这就是你感兴趣且熟知的那个 VR）等等；如果在搜索引擎中稍加搜索，你会发现有些资料里写到事件可以分为以下几类：</p>
<ul>
<li>UI事件</li>
<li>焦点事件</li>
<li>鼠标与滚轮事件</li>
<li>键盘与文本事件</li>
<li>复合事件</li>
<li>变动事件</li>
<li>HTML5 事件</li>
<li>设备事件</li>
<li>触摸与手势事件</li>
</ul>
<p>但这样写实在有些凌乱，其中一些是 DOM3 定义的事件，有一些是单独列出的事件，如果你觉得熟悉那么你会发现这是 JavaScript 高级程序设计里的叙述模式，在我看来，理解这些事件可以按照 DOM3 事件以及其他事件来做区分：其中，DOM3 级事件规定了以下几类事件 - UI 事件, 焦点事件, 鼠标事件, 滚轮事件, 文本事件, 键盘事件, 合成事件, 变动事件, 变动名称事件; 而剩下的例如 HTML5 事件可以单独做了解。而刚开始提到的 Event 作为一个主要接口，是很多事件的实现父类。有关 Web API 接口可以在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="external">这里</a>查到，里面可以看到有很多 Event 字眼。</p>
<p>好吧，事件说了这么多，我们还是没有解决刚开始提出的问题，如果监听页面中动态生成的元素呢？想到动态生成的元素都是需要通过网络请求获取资源的，那么是否可以监听所有 HTTP 请求呢？查看 jQuery 文档可以知道每当一个Ajax请求完成，jQuery 就会触发 ajaxComplete 事件，在这个时间点所有处理函数会使用 .ajaxComplete() 方法注册并执行。但是谁能保证所有 ajax 都从 jQuery 走呢？所以应该在<strong>变动事件</strong>中做出选择，我们来看看 DOM2 定义的如下变动事件：</p>
<ul>
<li><strong>DOMSubtreeModified</strong>: 在DOM结构发生任何变化的时候。这个事件在其他事件触发后都会触发；</li>
<li><strong>DOMNodeInserted</strong>: 当一个节点作为子节点被插入到另一个节点中时触发；</li>
<li><strong>DOMNodeRemoved</strong>: 在节点从其父节点中移除时触发；</li>
<li><strong>DOMNodeInsertedIntoDocument</strong>: 在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在 DOMNodeInserted 之后触发；</li>
<li><strong>DOMNodeRemovedFromDocument</strong>: 在一个节点被直接从文档移除或通过子树间接从文档移除之前触发。这个事件在 DOMNodeRemoved 之后触发；</li>
<li><strong>DOMAttrModified</strong>: 在特性被修改之后触发；</li>
<li><strong>DOMCharacterDataModified</strong>: 在文本节点的值发生变化时触发；</li>
</ul>
<p>所以，用 DOMSubtreeModified 好像没错。师兄旁边提醒，用 <strong>MutationObserver</strong>, 于是又搜到了一个新大陆。MDN 这样描述 MutationObserver：</p>
<blockquote>
<p>MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</p>
</blockquote>
<p>DOM3 事件规范中的 Mutation 事件可以被简单看成是 DOM2 事件规范中定义的 Mutation 事件的一个扩展，但是这些都不重要了，因为他们都要被 MutationObserver 替代了。好了，那么来详细介绍一下 MutationObserver 吧。文章《<a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="external">Mutation Observer API</a>》对 MutationObserver 的用法介绍的比较详细，所以我挑几点能直接解决我们需求的说一说。</p>
<p>既然要监听 DOM 的变化，我们来看看 Observer 的作用都有哪些：</p>
<blockquote>
<p>它等待所有脚本任务完成后，才会运行，即采用异步方式。</p>
<p>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条地个别处理 DOM 变动。</p>
<p>它既可以观察发生在 DOM 的所有类型变动，也可以观察某一类变动。</p>
</blockquote>
<p>MutationObserver 的构造函数比较简单，传入一个回调函数即可（回调函数接受两个参数，第一个是变动数组，第二个是观察器实例）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</div></pre></td></tr></table></figure>
<p>观察器实例使用 <code>observe</code> 方法来监听， <code>disconnect</code> 方法停止监听，<code>takeRecords</code> 方法来清除变动记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> article = <span class="built_in">document</span>.body;</div><div class="line"></div><div class="line"><span class="keyword">let</span>  options = &#123;</div><div class="line">  <span class="string">'childList'</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">'attributes'</span>:<span class="literal">true</span></div><div class="line">&#125; ;</div><div class="line"></div><div class="line">observer.observe(article, options);</div></pre></td></tr></table></figure>
<p><code>observe</code> 方法中第一个参数是所要观察的变动 DOM 元素，第二个参数则接收所要观察的变动类型（子节点变动和属性变动）。变动类型包括以下几种：</p>
<ul>
<li>childList：子节点的变动。</li>
<li>attributes：属性的变动。</li>
<li>characterData：节点内容或节点文本的变动。</li>
<li>subtree：所有后代节点的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在 option 对象中指定它的值为 true。需要注意的是，如果设置观察 subtree 的变动，必须同时指定  childList、attributes 和 characterData 中的一种或多种。<code>disconnect</code> 方法和 <code>takeRecords</code> 方法则直接调用即可，无传入参数。</p>
<p>好的，我们已经搞定了 DOM 变动的监听，将代码刷新一下看下效果吧，因为页面由很多动态生成的商品组成，那么我应该在 body 上添加变动监听，所以 options 应该这样设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">	&apos;attributes&apos;: true,</div><div class="line">	&apos;subtree&apos;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咦？页面往下拉一小点就触发了 observer 几十次？这样 DOM 哪吃得消啊，查看了页面的变动记录发现每次新进的资源底层都调用了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore" target="_blank" rel="external">Node.insertBefore()</a> 方法…</p>
<h3 id="再聊聊-JavaScript-中的截流／节流函数"><a href="#再聊聊-JavaScript-中的截流／节流函数" class="headerlink" title="再聊聊 JavaScript 中的截流／节流函数"></a>再聊聊 JavaScript 中的截流／节流函数</h3><p>现在遇到的一个麻烦是， DOM 变动太频繁了，如果每次变动都监听那真是太耗费资源了。一个简单的解决办法是我就放弃监听了，而采用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" target="_blank" rel="external">setInterval</a> 方法定时执行更新逻辑。是的，虽然方法原始了一点，但是性能上比 Observer “改进”了不少。</p>
<p>这个时候，又来了师兄的助攻：“用用截流函数”。记起之前看《<a href="https://book.douban.com/subject/3590768/" target="_blank" rel="external">JavaScript 语言精粹</a>》的时候看到是用 <code>setTimeout</code> 方法自调用来解决 <code>setInteval</code> 的频繁执行吃资源的现象，不知道两者是不是有关联。网上一查发现有两个“jie流函数”。需求来自于这里：</p>
<blockquote>
<p>在前端开发中，页面有时会绑定scroll或resize事件等频繁触发的事件，也就意味着在正常的操作之内，会多次调用绑定的程序，然而有些时候javascript需要处理的事情特别多，频繁出发就会导致性能下降、成页面卡顿甚至是浏览器奔溃。</p>
</blockquote>
<p>如果重复利用 setTimeout 和 clearTimeout 方法，我们好像可以解决这个频繁触发的执行。每次事件触发的时候我首先判断一下当前有没有一个 setTimeout 定时器，如果有的话我们先将它清除，然后再新建一个 setTimeout 定时器来延迟我的响应行为。这样听上去还不错，因为我们每次都不立即执行我们的响应，而频繁触发过程我们又能保持响应函数一直存在（且只存在一个），除了会有些延迟响应外，没什么不好的。是的这就是<strong>截流函数（debounce）</strong>，有一篇<a href="http://www.cnblogs.com/ambar/archive/2011/10/08/throttle-and-debounce.html" target="_blank" rel="external">博客</a>用这个小故事介绍它：</p>
<blockquote>
<p>形像的比喻是橡皮球。如果手指按住橡皮球不放，它就一直受力，不能反弹起来，直到松手。debounce 的关注点是空闲的间隔时间。</p>
</blockquote>
<p>在我的业务中，在 observer 实例中调用下面写的这个截流函数就可以啦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* fn 执行函数</div><div class="line">* context 绑定上下文</div><div class="line">* timeout 延时数值</div><div class="line">**/</div><div class="line"><span class="keyword">let</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context, timeout</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> timer;</div><div class="line">    </div><div class="line">    <span class="comment">// 利用闭包将内容传递出去</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (timer) &#123;</div><div class="line">		    <span class="comment">// 清除定时器</span></div><div class="line">			clearTimeout(timer); </div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// 设置一个新的定时器</span></div><div class="line">		timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			fn.apply(context, <span class="built_in">arguments</span>)</div><div class="line">		&#125;, timeout);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，解决了自己的问题，但还有一个概念没有说到——“节流函数”。同一篇博文里也使用了一个例子来说明它：</p>
<blockquote>
<p>形像的比喻是水龙头或机枪，你可以控制它的流量或频率。throttle 的关注点是连续的执行间隔时间。</p>
</blockquote>
<p>函数节流的原理也挺简单，一样还是定时器。当我触发一个时间时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就清除原来的定时器，再setTimeout一个新的定时器延迟一会执行。函数节流的出发点，就是让一个函数不要执行得太频繁，减少一些过快的调用来节流。这里引用 <a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="external">AlloyTeam</a> 的节流代码实现来解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数同上</span></div><div class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay, mustRunDelay</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line"> <span class="keyword">var</span> t_start;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> 	<span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>, t_curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 清除定时器</span></div><div class="line"> 	clearTimeout(timer);</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 函数初始化判断</span></div><div class="line"> 	<span class="keyword">if</span>(!t_start)&#123;</div><div class="line"> 		t_start = t_curr;</div><div class="line"> 	&#125;</div><div class="line"> 	</div><div class="line"> 	<span class="comment">// 超时（指定的时间间隔）判断</span></div><div class="line"> 	<span class="keyword">if</span>(t_curr - t_start &gt;= mustRunDelay)&#123;</div><div class="line"> 		fn.apply(context, args);</div><div class="line"> 		t_start = t_curr;</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="keyword">else</span> &#123;</div><div class="line"> 		timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> 			fn.apply(context, args);</div><div class="line"> 		&#125;, delay);</div><div class="line"> 	&#125;</div><div class="line"> &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当然，AlloyTeam 那篇文章将这里所说的截流函数作为节流函数的 V1.0 版本，你也可以这样认为。毕竟，设置了必然触发执行的时间间隔（即 mustRunDelay 函数），可以使得截流函数不会在“疯狂事件”情况下无止境的循环下去。</p>
<p>Observer 和截流函数一结合，问题解决啦嘿嘿。当然还有很多坑，下次再开一篇说说吧。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/load" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Events/load</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></li>
<li><a href="http://www.cnblogs.com/fsjohnhuang/p/4147810.html" target="_blank" rel="external">http://www.cnblogs.com/fsjohnhuang/p/4147810.html</a></li>
<li><a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="external">http://www.alloyteam.com/2012/11/javascript-throttle/</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/08/02/一个故事讲完 Https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/02/一个故事讲完 Https/" itemprop="url">
                  一个故事讲完 Https
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T00:00:00+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想起上个月面试官问我了不了解 Https，当时对 HTTP 都不太熟的我只能说”No”。当我看完计算机网络教材的时候，又恰巧看见了微信公众号码农翻身的此篇推送，让我受益良多。</p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>今天来聊一聊https 安全传输的原理。</p>
<p>在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。</p>
<p>这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。</p>
<p>此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心……</p>
<p>张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 The Divided State of America ……</p>
<p>Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样…..</p>
<p>两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。</p>
<h2 id="总是有一种被偷看的感觉"><a href="#总是有一种被偷看的感觉" class="headerlink" title="总是有一种被偷看的感觉"></a>总是有一种被偷看的感觉</h2><p>有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。</p>
<p>张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了? 估计已经被人截取了吧！”</p>
<p>Bill 提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ”<br><img src="http://i1.buimg.com/1949/ade6db4481ac227a.png" alt="image"><br>张大胖冰雪聪明，一看就明白了， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！”</p>
<p>（码农翻身注：这叫对称加密算法， 因为加密和解密用的是同一个密钥）</p>
<p>一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！”</p>
<p>Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？”</p>
<p>张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？　</p>
<p>“奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？”　</p>
<p>“哈哈， 这倒是终极解决之道 ” Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ”</p>
<p>张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！</p>
<p>可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！</p>
<h2 id="RSA：非对称加密"><a href="#RSA：非对称加密" class="headerlink" title="RSA：非对称加密"></a>RSA：非对称加密</h2><p>Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的非对称加密算法，一下子来了灵感。</p>
<p>这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。</p>
<p>更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。<br><img src="http://i1.buimg.com/1949/5e8c39e7ca86956d.png" alt="image"><br>有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ）<br><img src="http://i1.buimg.com/1949/43e126b0647a1475.png" alt="image"><br>反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。</p>
<p>这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。</p>
<h2 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密+对称加密"></a>非对称加密+对称加密</h2><p>两人实验了几次， 张大胖说： “Bill , 你有没有感觉这个RSA的加密和解密有点慢啊？”</p>
<p>Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了”</p>
<p>“回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走　(1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信, 如何？ ”</p>
<p>Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。”　</p>
<p>于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！</p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>张大胖把和Bill 聊天的情况给老婆汇报了一次。</p>
<p>老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?”</p>
<p>张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。”</p>
<p>老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密，　那中间人不就可以解密看到消息了？＂</p>
<p>张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill , Bill和我根本都意识不到， 还以为我们在安全传输呢！</p>
<p><img src="http://i1.buimg.com/1949/a58bf0d069be1226.png" alt="image"></p>
<p>看来问题出现在公钥的分发上！ 虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！</p>
<h2 id="你到底是谁"><a href="#你到底是谁" class="headerlink" title="你到底是谁"></a>你到底是谁</h2><p>但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？</p>
<p>可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。</p>
<p>怎么声明呢？</p>
<p>张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。</p>
<p>这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！</p>
<p>这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！</p>
<p>可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？</p>
<p>张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。</p>
<p>天无绝人之路， 张大胖很快就找到了突破口： 数字签名。</p>
<p>简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。<br><img src="http://i1.buimg.com/1949/b1bb655d23b8c5cc.png" alt="image"><br>可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？”</p>
<p>张大胖说你别得意的太早 ， 我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名：<br><img src="http://i1.buimg.com/1949/38d3543e8ee28c6e.png" alt="image"><br>这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书”<br><img src="http://i1.buimg.com/1949/e7a1c438c1108a01.png" alt="image"><br>张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！</p>
<p>如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。</p>
<p>虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。<br><img src="http://i1.buimg.com/1949/495b3241682bbe98.png" alt="image"><br>中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？　难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？　如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。”</p>
<p>张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！</p>
<p>不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。</p>
<p>（公众号码农翻身注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。）</p>
<h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><p>终于可以介绍https了，前面已经介绍了https的原理， 你把张大胖替换成浏览器， 把Bill 替换成某个网站就行了。</p>
<p>一个简化的（例如下图没有包含Pre-Master Secret）https流程图是这样的， 如果你理解了前面的原理，这张图就变得非常简单：<br><img src="http://i1.buimg.com/1949/ecbc530393f88118.png" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.webtoatl.cn/2017/07/30/MasterPromise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖宝">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖宝的宝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/30/MasterPromise/" itemprop="url">
                  Master Promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T00:00:00+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"create a promise"</span></div><div class="line"><span class="string">"after new Promise"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。</p>
<h2 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    resolve(<span class="number">2</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    reject(<span class="number">3</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1);</div><div class="line"><span class="built_in">console</span>.log(p2);</div><div class="line"><span class="built_in">console</span>.log(p3);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p2);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p3);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">2</span>&#125;</div><div class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"rejected"</span>, [[PromiseValue]]: <span class="number">3</span>&#125;</div></pre></td></tr></table></figure></p>
<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h2 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success1"</span>);</div><div class="line">  resolve(<span class="string">"success2"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">  reject(<span class="string">"reject"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"success1"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(“success2”)并不能将p1的值更改为success2，p2中reject(“reject”)也不能将p2的状态由resolved改变为rejected.</p>
<h2 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="string">"resolve"</span></div><div class="line"><span class="string">"reject: reject"</span></div></pre></td></tr></table></figure></p>
<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li><strong>return</strong>  一个同步的值 ，或者 <strong>undefined</strong>（当没有返回一个有效值时，默认返回undefined），<strong>then</strong>方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li><strong>return</strong> 另一个 Promise，<strong>then</strong>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
</ul>
<p>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p>
<h2 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"which one is called first ?"</span></div><div class="line"><span class="string">"success"</span></div></pre></td></tr></table></figure></p>
<p>Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h2 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  foo.bar();</div><div class="line">  resolve( <span class="number">1</span> );      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve( <span class="number">2</span> );    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</div><div class="line">    foo.bar();</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p1 then err: <span class="built_in">ReferenceError</span>: foo is not defined</div><div class="line">p2 then value: <span class="number">2</span></div><div class="line">p1 then then value: <span class="literal">undefined</span></div><div class="line">p2 then then err: <span class="built_in">ReferenceError</span>: foo is not defined</div><div class="line">p2 then then then value: <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>Promise中的异常由<strong>then</strong>参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，<strong>then</strong>返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级<strong>then</strong>的回调函数是交替执行的 ，这正是由Promise <strong>then</strong>回调的异步性决定的。</p>
<h2 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</div><div class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(p1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1 === p2); </div><div class="line"><span class="built_in">console</span>.log(p1 === p3);</div><div class="line"><span class="built_in">console</span>.log(p1 === p4);</div><div class="line"><span class="built_in">console</span>.log(p3 === p4);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">false</span></div><div class="line">p2=<span class="number">1</span></div><div class="line">p1=<span class="number">1</span></div><div class="line">p4=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p><strong>Promise.resolve(…)</strong>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的<strong>then</strong>最先调用，但在控制台上是最后输出结果的呢？因为p4的<strong>resolve</strong>中接收的参数是一个Promise对象p1，<strong>resolve</strong>会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h2 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p3.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p3 rejected: [object <span class="built_in">Promise</span>]</div><div class="line">p1 fulfilled: resolve</div><div class="line">p2 rejected: reject</div></pre></td></tr></table></figure></p>
<p>Promise回调函数中的第一个参数<strong>resolve</strong>，会对Promise执行”拆箱”动作。即当<strong>resolve</strong>的参数是一个Promise对象时，<strong>resolve</strong>会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是<strong>resolved</strong>，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是<strong>rejected</strong>，因此<strong>rejected</strong>回调被执行。但Promise回调函数中的第二个参数<strong>reject</strong>不具备”拆箱“的能力，<strong>reject</strong>的参数会直接传递给<strong>then</strong>方法中的<strong>rejected</strong>回调。因此，即使p3 <strong>reject</strong>接收了一个<strong>resolved</strong>状态的Promise，<strong>then</strong>方法中被调用的依然是<strong>rejected</strong>，并且参数就是<strong>reject</strong>接收到的Promise对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="赖宝" />
          <p class="site-author-name" itemprop="name">赖宝</p>
           
              <p class="site-description motion-element" itemprop="description">努力学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖宝</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
